<!DOCTYPE html>
<html>
<head>
  <title>
    ucore lab1实验小结 - The Tao of Jason
  </title>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  
  <link rel="shortcut icon" href="/favicon.ico" />
  

  <link rel="stylesheet" href="/css/utils/clear.css">
  <link rel="stylesheet" href="/css/style.css">

  <link href="https://google-fonts.mirrors.sjtug.sjtu.edu.cn/css2?family=Noto+Sans+SC:wght@100;300;400;500;700;900&display=swap" rel="stylesheet">

  <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
  <link href="https://cdn.bootcss.com/highlight.js/9.15.6/styles/default.min.css" rel="stylesheet">
</head>

<body>
  <div class="title">
  <img class="title_img" src="/images/icon.png"/><br>
  <p id="site_title">&nbspThe Tao of Jason&nbsp</p>
</div>

  <div class="navi">
    <a id="navi_item" href="/#" class="menu-item-link">Home</a>
    <a id="navi_item" href="/tags" class="menu-item-link">Tags</a>
    <a id="navi_item" href="/about" class="menu-item-link">About</a>
    <a id="navi_item" href="/search" class="menu-item-link">Search</a>
    
        <a id="navi_item" href="/friendlink" class="menu-item-link">Friendlink</a>
    
</div>

<hr/>


  <div class="main">
    <link rel="stylesheet" href="/css/post.css">
<post>

  <div class="post_title">
    ucore lab1实验小结
  </div>

  <br/><br/>

  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/styles/xcode.min.css">
  <script src="/js/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  

  <div id="post_content">
    <h3 id="0-序言"><a href="#0-序言" class="headerlink" title="0 序言"></a>0 序言</h3><p>一直感觉自己这操作系统学的一点也不扎实：（，果然之前秋招提前批被教育了，所以痛定思痛有了本系列文章，CS之路漫漫兮，吾将上下而求索~</p>
<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h3><h4 id="1-1-BIOS"><a href="#1-1-BIOS" class="headerlink" title="1.1 BIOS"></a>1.1 BIOS</h4><p>BIOS实际上是被固化在计算机ROM（只读存储器）芯片上的一个特殊的软件，为上层软件提供最底层的、最直接的硬件控制与支持。更形象地说，BIOS就是PC计算机硬件与上层软件程序之间的一个”桥梁”，负责访问和控制硬件。（BIOS以系统调用trap的形式提供IO 且 只能存在于系统的实模式下）</p>
<h4 id="1-2-BIOS是如何启动的"><a href="#1-2-BIOS是如何启动的" class="headerlink" title="1.2 BIOS是如何启动的"></a>1.2 BIOS是如何启动的</h4><p><img src="/images/ucore_01/bios.jpg" alt=""><br>首先我们必须明白计算机加电的时候是从哪读出第一条指令的，以x86为例，CPU根据CS（代码段寄存器）,IP（指令指针寄存器）的值计算得出<font color="red">PC=16*CS + IP</font>,此时PC为20位的二进制值（因为在实模式下只有20根地址总线，所以只能寻址1MB），在X86架构中 CS:IP 用来表示寻址（这里的PC就是一个概念上的寻址寄存器，实际递增的是IP寄存器），在ARM架构中PC寄存器是存在的（R15），得到地址取出地址中的执行，这条指令是个跳转指令，通过跳转指令跳到BIOS例行程序起始点。BIOS做完计算机硬件自检和初始化后，会选择一个启动设备（例如软盘、硬盘、光盘等），并且读取该设备的第一扇区(即主引导扇区或启动扇区)到内存一个特定的地址0x7c00处，然后CPU控制权会转移到那个地址继续执行。至此BIOS的初始化工作做完了，进一步的工作交给了ucore的bootloader。</p>
<h4 id="1-3-BIOS是如何启动系统的"><a href="#1-3-BIOS是如何启动系统的" class="headerlink" title="1.3 BIOS是如何启动系统的"></a>1.3 BIOS是如何启动系统的</h4><p><img src="/images/ucore_01/bios start.jpg" alt=""></p>
<ol>
<li>BIOS将bootloader（加载程序）从磁盘的主引导扇区(MBR)加载到内存0x7c00</li>
<li>跳转到0000（CS）:7c00（IP）</li>
<li>执行2中地址的bootloader</li>
<li>初始化各种寄存器，禁用中断，使能A20（拓宽地址总线宽度），加载GDT，使能cr0进入保护模式，修改保护模式下的各寄存器值，设置堆栈调用bootmain.c</li>
<li>加载elf格式的OS</li>
</ol>
<h3 id="2-分析make生成执行文件的过程"><a href="#2-分析make生成执行文件的过程" class="headerlink" title="2 分析make生成执行文件的过程"></a>2 分析make生成执行文件的过程</h3><h4 id="2-1-分析操作系统镜像文件ucore-img是如何一步一步生成的？"><a href="#2-1-分析操作系统镜像文件ucore-img是如何一步一步生成的？" class="headerlink" title="2.1 分析操作系统镜像文件ucore.img是如何一步一步生成的？"></a>2.1 分析操作系统镜像文件ucore.img是如何一步一步生成的？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   // 生成系统镜像</span><br><span class="line">UCOREIMG    := $(call totarget,ucore.img)</span><br><span class="line"></span><br><span class="line">$(UCOREIMG): $(kernel) $(bootblock)</span><br><span class="line">$(V)dd if=/dev/zero of=$@ count=10000 // 创建一个大小为10000字节的串</span><br><span class="line">$(V)dd if=$(bootblock) of=$@ conv=notrunc // 将bootblock默认写入第一个块</span><br><span class="line">$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc  // 将kernel默认写入第二个块</span><br><span class="line"></span><br><span class="line">$(call create_target,ucore.img)</span><br><span class="line"></span><br><span class="line"> // 生成kernel</span><br><span class="line">kernel = $(call totarget,kernel)</span><br><span class="line"></span><br><span class="line">$(kernel): tools/kernel.ld</span><br><span class="line"></span><br><span class="line">$(kernel): $(KOBJS)</span><br><span class="line">	@echo + ld $@</span><br><span class="line">	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)</span><br><span class="line">	@$(OBJDUMP) -S $@ &gt; $(call asmfile,kernel)</span><br><span class="line">	@$(OBJDUMP) -t $@ | $(SED) &apos;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&apos; &gt; $(call symfile,kernel)</span><br><span class="line"></span><br><span class="line">$(call create_target,kernel)</span><br><span class="line"></span><br><span class="line">// 创建启动块</span><br><span class="line">bootfiles = $(call listf_cc,boot)</span><br><span class="line">$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))</span><br><span class="line"></span><br><span class="line">bootblock = $(call totarget,bootblock)</span><br><span class="line"></span><br><span class="line">$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)</span><br><span class="line">@echo + ld $@</span><br><span class="line">$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)</span><br><span class="line">@$(OBJDUMP) -S $(call objfile,bootblock) &gt; $(call asmfile,bootblock)</span><br><span class="line">@$(OBJDUMP) -t $(call objfile,bootblock) | $(SED) &apos;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&apos; &gt; $(call symfile,bootblock)</span><br><span class="line">@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)</span><br><span class="line">@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)</span><br><span class="line"></span><br><span class="line">$(call create_target,bootblock)</span><br></pre></td></tr></table></figure>
<h4 id="2-2-一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><a href="#2-2-一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？" class="headerlink" title="2.2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"></a>2.2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</h4><ol>
<li>主引导记录MBR的大小为512字节</li>
<li>MBR结束字为[0x55 0xAA]<br>在tool/sign.c中可以很清晰的看到MBR的结束标志字（55AA）2字节以及主引导记录大小512字节<br><img src="/images/ucore_01/MBR.jpg" alt=""><h3 id="3-调试BIOS的加载"><a href="#3-调试BIOS的加载" class="headerlink" title="3 调试BIOS的加载"></a>3 调试BIOS的加载</h3></li>
</ol>
<p>实验步骤如下：</p>
<ol>
<li>qemu -hda ucore.img -s -S  # 打开qemu并附加参数-s设置连接端口1234</li>
<li>gdb </li>
<li>target remote localhost:1234 # gdb连接qemu（也可忽略前三步直接make debug）</li>
<li>输入 b  *0x7c00设置断点</li>
<li>continue</li>
<li>x/i $pc # 查看一条当前的指令<br>可以看到0x7c00处的代码和bootasm.S处的代码一致<br><img src="/images/ucore_01/init.jpg" alt=""><br><img src="/images/ucore_01/bootasm.jpg" alt=""></li>
</ol>
<h3 id="4-分析bootloader进入保护模式的过程"><a href="#4-分析bootloader进入保护模式的过程" class="headerlink" title="4 分析bootloader进入保护模式的过程"></a>4 分析bootloader进入保护模式的过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># start address should be 0:7c00, in real mode, the beginning address of the running bootloader</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">.code16                                             # Assemble for 16-bit mode</span><br><span class="line">    cli                                             # Disable interrupts</span><br><span class="line">    cld                                             # String operations increment</span><br><span class="line"></span><br><span class="line">    # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">    xorw %ax, %ax                                   # Segment number zero</span><br><span class="line">    movw %ax, %ds                                   # -&gt; Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; Extra Segment</span><br><span class="line">    movw %ax, %ss                                   # -&gt; Stack Segment</span><br><span class="line"></span><br><span class="line">    # Enable A20:</span><br><span class="line">    #  For backwards compatibility with the earliest PCs, physical</span><br><span class="line">    #  address line 20 is tied low, so that addresses higher than</span><br><span class="line">    #  1MB wrap around to zero by default. This code undoes this.</span><br><span class="line">seta20.1:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    outb %al, $0x64                                 # 0xd1 means: write data to 8042&apos;s P2 port</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">    outb %al, $0x60                                 # 0xdf = 11011111, means set P2&apos;s A20 bit(the 1 bit) to 1</span><br><span class="line"></span><br><span class="line">    # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">    # and segment translation that makes virtual addresses</span><br><span class="line">    # identical to physical addresses, so that the</span><br><span class="line">    # effective memory map does not change during the switch.</span><br><span class="line">    lgdt gdtdesc</span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $CR0_PE_ON, %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line"></span><br><span class="line">    # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">    # Switches processor into 32-bit mode.</span><br><span class="line">    ljmp $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure>
<p>根据代码注释可以总结得bootloaer进入保护模式的流程为：</p>
<ol>
<li>禁用中断</li>
<li>复位标志寄存器</li>
<li>初始化ds，es，ss三个段（设置为0）</li>
<li>使能A20（扩大寻址空间）</li>
<li>跳转到gdtdes中，加载GDT（全局描述符表）</li>
<li>使能cr0，切换到保护模式</li>
</ol>
<h3 id="5-分析bootloader加载ELF格式的OS的过程"><a href="#5-分析bootloader加载ELF格式的OS的过程" class="headerlink" title="5 分析bootloader加载ELF格式的OS的过程"></a>5 分析bootloader加载ELF格式的OS的过程</h3><h4 id="5-2-elf文件格式"><a href="#5-2-elf文件格式" class="headerlink" title="5.2 elf文件格式"></a>5.2 elf文件格式</h4><p><img src="/images/ucore_01/elf.png" alt=""><br><img src="/images/ucore_01/elf_seek.png" alt=""></p>
<h4 id="5-1-bootloader如何读取硬盘扇区的？"><a href="#5-1-bootloader如何读取硬盘扇区的？" class="headerlink" title="5.1 bootloader如何读取硬盘扇区的？"></a>5.1 bootloader如何读取硬盘扇区的？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">* waitdisk - wait for disk ready */</span><br><span class="line">static void</span><br><span class="line">waitdisk(void) &#123;</span><br><span class="line">    while ((inb(0x1F7) &amp; 0xC0) != 0x40)</span><br><span class="line">        /* do nothing */;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* readsect - read a single sector at @secno into @dst */</span><br><span class="line">static void</span><br><span class="line">readsect(void *dst, uint32_t secno) &#123;</span><br><span class="line">    // wait for disk to be ready</span><br><span class="line">    waitdisk(); // 等待磁盘就绪</span><br><span class="line"></span><br><span class="line">    outb(0x1F2, 1);    // 将要存取的扇区数（此处为1）存到0x1F2</span><br><span class="line">    outb(0x1F3, secno &amp; 0xFF);</span><br><span class="line">    outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);</span><br><span class="line">    outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF); </span><br><span class="line">    outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);// 0x1F3-0x1F6被用来设置扇区偏移</span><br><span class="line">    outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors，将READ命令存储到0x1F7（用来发起命令读取扇区）</span><br><span class="line"></span><br><span class="line">    // wait for disk to be ready</span><br><span class="line">    waitdisk(); // 等待磁盘就绪</span><br><span class="line"></span><br><span class="line">    // read a sector</span><br><span class="line">    insl(0x1F0, dst, SECTSIZE / 4);  // 通过CPU将数据从磁盘读到RAM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读扇区的流程总结为：</p>
<ol>
<li>等待磁盘准备好</li>
<li>写地址0x1f2~0x1f5,0x1f7,发出读取磁盘的命令</li>
<li>等待磁盘准备好</li>
<li>调用函数insl把扇区数据读到内存</li>
</ol>
<h4 id="5-2-bootloader是如何加载ELF格式的OS？"><a href="#5-2-bootloader是如何加载ELF格式的OS？" class="headerlink" title="5.2 bootloader是如何加载ELF格式的OS？"></a>5.2 bootloader是如何加载ELF格式的OS？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/* *</span><br><span class="line"> * readseg - read @count bytes at @offset from kernel into virtual address @va,</span><br><span class="line"> * might copy more than asked.</span><br><span class="line"> * */</span><br><span class="line">static void</span><br><span class="line">readseg(uintptr_t va, uint32_t count, uint32_t offset) &#123;</span><br><span class="line">    uintptr_t end_va = va + count;</span><br><span class="line"></span><br><span class="line">    // round down to sector boundary</span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    // translate from bytes to sectors; kernel starts at sector 1</span><br><span class="line">    uint32_t secno = (offset / SECTSIZE) + 1;</span><br><span class="line"></span><br><span class="line">    // If this is too slow, we could read lots of sectors at a time.</span><br><span class="line">    // We&apos;d write more to memory than asked, but it doesn&apos;t matter --</span><br><span class="line">    // we load in increasing order.</span><br><span class="line">    for (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">        readsect((void *)va, secno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* bootmain - the entry of bootloader */</span><br><span class="line">void</span><br><span class="line">bootmain(void) &#123;</span><br><span class="line">    // 读取磁盘的第一页(大小为4K),这里一个sectsize为512字节</span><br><span class="line">    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);</span><br><span class="line"></span><br><span class="line">    // 判断是否是合法的elf文件格式</span><br><span class="line">    if (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        goto bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct proghdr *ph, *eph;</span><br><span class="line"></span><br><span class="line">    // ELF头部有描述ELF文件应加载到内存什么位置的描述表，这里读取出来将之存入ph</span><br><span class="line">    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">	// 读出elf文件的段个数作为索引值</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    for (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">	// 读取每个elf文件段的内容</span><br><span class="line">        readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // call the entry point from the ELF header</span><br><span class="line">    // note: does not return</span><br><span class="line">    ((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    outw(0x8A00, 0x8A00);</span><br><span class="line">    outw(0x8A00, 0x8E00);</span><br><span class="line"></span><br><span class="line">    /* do nothing */</span><br><span class="line">    while (1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中可以看出程序控制流：</p>
<ol>
<li>运行bootmain，调用readseg读取多个扇区</li>
<li>readseg循环执行readsect读取每个扇区</li>
<li>返回bootmain，判断elf格式</li>
<li>将ELFheader读入ph（pragram header,程序头表）</li>
<li>将ph中各个section读入内存</li>
<li>通过内核入口函数加载内核</li>
</ol>
<h3 id="6-实现函数调用堆栈跟踪函数"><a href="#6-实现函数调用堆栈跟踪函数" class="headerlink" title="6 实现函数调用堆栈跟踪函数"></a>6 实现函数调用堆栈跟踪函数</h3><p>这里的代码根据注释不难写出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    void print_stackframe(void) &#123;</span><br><span class="line">        uint32_t ebp=read_ebp();        //(1) call read_ebp() to get the value of ebp. the type is (uint32_t)</span><br><span class="line">        uint32_t eip=read_eip();        //(2) call read_eip() to get the value of eip. the type is (uint32_t)</span><br><span class="line">        for(int i=0;i&lt;STACKFRAME_DEPTH&amp;&amp;ebp!=0;i++)&#123;    //(3) from 0 .. STACKFRAME_DEPTH</span><br><span class="line">              cprintf(&quot;ebp:0x%08x   eip:0x%08x &quot;,ebp,eip);    //(3.1)printf value of ebp, eip</span><br><span class="line">              uint32_t *tmp=(uint32_t *)ebp+2;</span><br><span class="line">              cprintf(&quot;arg :0x%08x 0x%08x 0x%08x 0x%08x&quot;,*(tmp+0),*(tmp+1),*(tmp+2),*(tmp+3));    //(3.2)(uint32_t)calling </span><br><span class="line"></span><br><span class="line">arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4]</span><br><span class="line">              cprintf(&quot;\n&quot;);            //(3.3) cprintf(&quot;\n&quot;);</span><br><span class="line">              print_debuginfo(eip-1);    //(3.4) call print_debuginfo(eip-1) to print the C calling function name and line </span><br><span class="line"></span><br><span class="line">number, etc.</span><br><span class="line">              eip=((uint32_t *)ebp)[1];</span><br><span class="line">              ebp=((uint32_t *)ebp)[0];    //(3.5) popup a calling stackframe</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如图所示：<br><img src="/images/ucore_01/5lab.jpg" alt=""></p>
<p>ebp是栈底指针，从该地址为基准，向上（栈底方向）能获取返回地址、参数值，向下（栈顶方向）能获取函数局部变量值，而该地址处又存储着上一层函数调用时的ebp值，eip则是指令指针寄存器保存着下一条指令的地址,最后一行输出的信息是debug_info，查看该函数定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void print_debuginfo(uintptr_t eip) &#123;</span><br><span class="line">    struct eipdebuginfo info;</span><br><span class="line">    if (debuginfo_eip(eip, &amp;info) != 0) &#123;</span><br><span class="line">        cprintf(&quot;    &lt;unknow&gt;: -- 0x%08x --\n&quot;, eip);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        char fnname[256];</span><br><span class="line">        int j;</span><br><span class="line">        for (j = 0; j &lt; info.eip_fn_namelen; j ++) &#123;</span><br><span class="line">            fnname[j] = info.eip_fn_name[j];</span><br><span class="line">        &#125;</span><br><span class="line">        fnname[j] = &apos;\0&apos;;</span><br><span class="line">        cprintf(&quot;    %s:%d: %s+%d\n&quot;, info.eip_file, info.eip_line,</span><br><span class="line">                fnname, eip - info.eip_fn_addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出最行一行输出的信息是源码所在文件名，源码所在行数（eip指向的指令对应），函数名，源码的长度（当前指令执行位置-函数起始位置）或者是不合法的eip（没找到eip对应的info，这里的info就是eipdebuginfo数据结构）<br>最后一个0x00007d63不合法的原因是我们还没有写内存管理模块（没有引入虚拟地址的抽象）…这里程序的堆栈空间范围在0~0x7c00(在bootasm.S中,感谢TsushimaAlice同学告知)所以超出堆栈的行为是未定义的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">kern_init(void)&#123;</span><br><span class="line">    extern char edata[], end[];</span><br><span class="line">    memset(edata, 0, end - edata);</span><br><span class="line"></span><br><span class="line">    cons_init();                // init the console</span><br><span class="line"></span><br><span class="line">    const char *message = &quot;(THU.CST) os is loading ...&quot;;</span><br><span class="line">    cprintf(&quot;%s\n\n&quot;, message);</span><br><span class="line"></span><br><span class="line">    print_kerninfo();</span><br><span class="line"></span><br><span class="line">    grade_backtrace();</span><br><span class="line"></span><br><span class="line">    pmm_init();                 // init physical memory management</span><br><span class="line"></span><br><span class="line">    pic_init();                 // init interrupt controller</span><br><span class="line">    idt_init();                 // init interrupt descriptor table</span><br><span class="line"></span><br><span class="line">    clock_init();               // init clock interrupt</span><br><span class="line">    intr_enable();              // enable irq interrupt</span><br><span class="line"></span><br><span class="line">    //LAB1: CAHLLENGE 1 If you try to do it, uncomment lab1_switch_test()</span><br><span class="line">    // user/kernel mode switch test</span><br><span class="line">    lab1_switch_test();</span><br><span class="line"></span><br><span class="line">    /* do nothing */</span><br><span class="line">    while (1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="7-完善中断初始化和处理"><a href="#7-完善中断初始化和处理" class="headerlink" title="7 完善中断初始化和处理"></a>7 完善中断初始化和处理</h3><p>在X86架构中，中断可以分为3种：</p>
<ol>
<li>和CPU无关的，比如外设的请求等，这些属于Interrupt。</li>
<li>和CPU有关的，比如除0，page fault等，这些属于Exception。</li>
<li>系统调用，这些属于Trap</li>
</ol>
<h4 id="7-1-中断描述符表项及字段含义"><a href="#7-1-中断描述符表项及字段含义" class="headerlink" title="7.1 中断描述符表项及字段含义"></a>7.1 中断描述符表项及字段含义</h4><p><img src="/images/ucore_01/IDT.png" alt=""><br>可以看出，一个表项占32*2位，8个字节。0到15位和48到63位为偏移量的低位和高位。16到31位是段选择子。 通过这几个数据来找到中断处理代码的入口。</p>
<h4 id="7-2-初始化idt"><a href="#7-2-初始化idt" class="headerlink" title="7.2 初始化idt"></a>7.2 初始化idt</h4><p>中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void idt_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* LAB1 YOUR CODE : STEP 2 */</span><br><span class="line">    /* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?</span><br><span class="line">      *     All ISR&apos;s entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?</span><br><span class="line">      *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c</span><br><span class="line">      *     (try &quot;make&quot; command in lab1, then you will find vector.S in kern/trap DIR)</span><br><span class="line">      *     You can use  &quot;extern uintptr_t __vectors[];&quot; to define this extern variable which will be used later.</span><br><span class="line">      * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT).</span><br><span class="line">      *     Can you see idt[256] in this file? Yes, it&apos;s IDT! you can use SETGATE macro to setup each item of IDT</span><br><span class="line">      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using &apos;lidt&apos; instruction.</span><br><span class="line">      *     You don&apos;t know the meaning of this instruction? just google it! and check the libs/x86.h to know more.</span><br><span class="line">      *     Notice: the argument of lidt is idt_pd. try to find it!</span><br><span class="line">      */</span><br><span class="line">    int i = 0;</span><br><span class="line">    extern uintptr_t __vectors[];</span><br><span class="line">    for(i = 0; i &lt; 255; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">		//  vectors 中存储了中断处理程序的入口地址。vectors 定义在 vector.S 文件中，通过一个工具程序 vector.c 生成</span><br><span class="line">        SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], 0); </span><br><span class="line">    &#125;</span><br><span class="line">	// 切换用户模式到内核模式</span><br><span class="line">    SETGATE(idt[T_SWITCH_TOK], 1, GD_KTEXT, __vectors[T_SWITCH_TOK], 3);// </span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>思路是：</p>
<ol>
<li>通过SETGATE宏初始化idt表（这里体现为一维数组）</li>
<li>准备执行lidt指令，因为trap是系统调用，所以执行idt_init的时候是在DPL_USER（3）的模式，而根据实验指导书，lidt需要在DPL_KERNEL（0）模式执行，所以需要切换用户模式到内核模式</li>
<li>执行lidt，使用一个包含线性地址基址和界限的内存操作数来加载IDT</li>
</ol>
<h4 id="7-3-时钟中断"><a href="#7-3-时钟中断" class="headerlink" title="7.3 时钟中断"></a>7.3 时钟中断</h4><p>中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">	/* LAB1 YOUR CODE : STEP 3 */</span><br><span class="line">	/* handle the timer interrupt */</span><br><span class="line">	/* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in </span><br><span class="line"></span><br><span class="line">kern/driver/clock.c</span><br><span class="line">	* (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().</span><br><span class="line">	* (3) Too Simple? Yes, I think so!</span><br><span class="line">	*/</span><br><span class="line">	ticks ++;</span><br><span class="line">	if (ticks % TICK_NUM == 0) &#123;</span><br><span class="line">	print_ticks();</span><br><span class="line">	&#125;</span><br><span class="line">break;</span><br></pre></td></tr></table></figure>
<p>思路是：每次 handles or dispatches an exception/interrupt都会调用trap，trap中通过累加tick这个时钟周期的全局变量（定义在clock.c）到100来触发时钟中断</p>
<h3 id="8-小结"><a href="#8-小结" class="headerlink" title="8 小结"></a>8 小结</h3><p>bootloader的启动到OS的加载流程为：</p>
<ol>
<li>禁用中断</li>
<li>复位标志寄存器</li>
<li>初始化ds，es，ss三个段（设置为0）</li>
<li>使能A20（扩大寻址空间）</li>
<li>跳转到gdtdes中，加载GDT（全局描述符表）</li>
<li>使能cr0，切换到保护模式</li>
<li>切换到32位模式</li>
<li>修改保护模式下各个寄存器的值</li>
<li>设置堆栈以调用C,初始化栈区（0x0~0x7c00）</li>
<li>调用bootmain.c</li>
<li>运行bootmain，调用readseg读取多个扇区</li>
<li>readseg循环执行readsect读取每个扇区</li>
<li>返回bootmain，判断elf格式</li>
<li>将ELFheader读入ph（pragram header,程序头表）</li>
<li>将ph中各个section读入内存</li>
<li>通过内核入口函数加载内核</li>
</ol>
<p>总的来说实验量还是很好的，实验指导书也很到位，看项目级代码果然需要一个静态分析利器啊，感谢清华！</p>
<h3 id="9-Reference"><a href="#9-Reference" class="headerlink" title="9 Reference"></a>9 Reference</h3><p><a href="https://www.jianshu.com/p/47dd6d3f551e" title="TsushimaAlice同学 简书 lab1" target="_blank" rel="noopener">TsushimaAlice同学 简书 lab1</a></p>

  </div>

  <br/>

  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">This post has been read：<span id="busuanzi_value_page_pv"></span>times</span>
  
  <br/><br/>


  

  <div class="copyright" >

    <a class="license-image" rel="license" href="http://creativecommons.org/licenses/by
-nc
-sa
/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by
-nc
-sa
/4.0/80x15.png" />
    </a>

      <p>本作品采用
      <a class="license-word-hyper" rel="license" href="http://creativecommons.org/licenses/by
-nc
-sa
/4.0/">
        知识共享署名
-非商业性使用
-相同方式共享
4.0 国际许可协议</a>
      进行许可。</p>
  </div>


  <div id="top">
    <a href="#">▲</a>
    <a href="#footer">▼</a>
</div>

  
  <script defer src="https://commento.pcrab.xyz/js/commento.js"></script>
<div id="commento"></div>
<noscript>Please enable JavaScript to load the comments.</noscript>


</post>

  </div>

  <foot id="footer">
  <hr class="boldline"/>
  <br>

  <p class="center font">
    
      <a href="https://github.com/pcrab">
  <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
   <path class="icon_path" d="M427.392 853.504a61.44 61.44 0 0 1-1.450667 15.530667 92.586667 92.586667 0 0 1-10.965333 27.605333c-15.061333 25.301333-40.661333 42.154667-73.642667 42.154667-77.653333 0-108.117333-38.101333-146.261333-133.504C169.216 740.693333 157.013333 725.461333 128 725.461333v-85.333333c77.653333 0 108.117333 38.101333 146.261333 133.504 25.856 64.597333 38.058667 79.786667 67.072 79.786667 0-12.373333-0.170667-23.296-0.512-38.144-0.853333-34.816-0.938667-41.941333 0.554667-51.2 0.64-20.352 5.888-34.773333 16.384-49.066667-95.232-20.736-159.445333-63.573333-196.309333-132.992l-13.824-32.426667C134.186667 510.848 128 467.072 128 416.426667c0-58.24 17.749333-110.336 50.944-153.856-10.368-41.386667-8.96-91.989333 13.909333-149.077334l7.466667-18.688 19.2-6.101333c2.56-0.853333 5.632-1.578667 9.301333-2.133333 37.290667-5.888 90.325333 8.106667 159.701334 52.48a565.930667 565.930667 0 0 1 127.274666-14.208c38.741333 0 77.226667 3.882667 114.048 11.605333 67.456-42.24 119.04-55.509333 155.306667-49.92 3.626667 0.597333 6.741333 1.322667 9.258667 2.133333l19.285333 6.101334 7.466667 18.773333c20.010667 50.218667 23.424 96.469333 16.128 136.96C875.434667 296.32 896 352.597333 896 416.512c0 53.888-3.84 94.378667-14.933333 133.802667l-11.733334 32.170666c-30.677333 69.333333-98.304 112.64-202.538666 133.248 10.837333 15.018667 15.872 30.250667 15.872 52.394667v42.666667l-0.042667 42.666666a13.013333 13.013333 0 0 0 0.341333 2.730667L682.666667 938.794667c-36.352 0-63.36-17.706667-76.672-45.653334a88.277333 88.277333 0 0 1-8.661334-40.277333v-84.736c0-3.584-0.128-3.797333-8.832-12.501333-23.296-23.296-33.834667-40.874667-33.834666-72.832v-38.613334l38.4-3.84c114.346667-11.52 176.512-43.221333 197.12-89.6l9.6-26.325333c7.68-27.562667 10.88-61.098667 10.88-107.946667 0-49.706667-17.365333-90.837333-50.218667-123.648L742.4 274.773333l7.381333-24.448c6.528-21.717333 8.106667-47.402667 1.152-76.714666a158.634667 158.634667 0 0 0-3.584 0.938666c-22.826667 6.4-51.370667 20.053333-85.76 43.008l-15.658666 10.453334-18.304-4.522667a467.754667 467.754667 0 0 0-111.829334-13.269333c-42.709333 0-84.906667 5.418667-123.946666 16.042666l-19.029334 5.205334-16.256-11.136c-35.541333-24.32-65.109333-38.826667-88.746666-45.568a158.293333 158.293333 0 0 0-4.864-1.28c-8.234667 33.92-4.992 61.781333 3.413333 82.688l9.984 25.088-18.346667 19.797333C228.693333 332.629333 213.333333 370.986667 213.333333 416.512c0 41.685333 4.864 76.202667 13.824 102.229333l11.178667 26.453334c27.904 52.352 87.168 83.84 192.853333 95.146666l38.144 4.096v38.357334c0 32-10.538667 49.536-33.834666 72.832-8.704 8.704-8.832 8.96-8.832 12.501333l-0.725334 7.893333c-0.512 2.56-0.512 9.258667 0.170667 37.205334 0.298667 12.8 0.469333 22.997333 0.554667 33.621333a33.962667 33.962667 0 0 1 0.725333 6.656z"/>
  </svg>
 </a>

    
    
      <a href="mailto:pcrab@mailbox.org">
  <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <path d="M513.78 602.99c-27.28 0.45-53.79-9.09-74.53-26.83l-65.96-56.64c-15.64-13.37-17.48-36.9-4.1-52.54 13.38-15.65 36.9-17.48 52.54-4.1l65.96 56.64c13.68 11.1 33.27 11.1 46.95 0L881.2 253.08l-708.02-2.61c-20.58 0-37.26-16.69-37.26-37.26s16.68-37.26 37.26-37.26H881.2c41.09-2.36 76.32 29.05 78.67 70.14a74.519 74.519 0 0 1-32.46 65.87L580.86 578.38a111.842 111.842 0 0 1-67.08 24.61z m444.57 133.4V438.28c0-20.58-16.68-37.26-37.26-37.26s-37.26 16.69-37.26 37.26V736.4c0 20.58-16.68 37.26-37.26 37.26h-521.7c-20.58 0-37.26 16.69-37.26 37.26s16.68 37.26 37.26 37.26h521.7c61.72 0.01 111.78-50.05 111.78-111.79zM362.12 363.75c0-20.58-16.68-37.26-37.26-37.26h-223.6c-20.58 0-37.26 16.69-37.26 37.26s16.68 37.26 37.26 37.26h223.59c20.58 0.01 37.27-16.68 37.27-37.26z m0 298.12c0-20.58-16.68-37.26-37.26-37.26h-111.8c-20.58 0-37.26 16.69-37.26 37.26s16.68 37.26 37.26 37.26h111.79c20.58 0 37.27-16.69 37.27-37.26z"/>
  </svg>
</a>

    
    
      <a href="https://t.me/Pcrab">
  <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <path d="M834.24 127.872a95.168 95.168 0 0 0-29.856 7.136h-0.128c-9.12 3.616-52.48 21.856-118.4 49.504l-236.224 99.488c-169.504 71.36-336.128 141.632-336.128 141.632l1.984-0.768s-11.488 3.776-23.488 12a64.96 64.96 0 0 0-18.752 18.144c-5.888 8.64-10.624 21.856-8.864 35.52 2.88 23.104 17.856 36.96 28.608 44.608 10.88 7.744 21.248 11.36 21.248 11.36h0.256l156.256 52.64c7.008 22.496 47.616 156 57.376 186.752 5.76 18.368 11.36 29.856 18.368 38.624 3.392 4.48 7.36 8.224 12.128 11.232a35.808 35.808 0 0 0 7.872 3.392l-1.6-0.384c0.48 0.128 0.864 0.512 1.216 0.64 1.28 0.352 2.144 0.48 3.776 0.736 24.736 7.488 44.608-7.872 44.608-7.872l1.12-0.896 92.256-84 154.624 118.624 3.52 1.504c32.224 14.144 64.864 6.272 82.112-7.616 17.376-13.984 24.128-31.872 24.128-31.872l1.12-2.88 119.488-612.128c3.392-15.104 4.256-29.248 0.512-42.976a57.824 57.824 0 0 0-24.992-33.504 59.904 59.904 0 0 0-34.144-8.64z m-3.232 65.6c-0.128 2.016 0.256 1.792-0.64 5.664v0.352l-118.368 605.76c-0.512 0.864-1.376 2.752-3.744 4.64-2.496 1.984-4.48 3.232-14.88-0.896l-189.12-144.992-114.24 104.128 24-153.28 308.992-288c12.736-11.84 8.48-14.336 8.48-14.336 0.896-14.528-19.232-4.256-19.232-4.256l-389.632 241.376-0.128-0.64-186.752-62.88v-0.128l-0.48-0.096a8.64 8.64 0 0 0 0.96-0.384l1.024-0.512 0.992-0.352s166.752-70.272 336.256-141.632c84.864-35.744 170.368-71.744 236.128-99.52 65.76-27.616 114.368-47.872 117.12-48.96 2.624-1.024 1.376-1.024 3.264-1.024z"/>
  </svg>
</a>

    
    
    
    
    
    
    
    
      <a href="/atom.xml">
  <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <path d="M122.88 720.213333a128 128 0 0 0 0 180.906667 128 128 0 0 0 180.906667 0 128 128 0 0 0-180.906667-180.906667z m120.746667 120.746667a42.666667 42.666667 0 0 1-60.586667-60.586667 42.666667 42.666667 0 0 1 60.586667 0 42.666667 42.666667 0 0 1 0 60.586667zM213.333333 512a42.666667 42.666667 0 0 0 0 85.333333 213.333333 213.333333 0 0 1 213.333334 213.333334 42.666667 42.666667 0 0 0 85.333333 0 298.666667 298.666667 0 0 0-298.666667-298.666667z m0-170.666667a42.666667 42.666667 0 0 0 0 85.333334 384 384 0 0 1 384 384 42.666667 42.666667 0 0 0 85.333334 0 472.746667 472.746667 0 0 0-137.386667-331.946667A472.746667 472.746667 0 0 0 213.333333 341.333333z m452.693334 16.64A644.693333 644.693333 0 0 0 213.333333 170.666667a42.666667 42.666667 0 0 0 0 85.333333 554.666667 554.666667 0 0 1 554.666667 554.666667 42.666667 42.666667 0 0 0 85.333333 0 644.693333 644.693333 0 0 0-187.306666-452.693334z"/>
  </svg>
</a>

    
  <p>
  <br>
  <p id="hitokoto">:D 获取中...</p>
  <script src="https://v1.hitokoto.cn/?c=a&encode=js&select=%23hitokoto" defer></script>
  <br>
  <p class="center font">
    &copy - <a href="http://www.woaitucao.xyz">Jason</a> -  2020 -  2021 - Powered by <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/pcrab/hexo-theme-quark"> Quark </a> 
  </p>
  <p>
    <a href="https://beian.miit.gov.cn/" target="_blank"></a>
  </p>
  <br/>
</foot>

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
