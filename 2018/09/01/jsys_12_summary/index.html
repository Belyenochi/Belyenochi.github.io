<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>计算的要素第十二章总结 | The Tao of Jason</title>
	<link rel="stylesheet" href="/css/style.css" />
	
      <link rel="alternate" href="/atom.xml" title="The Tao of Jason" type="application/atom+xml">
    
</head>

<body>

	<header class="header">
		<nav class="header__nav">
			
				<a href="/archives" class="header__link">Archive</a>
			
				<a href="/tags" class="header__link">Tags</a>
			
				<a href="/atom.xml" class="header__link">RSS</a>
			
		</nav>
		<h1 class="header__title"><a href="/">The Tao of Jason</a></h1>
		<h2 class="header__subtitle"></h2>
	</header>

	<main>
		<article>
	
		<h1>计算的要素第十二章总结</h1>
	
	<div class="article__infos">
		<span class="article__date">2018-09-01</span><br />
		
			<span class="article__category">
				<a class="article-category-link" href="/categories/计算机体系结构/">计算机体系结构</a>
			</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/Nand2tetris/">Nand2tetris</a>
			</span>
		
	</div>

	

	
		<p>本章是针对Hack OS各个模块的概述及其实现，其中某几个模块实现的算法很有意思，让我们马上开始吧~</p>
<h3 id="1-什么是OS（以Hack-OS为例）"><a href="#1-什么是OS（以Hack-OS为例）" class="headerlink" title="1 什么是OS（以Hack OS为例）"></a>1 什么是OS（以Hack OS为例）</h3><ol>
<li>以一种对软件友好的方式封装了不同的硬件服务</li>
<li>用不同的函数和抽象数据类型扩展了高级语言。在这个意义上的操作系统与语言的标准程序库的分界线就不那么明显。事实上，某些现代语言（例如Java）就趋向于将很多经典的操作系统服务（比如GUI管理，内存管理，和多任务处理等）连同很多语言拓展一起打包到其标准程序库中，这么做的目的以我的理解是为了屏蔽系统层面的差异（比如C的fopen等）以及减少系统调用（比如Java的内存管理，向内存申请一大片空间，Java NIO等）</li>
</ol>
<h3 id="2-为什么我们需要OS"><a href="#2-为什么我们需要OS" class="headerlink" title="2 为什么我们需要OS"></a>2 为什么我们需要OS</h3><p>计算机是用来解决实际问题的，所以我们构建计算机硬件用来计算，基于硬件我们造了编译器用来写更可读的汇编程序，然后有了用汇编程序写的应用，随着应用程序越来越到，我们需要抽象出能够将控制（硬件和外围设备以及软件）和分配资源的常用功能集一体的概念，它就是Operating System，感兴趣的同学可以看看操作系统的演化。（有时间去研究研究发出来）<br>计算机系统的基本目标是执行用户程序并以更容易的方式解决用户的问题。</p>
<h3 id="3-数学操作"><a href="#3-数学操作" class="headerlink" title="3 数学操作"></a>3 数学操作</h3><p>首先，这里明确的告诉了我下意识想到的通过累加和累减来实现乘除法来操作系统层面是不可行的，原因很简单，效率太低了高达O（n）的输入敏感复杂度会让计算一个100000000000000*10000000000000的人在凳子上坐上几天（只是举个例子，数据不具备代表性），那么就让我们来看一看Hack OS的做法</p>
<font color="red">注：以下所有运算都假定操作数为16位（Hacl硬件规范字长16位）</font>

<h4 id="3-1-乘法"><a href="#3-1-乘法" class="headerlink" title="3.1 乘法"></a>3.1 乘法</h4><p><img src="/images/jsys_12/乘法.jpg" alt=""></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>,index = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y.toString(<span class="number">2</span>).padStart(<span class="number">16</span>,<span class="string">"0"</span>).charAt(index) !== <span class="string">"0"</span>) &#123;</span><br><span class="line">        	<span class="built_in">console</span>.log(y, index,y.toString(<span class="number">2</span>).padStart(<span class="number">16</span>,<span class="string">"0"</span>));</span><br><span class="line">             sum = sum + x;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x + x;</span><br><span class="line">       index = index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到实际上乘法就是在模拟我们日常生活中的乘法，通过逐位相乘，并且再每一次乘完以后将被乘数左移一位，迭代这个过程直到遍历完所有位数，在日常生活中我们看到某个算术53*20，当我们处理完5这一位不会再用0去乘20，但是在计算机中你需要一套规则去运算，这套规则在这里就是遍历完操作数的所有位，即便它全是0。</p>
<h4 id="3-2-除法"><a href="#3-2-除法" class="headerlink" title="3.2 除法"></a>3.2 除法</h4><p><img src="/images/jsys_12/除法.jpg" alt=""></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> q,result,flag;</span><br><span class="line"></span><br><span class="line">    flag = !((x &lt; <span class="number">0</span>) ^ (y &lt; <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    x = <span class="built_in">Math</span>.abs(x);</span><br><span class="line">    y = <span class="built_in">Math</span>.abs(y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q = divide(x,y + y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x - (<span class="number">2</span> * q * y) &lt; y) &#123;</span><br><span class="line">        result = q + q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = q + q + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flag ? result : -result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路也是模仿人除法的过程，选择一个尽可能从x上减去y的最大倍数（假定算式x/y），直到y比x大，这个过程的递归形式如上。</p>
<h4 id="3-3-平方根"><a href="#3-3-平方根" class="headerlink" title="3.3 平方根"></a>3.3 平方根</h4><p><img src="/images/jsys_12/二叉树.jpg" alt=""></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sqrt</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y,j,temp,tempQ;</span><br><span class="line"></span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    j = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">      temp = y + <span class="built_in">Math</span>.pow(<span class="number">2</span>,j);</span><br><span class="line">      tempQ = temp * temp;</span><br><span class="line">      <span class="comment">//avoid overflow</span></span><br><span class="line">      <span class="keyword">if</span>((tempQ &lt;= x) &amp; (tempQ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">        y = temp;</span><br><span class="line">      &#125;</span><br><span class="line">      j = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法就是根据y²&lt;= x &lt;(y+1)²，使得y从0开始逐步逼近x使得y满足上述区间</p>
<h3 id="4-内存管理"><a href="#4-内存管理" class="headerlink" title="4 内存管理"></a>4 内存管理</h3><p>内存管理很有趣，首先说一说内存管理的背景</p>
<h4 id="4-1-背景"><a href="#4-1-背景" class="headerlink" title="4.1 背景"></a>4.1 背景</h4><p>计算机的程序会声明并使用各种类型的变量，包括整数、布尔数等简单的数据类型以及如数组、对象等复杂的数据类型。高级语言的最大优点之一是程序员不必关心内存管理细节：比如为变量分配内存空间；以及当该变量不再使用时，回收为其分配的内存空间。所有关于内存管理的琐碎工作都由编译器、操作系统和虚拟机在后端完成。<br>不同的变量的内存在程序生命周期中的不同时刻被分配。例如，<strong>静态变量</strong>在编译期间由编译器为其分配内存，而<strong>局部变量</strong>则在每个子程序开始运行时被分配在堆栈内。其他变量的内存则是在程序的执行过程中被动态分配，这时候OS就要上了。<font color="red">注意操作系统本身并不自带垃圾回收功能，这是高级语言提供的内存管理手段，比如Java，JVM先向OS请求一大块内存用于程序运行，然后在这块内存中可以“自动内存管理”，本质是在OS层面之上进行内存管理，这样就不用频繁的调用系统的malloc，free了</font></p>
<p>在OS看来内存其实就是一块大数组（big buffer），当然真实的内存实现我们已经在之前看到过了(多个Register-&gt;多个RAM-&gt;Memory)。</p>
<h4 id="4-2-内存管理算法"><a href="#4-2-内存管理算法" class="headerlink" title="4.2 内存管理算法"></a>4.2 内存管理算法</h4><h5 id="4-2-1-alloc"><a href="#4-2-1-alloc" class="headerlink" title="4.2.1 alloc"></a>4.2.1 alloc</h5><p><img src="/images/jsys_12/malloc.jpg" alt=""><br>上图的freeList的节点乍看可能有点疑惑，其实这里的freeList是经历过deAlloc的，一开是freeList只有一个节点就是整块内存区，然后随着alloc-deAlloc，链表节点逐渐增多，碎片化也越来越严重…</p>
<h5 id="4-2-2-deAlloc"><a href="#4-2-2-deAlloc" class="headerlink" title="4.2.2 deAlloc"></a>4.2.2 deAlloc</h5><p><img src="/images/jsys_12/delloc.jpg" alt=""><br>deAlloc的算法其实可以总结如下：<br>假设待释放节点值为o</p>
<ol>
<li>找到freeList中节点的地址值比待释放节点值大的节点（A）</li>
<li>将待释放的节点的next域设为A的地址<br>3.将A的上一个节点的next域设为o</li>
</ol>
<p>然而我刚开始的做法是：</p>
<ol>
<li>将o的next域设为freeList指向的节点</li>
<li>修改freeList指向o的地址（这和上图Mark的做法有点出路，个人觉得这样头插效率比根据Address来的高且简单）<br>当然我所谓的优于，是建立在没有合并的基础上的…</li>
</ol>
<h5 id="4-2-3-defragmentation（碎片合并）"><a href="#4-2-3-defragmentation（碎片合并）" class="headerlink" title="4.2.3 defragmentation（碎片合并）"></a>4.2.3 defragmentation（碎片合并）</h5><p>细心的读者已经发现了，上图中还包含这碎片合并的动作，这个碎片合并的动作如果链表不是根据address有序的话复杂度是O（n²）级别的，这带来的直接后果就是，咦，为什么我的程序关的这么慢。。。所以我们在deAlloc的时候要用第一个算法的原因就是如此。</p>
<p>defragmentation算法如下：<br>1.遍历链表<br>2.如果当前节点的地址值+size+1（存储size的存储单元） = 下一个节点的地址，merge</p>
<h3 id="5-输入输出管理"><a href="#5-输入输出管理" class="headerlink" title="5 输入输出管理"></a>5 输入输出管理</h3><p>这部分我就说两个比较有意思的地方</p>
<h4 id="5-1-输出"><a href="#5-1-输出" class="headerlink" title="5.1 输出"></a>5.1 输出</h4><h5 id="5-1-1-绘制三角形"><a href="#5-1-1-绘制三角形" class="headerlink" title="5.1.1 绘制三角形"></a>5.1.1 绘制三角形</h5><p><img src="/images/jsys_12/sanjiao.jpg" alt=""><br>这里说绘制三角形，不如说如何模拟三角形，实际上我们画出的三角形是以堆砌一个个像素形成的，可以把像素看出3*1的正方形，而绘制三角形的过程，就是如何堆砌正方形让它更像三角形，下面是过程图示<br><img src="/images/jsys_12/sanjiaoxing.png" alt=""></p>
<p><strong>图中最关键的一点在于    当前的坐标斜率&lt;=(y2-y1)/(x2-x1),a++，否则b++</strong></p>
<h5 id="5-1-2-绘制圆"><a href="#5-1-2-绘制圆" class="headerlink" title="5.1.2 绘制圆"></a>5.1.2 绘制圆</h5><p><img src="/images/jsys_12/circle.jpg" alt=""><br>绘制圆的本质就是绘制一系列的矩形，算法如上</p>
<h4 id="5-2-输入"><a href="#5-2-输入" class="headerlink" title="5.2 输入"></a>5.2 输入</h4><p>这一部分主要描述操作系统如何在三个递增的抽象层级上来管理面向文本的输入：</p>
<ol>
<li>捕获单字符输入</li>
<li>捕获多字符输入</li>
<li>捕获多字符输入（也就是字符串）</li>
</ol>
<h5 id="5-2-1-侦测键盘输入"><a href="#5-2-1-侦测键盘输入" class="headerlink" title="5.2.1 侦测键盘输入"></a>5.2.1 侦测键盘输入</h5><p><img src="/images/jsys_12/keyboard.jpg" alt=""><br>在底层捕获键盘输入时，程序直接从硬件获取数据，并确定用户当前按下哪个键。对该原始数据的访问依赖于键盘接口的具体特性。比如，若接口是被键盘持续更新的内存映像（比如Hack），就可以通过检测对应的内存映像来确定按下了哪个键</p>
<h5 id="5-2-2-读取单一字符"><a href="#5-2-2-读取单一字符" class="headerlink" title="5.2.2 读取单一字符"></a>5.2.2 读取单一字符</h5><p><img src="/images/jsys_12/readchar.jpg" alt=""></p>
<h5 id="5-2-3-读取字符串"><a href="#5-2-3-读取字符串" class="headerlink" title="5.2.3 读取字符串"></a>5.2.3 读取字符串</h5><p><img src="/images/jsys_12/readLine.jpg" alt=""></p>
<p><strong>其他模块String，Array，Output，Sys是在以上模块上的封装，具体的实现细节就参考书吧。</strong></p>
<h3 id="6-Q-amp-A"><a href="#6-Q-amp-A" class="headerlink" title="6 Q&amp;A"></a>6 Q&amp;A</h3><p>Q：关于平方根算法有更高效的算法吗？<br>A：除了书中提到的牛顿法求平方根（不动点算法），泰勒展开，<a href="http://nand2tetris-questions-and-answers-forum.32033.n3.nabble.com/A-more-efficient-square-root-algorithm-td4028140.htmla" title="这里" target="_blank" rel="noopener">这里</a>实现了一个长除法的实现，除了平方根算法，书中对于圆的绘制也有<a href="http://nand2tetris-questions-and-answers-forum.32033.n3.nabble.com/Fast-circle-algorithm-td4030808.html" title="更高效的算法" target="_blank" rel="noopener">更高效的算法</a></p>
<h3 id="7-Reference"><a href="#7-Reference" class="headerlink" title="7 Reference"></a>7 Reference</h3><p><a href="http://sites.google.com/site/johnkennedyshome/home/downloadable-papers/bcircle.pdf" title="用于绘制圆的快速Bresenham型算法，John Kennedy" target="_blank" rel="noopener">用于绘制圆的快速Bresenham型算法，John Kennedy</a><br><a href="https://sites.google.com/site/johnkennedyshome/home/downloadable-papers/bcircle.pdf?attredirects=0" title="用于绘制椭圆的快速Bresenham型算法，John Kennedy" target="_blank" rel="noopener">用于绘制椭圆的快速Bresenham型算法，John Kennedy</a></p>

	

	
		<span class="different-posts"><a href="/2018/09/01/jsys_12_summary/" onclick="window.history.go(-1); return false;">⬅️ Go back </a></span>

	

</article>

	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<p>Hi there, <br />welcome to my Blog glad you found it. Have a look around, will you?</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		  <li class="footer-links__link"><a href="/atom.xml">RSS</a></li>
	    
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2021 Jason | Powered by <a href="https://hexo.io/">Hexo</a> | Theme <a href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>
