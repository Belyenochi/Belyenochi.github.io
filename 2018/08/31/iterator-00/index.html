<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>迭代器实现（零） | The Tao of Jason</title>
	<link rel="stylesheet" href="/css/style.css" />
	
      <link rel="alternate" href="/atom.xml" title="The Tao of Jason" type="application/atom+xml">
    
</head>

<body>

	<header class="header">
		<nav class="header__nav">
			
				<a href="/archives" class="header__link">Archive</a>
			
				<a href="/tags" class="header__link">Tags</a>
			
				<a href="/atom.xml" class="header__link">RSS</a>
			
		</nav>
		<h1 class="header__title"><a href="/">The Tao of Jason</a></h1>
		<h2 class="header__subtitle"></h2>
	</header>

	<main>
		<article>
	
		<h1>迭代器实现（零）</h1>
	
	<div class="article__infos">
		<span class="article__date">2018-08-31</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/Jason-Tomas的造轮子之旅/">Jason Tomas的造轮子之旅</a>
			</span>
		
	</div>

	

	
		<h3 id="1-迭代器是什么"><a href="#1-迭代器是什么" class="headerlink" title="1 迭代器是什么"></a>1 迭代器是什么</h3><p>在计算机编程中，迭代器是一个对象，它使程序员能够遍历容器，特别是列表。通常通过容器的接口提供各种类型的迭代器。虽然给定迭代器的接口和语义是固定的，但迭代器通常是根据容器实现的底层结构实现的，并且通常紧密耦合到容器以启用迭代器的操作语义。迭代器执行遍历并且还允许访问容器中的数据元素，但本身不执行迭代（即，并非没有采用该概念或使用术语的轻微自由）。迭代器在行为上类似于数据库游标。迭代器可以追溯到1974年的CLU编程语言。</p>
<h3 id="2-为什么会需要迭代器？"><a href="#2-为什么会需要迭代器？" class="headerlink" title="2 为什么会需要迭代器？"></a>2 为什么会需要迭代器？</h3><ol>
<li>便于数据流的控制，假定有一个数据流，这时如果有迭代器就可以很方便的操作这个数据流，当然也可以把迭代器理解为延时求值（lazy eval）啦</li>
<li>解耦算法和数据结构，比如你想找到树中符合条件的节点，传统的做法是使用一个查找算法，传入一个树对象和查找条件，遍历树进行匹配，而拥有迭代器之后，你只需不停的next直到迭代器末尾，大大增加了代码的可读性（毕竟是线性的）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器前</span></span><br><span class="line">select(node, condition,result) &#123;</span><br><span class="line">	<span class="keyword">if</span> (node) &#123;</span><br><span class="line">		<span class="keyword">if</span>(node.left !== <span class="string">''</span>) &#123;</span><br><span class="line">			select(node.left);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (condition(node.value)) &#123;</span><br><span class="line">			result.push(node.value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(node.right !== <span class="string">''</span>) &#123;</span><br><span class="line">			select(node.right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器后,可读性增强了</span></span><br><span class="line">select(treeIterator, condition， result) &#123;</span><br><span class="line">	<span class="keyword">for</span>(treeNode <span class="keyword">of</span> treeIterator) &#123; <span class="comment">// 假定这里for of调用迭代器，事实上在JS中也确实如此</span></span><br><span class="line">		<span class="keyword">if</span>(condition(treeNode)) &#123;</span><br><span class="line">			result.push(treeNode);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然线性的代码更可读，但我个人觉得递归的代码真的很美…我个人在可以递归的条件下是不会去写迭代的（除了效率限制），不过现在部分编译器支持Tail call optimization，虽然JavaScript没有，但是你可以将任何递归用黑魔法 Trampoline转化为形式上的尾递归~</p>
<h3 id="3-实现迭代器"><a href="#3-实现迭代器" class="headerlink" title="3 实现迭代器"></a>3 实现迭代器</h3><p>迭代器的本质是延迟求值或者说部分求值（令我想到了SICP的流模型），那么由于传统的程序执行比如递归，你是无法控制程序的控制流的，拿之前的递归遍历树的例子来看，你无法在它遍历到某个子树（这时这个子树的左右节点还存在）的情况下马上回到根节点的，这是因为受限于函数的调用栈，当然你可以通过cps变换来手动控制你的代码，这是另外一回事，这里暂不予展开。既然我们不能控制函数调用栈，那我们就一不做二不休的自己创建栈来模拟之前的遍历函数运行，这样代码就在我们的掌控下了（基于栈的程序控制其实体现着栈式虚拟机的思想，通过push和pop来控制”计算”，而CPS变换更多的体现的是续算（continuation）的传递，PL的魔法啦）</p>
<p>接下来我们可以看看，基于栈的非递归遍历实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于栈的非递归查询算法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inorder_tarverse_nonrecursive</span>(<span class="params">node,condition,result</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> stack = [];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">// 压入所有左子节点</span></span><br><span class="line">		<span class="keyword">while</span> (node) &#123;</span><br><span class="line">			stack.push(node);</span><br><span class="line">			node = node.left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Pop出左子节点，进入右子节点或者返回父节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">let</span> top = stack.pop();</span><br><span class="line">			<span class="keyword">if</span> (condition(top)) &#123;</span><br><span class="line">				result.push(top.value);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (top.right) &#123;</span><br><span class="line">				node = top.right;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 此时根节点和根中所有左子节点已经遍历完毕</span></span><br><span class="line">			<span class="keyword">if</span> (stack.length === <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 遍历完毕所有节点</span></span><br><span class="line">		<span class="keyword">if</span> (stack.length === <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里给出递归实现以做对比<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inorder_traverse</span>(<span class="params">node,condition,result</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node) &#123;</span><br><span class="line">		inorder_traverse(node.left);</span><br><span class="line">		<span class="keyword">if</span> (condition(node.value)) &#123;</span><br><span class="line">			result.push(result);</span><br><span class="line">		&#125;;</span><br><span class="line">		inorder_traverse(node.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>递归的调用栈和非递归模拟的程序栈对比<br>树：<br><img src="/images/tools/iterator/树.jpg" alt=""></p>
<p>非递归：<br><img src="/images/tools/iterator/栈1.jpg" alt=""><br><img src="/images/tools/iterator/栈2.jpg" alt=""></p>
<p>递归<br><img src="/images/tools/iterator/callStack.jpg" alt=""></p>
<font color="red">可以看出非递归模拟递归的本质就在于程序控制流的模拟，这里的控制流并不是调用栈的模拟，而是计算顺序的模拟（体现在上面的例子中就是对节点值的访问顺序），非递归模拟代码就是用栈中的节点来模拟访问的次序</font>

<p>既然现在我们已经能够用栈来模拟控制流，这也意味着对程序的遍历的控制已经完全受制于我们（这里的完全受制是逻辑上的，屏蔽底层编译的细节），我们终于摆脱了了call stack :)</p>
<p>现在我们可以肆意的操控我们的遍历程序,接下来用闭包保存栈，每次next调用pop一次来实现迭代<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeTreeIterator</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> controlStack = [];</span><br><span class="line"></span><br><span class="line">	((<span class="function"><span class="keyword">function</span> <span class="title">InorderIterator</span>(<span class="params">currNode</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 将当前节点的所有左子节点入栈</span></span><br><span class="line">		<span class="keyword">while</span> (currNode) &#123;</span><br><span class="line">			controlStack.push(currNode);</span><br><span class="line">			currNode = currNode.left;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)(node))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (controlStack.length) &#123;</span><br><span class="line">				<span class="comment">// 取出当前节点</span></span><br><span class="line">				<span class="keyword">let</span> top = controlStack.pop();</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (top.right) &#123;</span><br><span class="line">					<span class="keyword">let</span> currNode = top.right;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 将当前节点的右子节点的所有左子节点压栈</span></span><br><span class="line">					<span class="keyword">while</span> (currNode) &#123;</span><br><span class="line">						controlStack.push(currNode);</span><br><span class="line">						currNode = currNode.left;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> &#123;<span class="attr">value</span>: top.value, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>拉出迭代器遛遛<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tree = &#123;</span><br><span class="line">	value: <span class="number">5</span>,</span><br><span class="line">	left: &#123;</span><br><span class="line">		value: <span class="number">4</span>,</span><br><span class="line">		left: <span class="string">''</span>,</span><br><span class="line">		right: <span class="string">''</span></span><br><span class="line">	&#125;,</span><br><span class="line">	right: &#123;</span><br><span class="line">		value: <span class="number">8</span>,</span><br><span class="line">		left: &#123;</span><br><span class="line">			value: <span class="number">6</span>,</span><br><span class="line">			left: <span class="string">''</span>,</span><br><span class="line">			right: <span class="string">''</span></span><br><span class="line">		&#125;,</span><br><span class="line">		right: <span class="string">''</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test = makeTreeIterator(tree),result = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = test.next(); i.done !== <span class="literal">true</span>; i=test.next()) &#123;</span><br><span class="line">	<span class="keyword">if</span> (i.value &lt; <span class="number">5</span>) &#123;</span><br><span class="line">		result.push(i.value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [4]</span></span><br></pre></td></tr></table></figure></p>
<p>还有一种实现迭代器的方法就是使用continuation来实现控制反转啦~<br>下一篇博客会去讲解如何用continuation来实现迭代器，这里先用ES6的generator来预热<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inOrder</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> x;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (node) &#123;</span><br><span class="line">		<span class="keyword">for</span> (x <span class="keyword">of</span> inOrder(node.left)) &#123;</span><br><span class="line">			<span class="keyword">yield</span> x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">yield</span> node.value;</span><br><span class="line">		<span class="keyword">for</span> (x <span class="keyword">of</span> inOrder(node.right)) &#123;</span><br><span class="line">			<span class="keyword">yield</span> x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test = inOrder(tree),result = [];</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">of</span> test) &#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">		result.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [4]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h3><p>基于栈可以模拟控制流，这也是栈式虚拟机的思想，堆栈处理不愧是计算机领域强劲的技术，从迭代引申到控制流，看来“取指-执行”模型不仅仅用在CPU啊。</p>
<h3 id="5-Reference"><a href="#5-Reference" class="headerlink" title="5 Reference"></a>5 Reference</h3><p><a href="https://coolshell.cn/articles/9886.html/comment-page-1#comments" title="二叉树迭代器算法" target="_blank" rel="noopener">二叉树迭代器算法</a><br><a href="http://effbot.org/pyfaq/what-is-an-iterator.htm" title="What is an iterator?" target="_blank" rel="noopener">What is an iterator?</a><br><a href="https://stackoverflow.com/questions/49052473/folder-iterator-continuation-token-recursive-loop" title="Folder Iterator Continuation Token Recursive Loop" target="_blank" rel="noopener">Folder Iterator Continuation Token Recursive Loop</a><br><a href="http://gallium.inria.fr/blog/generators-iterators-control-and-continuations/" title="generators-iterators-control-and-continuations/" target="_blank" rel="noopener">generators-iterators-control-and-continuations/</a></p>

	

	
		<span class="different-posts"><a href="/2018/08/31/iterator-00/" onclick="window.history.go(-1); return false;">⬅️ Go back </a></span>

	

</article>

	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<p>Hi there, <br />welcome to my Blog glad you found it. Have a look around, will you?</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		  <li class="footer-links__link"><a href="/atom.xml">RSS</a></li>
	    
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2021 Jason | Powered by <a href="https://hexo.io/">Hexo</a> | Theme <a href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>
