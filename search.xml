<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>离职小结——2019/5/16/1:39</title>
      <link href="/2019/05/16/suibi/"/>
      <url>/2019/05/16/suibi/</url>
      
        <content type="html"><![CDATA[<p>&emsp;在麦穗实习了8个月了，说起来还真的是很快，从对工业界一无所知到现在的略知一二一路走来同事，老大，老板都给予了很大的帮助，可以说这里拥有一个优秀的创业公司的基因，理性判断且关注下属换位思考的老板，帮助小老弟成长的老大，以及带领我从小白到初级工程师的同事，但是夜深人静的时候我时常在想自己追求的到底是什么，从刚进麦穗那会的前端，到后来的devops，我一直在问自己一个问题，我真的热爱这份工作吗？我真的可以为他奋斗3，5年乃至10年吗？</p><p>&emsp;在越来越繁重的需求迭代中，我感觉自己的工作状态一天不如一天，我知道是我内心开始不认同我现在做的大部分事情了，我失去了对工作的热情，那么我感兴趣的到底是什么呢？对比再三我还是认为更底层的工作更适合我，以及我需要更多技术实践的机会，所以我选择了离开麦穗，说起来与麦穗的大家伙生活了半年多没有感情是假的，因为我这个人在学校比较自闭，在麦穗的半年多让我感受到了在学校三年来不曾有过的情切感，以及同事的信任，互相帮助，可以说是麦穗的实习成就了现在我，对于我职业生涯发展也起了很大的帮助，也正是在麦穗的期间让我改掉了很多不好的习惯，这所有的一切我都会珍藏在心里，并且怀着对过去的感激继续勇往直前。</p><p>&emsp;未来怎么样，这个决定对我到底有什么影响说起来我真的很难预测，但我觉得这条路是我摔了很多跟头以后发现的，我不想因为觉得太难了不配等其他原因说服自己，但我不会忘记是麦穗给我这个机会让我尝试各种想法，给我摔跟头的机会，我也不会忘记luyi姐在我遭遇工作瓶颈的时候顺毛摸，理性分析，火火对我思维模式以及责任感的告诫，小灰对我代码风格习惯的指导，扬哥给我提供各种实践的机会以及指导（甚至一开始还教我怎么写scala的工程代码），老王给予我前端方面的指导以及一些职场见解，少爷以身作则的向我展现了一个优秀的程序员是不需要加班的，超哥在大局方面的见解，vv姐对我生活方面的建议，书记让我认识到了男人是如何能屈能伸的，法师向我展现了上一代程序员的职业素养以及责任感，以及月月、盛宙、敏材与我分享见解的时光，这一切的一切都是我在麦穗收获的珍宝，感谢麦穗这个大家庭的所有人，衷心祝愿麦穗能在ai招聘领域成为独角兽，发展的越来越好，也衷心祝愿公司的每一个人能够身体健康，生活幸福！大家都是最棒的！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>趣谈Linux操作系统笔记02（对应06-08）</title>
      <link href="/2019/04/14/biji-os-02/"/>
      <url>/2019/04/14/biji-os-02/</url>
      
        <content type="html"><![CDATA[<h3 id="0-计算机的工作模式"><a href="#0-计算机的工作模式" class="headerlink" title="0 计算机的工作模式"></a>0 计算机的工作模式</h3><h4 id="0-1-硬件图和计算机的逻辑图"><a href="#0-1-硬件图和计算机的逻辑图" class="headerlink" title="0.1 硬件图和计算机的逻辑图"></a>0.1 硬件图和计算机的逻辑图</h4><p><img src="/images/biji_os_02/1.png" alt=""></p><h4 id="0-2-cpu的组成"><a href="#0-2-cpu的组成" class="headerlink" title="0.2 cpu的组成"></a>0.2 cpu的组成</h4><ol><li>运算单元</li><li>数据单元</li><li>控制单元<br><img src="/images/biji_os_02/2.png" alt=""></li></ol><h3 id="1-x86架构"><a href="#1-x86架构" class="headerlink" title="1 x86架构"></a>1 x86架构</h3><h4 id="1-1-历史"><a href="#1-1-历史" class="headerlink" title="1.1 历史"></a>1.1 历史</h4><p>x86泛指一系列由英特尔公司开发处理器的架构，这类处理器最早为1978年面市的“Intel 8086”CPU。<br>该系列较早期的处理器名称是以数字来表示80x86。由于以“86”作为结尾，包括Intel 8086、80186、80286、80386以及80486，因此其架构被称为“x86”。由于数字并不能作为注册商标，因此Intel及其竞争者均在新一代处理器使用可注册的名称，如Pentium。现时英特尔将其称为IA-32，全名为“Intel Architecture, 32-bit”，一般情形下指代32位的架构。</p><h4 id="1-2-8086的原理"><a href="#1-2-8086的原理" class="headerlink" title="1.2 8086的原理"></a>1.2 8086的原理</h4><p>8086的cpu包含以下几个部分：</p><ul><li>数据单元：AX、BX、CX、DX、SP、BP、SI、DI寄存器</li><li>控制单元：IP（指令指针寄存器，指向代码段中下一条指令的位置 ）、CS（代码段寄存器（Code Segment Register），通过它可以找到代码在内存中的位置）、DS（数据段的寄存器，通过它可以找到数据在内存中的位置）、SS（栈寄存器）、ES<br><img src="/images/biji_os_02/3.png" alt=""><h4 id="1-3-课堂练习"><a href="#1-3-课堂练习" class="headerlink" title="1.3 课堂练习"></a>1.3 课堂练习</h4>Q: mov, call, ret, jmp, int, add, or, xor, shl, ahr, push, pop, inc, dec, sub, cmp指令含义？<br>A: </li><li>mov: 将第二个操作数（源操作数）复制到第一个操作数（目标操作数）。源操作数可以是立即值，通用寄存器，段寄存器或存储器位置; 目标寄存器可以是通用寄存器，段寄存器或存储器位置。两个操作数必须大小相同，可以是字节，字，双字或四字。<font color="red">MOV指令不能用于加载CS寄存器。尝试这样做会导致无效的操作码异常（#UD）。要加载CS寄存器，请使用far JMP，CALL或RET指令。</font></li><li>call : 保存将堆栈和分支上的信息链接到使用目标操作数指定的调用过程的过程。目标操作数指定被调用过程中第一条指令的地址。操作数可以是立即值，通用寄存器或存储器位置。</li><li>ret : 将程序控制流转移到位于堆栈顶部的返回地址。地址通常由CALL指令放在堆栈上，并返回到CALL指令后面的指令。</li><li>jmp : 将程序控制流转移到指令流中的不同点而不记录返回信息。<br>int : 调用中断</li><li>add : 添加目标操作数（第一个操作数）和源操作数（第二个操作数），然后将结果存储在目标操作数中。目标操作数可以是寄存器或存储器位置; 源操作数可以是立即数，寄存器或存储器位置。（但是，在一条指令中不能使用两个存储器操作数。）当立即值用作操作数时，它将符号扩展为目标操作数格式的长度。ADD指令执行整数加法。它评估有符号和无符号整数操作数的结果，并设置CF和OF标志，分别表示有符号或无符号结果中的进位（溢出）。SF标志指示签名结果的符号</li><li>or : 在目标（第一个）和源（第二个）操作数之间执行按位包含OR运算，并将结果存储在目标操作数位置。源操作数可以是立即数，寄存器或存储器位置; 目标操作数可以是寄存器或存储器位置。（但是，在一条指令中不能使用两个存储器操作数。）如果第一和第二操作数的相应位都为0，则OR指令结果的每一位都设置为0; 否则，每个位都设置为1。</li><li>xor : 对目标（第一个）和源（第二个）操作数执行按位异或（XOR）运算，并将结果存储在目标操作数位置。源操作数可以是立即数，寄存器或存储器位置; 目标操作数可以是寄存器或存储器位置。（但是，一条指令不能使用两个存储器操作数。）如果操作数的相应位不同，则结果的每一位都为1; 如果相应的位相同，则每个位为0。</li><li>shl : 逻辑左移</li><li>shr :逻辑右移</li><li>push : 堆栈指针寄存器的值递减，然后将源操作数存储在堆栈顶部</li><li>pop:  将值从堆栈顶部加载到使用目标操作数（或显式操作码）指定的位置，然后递增堆栈指针。目标操作数可以是通用寄存器，存储器位置或段寄存器。</li><li>inc: 将1添加到目标操作数，同时保留CF标志的状态。目标操作数可以是寄存器或存储器位置。该指令允许更新循环计数器而不会干扰CF标志。（使用立即操作数为1的ADD指令执行更新CF标志的增量操作。）</li><li>dec: 从目标操作数中减去1，同时保留CF标志的状态。目标操作数可以是寄存器或存储器位置。该指令允许更新循环计数器而不会干扰CF标志。（要执行更新CF标志的减量操作，请使用立即操作数为1的SUB指令。）</li><li>sub : 从第一个操作数（目标操作数）中减去第二个操作数（源操作数），并将结果存储在目标操作数中。目标操作数可以是寄存器或存储器位置; 源操作数可以是立即数，寄存器或内存位置。（但是，在一条指令中不能使用两个存储器操作数。）当立即值用作操作数时，它将符号扩展为目标操作数格式的长度。SUB指令执行整数减法。它评估有符号和无符号整数操作数的结果，并设置OF和CF标志，分别表示有符号或无符号结果中的溢出。SF标志指示签名结果的符号。</li><li>cmp: 比较第一个源操作数和第二个源操作数，并根据结果设置EFLAGS寄存器中的状态标志。通过从第一个操作数中减去第二个操作数，然后以与SUB指令相同的方式设置状态标志来执行比较。当立即值用作操作数时，它将符号扩展为第一个操作数的长度。</li></ul><h3 id="2-Linux内核启动过程（bootloader）"><a href="#2-Linux内核启动过程（bootloader）" class="headerlink" title="2 Linux内核启动过程（bootloader）"></a>2 Linux内核启动过程（bootloader）</h3><h4 id="2-1-启动过程描述"><a href="#2-1-启动过程描述" class="headerlink" title="2.1 启动过程描述"></a>2.1 启动过程描述</h4><p><img src="/images/biji_os_02/4.png" alt=""></p><ol><li>主板加电，cpu从rom中读取BIOS执行（通过将CS 设置为 0xFFFF，将 IP 设置为 0x0000，跳转到ROM中进行初始化）</li><li>BIOS做完计算机硬件自检和初始化后，会选择一个启动设备（例如软盘、硬盘、光盘等）</li><li>将 boot.img 从启动设备的主引导扇区(MBR)加载到内存中的 0x7c00（从现在开始进入bootloader，grub2为例）</li><li>boot.img加载core.img的第一个扇区diskboot.img（diskboot.img复杂加载core.img的其余模块）</li><li>diskboot.img通过启用分段和分页将系统从实模式切换到保护模式增大以寻址空间（为了解压缩lzma_decompress.img）<br><img src="/images/biji_os_02/5.png" alt=""></li><li>解压缩kernel.img,跳转到kernel.img开始执行</li><li>grub load config解析操作系统配置文件（grub.conf），经过一系列的系统配置初始化函数，最后调用grub_command_execute启动内核</li></ol><h4 id="2-2-启动过程小结图"><a href="#2-2-启动过程小结图" class="headerlink" title="2.2 启动过程小结图"></a>2.2 <font color="red">启动过程小结图</font></h4><p><img src="/images/biji_os_02/6.png" alt=""><br><img src="/images/biji_os_02/7.png" alt=""><br><img src="/images/biji_os_02/8.png" alt=""></p><h3 id="3-内核初始化"><a href="#3-内核初始化" class="headerlink" title="3 内核初始化"></a>3 内核初始化</h3><h4 id="3-1-内核初始化流程"><a href="#3-1-内核初始化流程" class="headerlink" title="3.1 内核初始化流程"></a>3.1 内核初始化流程</h4><p><img src="/images/biji_os_02/9.png" alt=""></p><ol><li>调用内核初始化函数start_kernel()</li><li>初始化进程列表，创建0号进程，这是唯一一个没有通过 fork 或者 kernel_thread 产生的进程，是进程列表的第一个</li><li>调用trap_init()初始化中断门</li><li>调用mm_init()初始化内存管理模块</li><li>调用sched_init()初始化调度模块</li><li>调用vfs_caches_init()初始化基于内存的文件系统rootfs</li><li>调用rest_init()来做其他方面的初始化<h4 id="3-2-系统调用流程"><a href="#3-2-系统调用流程" class="headerlink" title="3.2 系统调用流程"></a>3.2 系统调用流程</h4><img src="/images/biji_os_02/10.png" alt=""></li></ol><h4 id="3-3-rest-init"><a href="#3-3-rest-init" class="headerlink" title="3.3 rest_init()"></a>3.3 rest_init()</h4><ul><li>调用kernel_thread(kernel_init, NULL, CLONE_FS)创建第1号进程（用户态所有进程的祖先）</li><li>调用kernel_thread(kernel_init, NULL, CLONE_FS|CLONE_FILES)创建2号进程（用户态所有进程的祖先）</li></ul><font color="red">这里的函数 kthreadd，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。</font><h4 id="3-4-小结流程"><a href="#3-4-小结流程" class="headerlink" title="3.4 小结流程"></a>3.4 小结流程</h4><p><img src="/images/biji_os_02/11.png" alt=""></p><h3 id="4-引用链接"><a href="#4-引用链接" class="headerlink" title="4 引用链接"></a>4 引用链接</h3><p><a href="https://zh.wikipedia.org/wiki/X86" title="x86" target="_blank" rel="noopener">x86</a><br><a href="https://www.felixcloutier.com/x86/" title="x86 and amd64 instruction reference" target="_blank" rel="noopener">x86 and amd64 instruction reference</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>趣谈Linux操作系统笔记01（对应03-06）</title>
      <link href="/2019/04/06/biji-os-01/"/>
      <url>/2019/04/06/biji-os-01/</url>
      
        <content type="html"><![CDATA[<h3 id="1-操作系统简介"><a href="#1-操作系统简介" class="headerlink" title="1 操作系统简介"></a>1 操作系统简介</h3><h4 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h4><p><img src="/images/biji_os_01/WX20190406-221620@2x.png" alt=""><br>在谈论什么是操作系统前我们可以回忆一下十几年前买电脑的过程，引用文章的栗子就是”那时候买电脑，经常是这样一个情景：三五个哥们儿一起来到电脑城，呼啦呼啦采购了一大堆硬件，有密密麻麻都是针脚的<strong>CPU</strong>；有铺满各种复杂电路的一块板子，也就是<strong>主板</strong>；还需要买块<strong>显卡</strong>，用来连接显示器；还需要买个<strong>网卡</strong>，里面可以插网线；还要买块<strong>硬盘</strong>，将来用来存放文件；然后还需要一大堆<strong>线</strong>，将这些设备和主板连接起来；最终再来一个<strong>鼠标</strong>，一个<strong>键盘</strong>，还有一个<strong>显示器</strong>。设备差不多啦，准备开整！”,那么此时如何将这些硬件连接起来并使用户能够在不知道硬件的情况下进行操作呢（比如总不能让用户手动操作强行写入显示器所在内存使显示器显示字符），<strong>没错这层硬件细节与用户使用普通软件的抽象就是操作系统</strong>，</p><h4 id="1-2-为什么需要操作系统"><a href="#1-2-为什么需要操作系统" class="headerlink" title="1.2 为什么需要操作系统"></a>1.2 为什么需要操作系统</h4><p>其实回答这个问题只需要看一看没有操作系统的时候，实际上，最早的计算机没有操作系统（这里我们假设最早的计算机是ENIAC,实际上这个定义一直有争议这里只是举例）; 他们是一次负责一个程序的大型机器。出于这个原因，他们并不真正需要操作系统。事实上，最早的计算机要求用户物理连接和断开插头板上的电线以检索计算。但是如果你没有操作系统，你可以让你的电脑做任何事吗？（那时候说的程序员都还是指拔插连接线用以实现运算的女性呢～）</p><p>是。但是你还有很多工作要做。如果没有操作系统使用和执行标准的系统方法来运行计算机，那么您就会处于编写必须告诉计算机确切操作的代码（或程序）的位置。因此，如果要在文字处理程序中键入文档，则必须从头创建代码，告诉计算机响应键盘上按下的每个字符。然后，您必须编写一个代码，告诉计算机这些响应必须如何转换为屏幕。您必须告诉您的计算机如何绘制您想要的角色！想想你的文字处理程序有的每一个选项或可能性。您必须直接在硬盘上为每一个代码编写代码。</p><p>文中说<strong>操作系统其实就像一个软件外包公司，其内核就相当于这家外包公司的老板。所以接下来的整个课程中，请你将自己的角色切换成这家软件外包公司的老板，设身处地地去理解操作系统是如何协调各种资源，帮客户做成事情的。</strong>，那么其实这个类比隐含了默认场景，完整的类比应该是，客户尽是一些不具备软件开发能力的公司，此时客户看到了某款爆款软件”拼西西”的成功，心急如焚的想要构建一个高并发、高可用的”拼东东”东东，那么问题来了，公司内部没有现成的基础设施（消息队列、缓存等），更重要的是连个懂业务开发的技术人员都没有，我作为客户好急啊～从0-1完成传统企业转型臣妾做不到啊，然而我转念一想我其实不需要会开发我只需要一个中间层懂开发就行了，我输入业务输出的是计算机相应的程序就行，好了这不隔壁老张开了家软件外包公司帮我屏蔽了软件开发的抽象（对应到os就是输入输出设备，进程，存储等抽象），那么我就能安心的进行业务拓展了呢。（可以说广大应用软件正是站在巨人（操作系统）的肩膀上）</p><p><font color="red"><em>脑洞一下，如果说图灵机是没有os的计算机（其实是一种计算模型，当然也可以称为计算机），那么我们来思考一下图灵机适合现代使用吗？</em></font><br>&nbsp;</p><p><font color="blue">&nbsp;&nbsp;小王想要看漫画，请问您从图灵机抽象能给我显示一个小姐姐图片吗，这当然不行，虽然图灵机的实现可以支持各种逻辑运算结构但是图灵机并没有规定如何将纸带连接到显示屏（缺少了硬件驱动管理等），实际上之前说的早期的计算机确实是图灵机的一种实现，现在他有了一个响当当的名号<strong>冯诺伊曼体系结构</strong>，但是这种体系结构只是为os打好了硬件基础，在这个体系结构之上的抽象才是操作系统。那么现在我们知道图灵机距离适合现在使用差了两个层次，第一层是现代的体系结构作为图灵机的实现，第二层是操作系统的介入屏蔽硬件体系结构并提供一些好用的基础工具（比如进程抽象)</font></p><p><font color="red"><em>继续脑洞等价于图灵机的理论模型最知名的应该属于图灵师父在图灵机理论发表之前发布的lambda calculus，这是一种纯数学的模型（理解起来需要花费一点时间但是很有意思，推荐可以去看看计算语义学方面的书），上面我的脑洞在这里可以翻译为我能用数学函数运算看动漫吗？</em></font><br>&nbsp;</p><p><font color="blue">&nbsp;&nbsp;这次我觉得这次应该没人质疑了吧，当然你可能会想到，从看动漫降维抽象到计算理论这一层（对应到体系结构的实现）那么好像看起来我看动漫的基础就是lambda calculus呢（当然实际上并不是的，这里我指的是计算能力上的等价，ladmda calculus的计算能力是等价于图灵机的所以这里看动漫的基础归结到体系结构的抽象可以是图灵机并等价于lambda calculus）</font></p><h4 id="1-3-“双击-QQ”这个过程，都需要用到哪些硬件？"><a href="#1-3-“双击-QQ”这个过程，都需要用到哪些硬件？" class="headerlink" title="1.3 “双击 QQ”这个过程，都需要用到哪些硬件？"></a>1.3 “双击 QQ”这个过程，都需要用到哪些硬件？</h4><p>用户开始对着屏幕上的 QQ 图标双击鼠标了。</p><ol><li>鼠标就会通过鼠标线给电脑发消息，告知电脑，鼠标向某个方向移动了多少距离</li><li>屏幕，也就是显示器，是计算机的输出设备，将计算机处理用户请求展示给用户看</li><li>显卡，由显卡控制在显示器的哪个坐标上再绘制一个鼠标箭头</li><li>RAM, 坐标值经过鼠标输入中断写入ram对应的屏幕内存对应区域</li></ol><h4 id="1-4-从点击-QQ-图标，看操作系统全貌"><a href="#1-4-从点击-QQ-图标，看操作系统全貌" class="headerlink" title="1.4 从点击 QQ 图标，看操作系统全貌"></a>1.4 从点击 QQ 图标，看操作系统全貌</h4><ul><li>硬盘是个物理设备，要按照规定格式化成为文件系统，才能存放这些程序。文件系统需要一个系统进行统一管理，称为文件管理子系统（File Management Subsystem）。</li><li>当操作系统拿到 QQ 的二进制执行文件的时候，就可以运行这个文件了。QQ 的二进制文件是静态的，称为程序（Program），而运行起来的 QQ，是不断进行的，称为进程（Process）。</li><li>在操作系统中，也有同样的问题，例如多个进程都要往打印机上打印文件，如果随便乱打印进程，就会出现同样一张纸，第一行是 A 进程输出的文字，第二行是 B 进程输出的文字，全乱套了。所以，打印机的直接操作是放在操作系统内核里面的，进程不能随便操作。但是操作系统也提供一个办事大厅，也就是系统调用（System Call）。</li><li>在操作系统中，进程的执行也需要分配 CPU 进行执行，也就是按照程序里面的二进制代码一行一行地执行。于是，为了管理进程，我们还需要一个进程管理子系统（Process Management Subsystem）。如果运行的进程很多，则一个 CPU 会并发运行多个进程，也就需要 CPU 的调度能力了。</li><li>在操作系统中，不同的进程有不同的内存空间，但是整个电脑内存就这么点儿，所以需要统一的管理和分配，这就需要内存管理子系统（Memory Management Subsystem）。</li></ul><p>也可以使用软件外包公司的组织架构模拟以上的os组成模块<br><img src="/images/biji_os_01/WX20190406-234401@2x.png" alt=""></p><h4 id="1-5-os组成总览"><a href="#1-5-os组成总览" class="headerlink" title="1.5 os组成总览"></a>1.5 os组成总览</h4><p><img src="/images/biji_os_01/WX20190406-234419@2x.png" alt=""></p><h4 id="1-6-课堂练习"><a href="#1-6-课堂练习" class="headerlink" title="1.6 课堂练习"></a>1.6 课堂练习</h4><p>系统调用 kernel/<br>进程管理 kernel/, arch/<arch>/kernel<br>内存管理 mm/, arch/<arch>/mm<br>文件 fs/<br>设备 drivers/char, drivers/block<br>网络 net/</arch></arch></p><p><font color="red"><strong>arch</strong></font>代表某种架构</p><h3 id="2-常用的Linux命令"><a href="#2-常用的Linux命令" class="headerlink" title="2 常用的Linux命令"></a>2 常用的Linux命令</h3><h4 id="2-1-常用Linux命令图示"><a href="#2-1-常用Linux命令图示" class="headerlink" title="2.1 常用Linux命令图示"></a>2.1 常用Linux命令图示</h4><p><img src="/images/biji_os_01/4.jpg" alt=""></p><h4 id="2-2-部分命令在centos体系和ubnutu体系下的差别"><a href="#2-2-部分命令在centos体系和ubnutu体系下的差别" class="headerlink" title="2.2 部分命令在centos体系和ubnutu体系下的差别"></a>2.2 部分命令在centos体系和ubnutu体系下的差别</h4><p><strong>安装软件命令(以安装jdk为例)</strong><br>centos体系：<br>rpm -i jdk-XXX_linux-x64_bin.rpm<br>ubnutu体系:<br>dpkg -i jdk-XXX_linux-x64_bin.deb</p><p><strong>服务相关命令（以启动服务为例）</strong><br>centos体系：<br>systemctl start mariadb<br>ubnutu体系:<br>systemctl start mysql</p><h4 id="2-3-思路如下"><a href="#2-3-思路如下" class="headerlink" title="2.3 思路如下"></a>2.3 思路如下</h4><ol><li>安装jdk，mysql</li><li>配置jdbc驱动配置文件</li><li>通过jdbc在java app里连接msql并执行相应的数据库操作</li></ol><h3 id="3-几个常用的系统调用"><a href="#3-几个常用的系统调用" class="headerlink" title="3 几个常用的系统调用"></a>3 几个常用的系统调用</h3><h4 id="3-1-进程管理"><a href="#3-1-进程管理" class="headerlink" title="3.1 进程管理"></a>3.1 进程管理</h4><h5 id="3-1-1-fork"><a href="#3-1-1-fork" class="headerlink" title="3.1.1 fork"></a>3.1.1 fork</h5><p>linux里进程的创建是通过fork父进程完成的，关于fork的详细用法可以参考<a href="https://linux.die.net/man/2/fork" title="这里" target="_blank" rel="noopener">这里</a><br>关于fork可以引申出<font color="red">孤儿进程和僵尸进程</font></p><ul><li><font color="red">孤儿进程</font>：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li><li><font color="red">僵尸进程</font>：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。<h5 id="3-1-2-execve"><a href="#3-1-2-execve" class="headerlink" title="3.1.2 execve"></a>3.1.2 execve</h5>execve用来执行一个二进制可执行文件或者以#! interpreter [optional-arg]为开头的脚本，关于execve的详细用法可以参考<a href="https://linux.die.net/man/2/execve" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-1-3-waitpid"><a href="#3-1-3-waitpid" class="headerlink" title="3.1.3 waitpid"></a>3.1.3 waitpid</h5>waitpid用来等待进程改变状态，常用于父进程等待子进程结束，关于waitpid的详细用法可以参考<a href="https://linux.die.net/man/2/waitpid" title="这里" target="_blank" rel="noopener">这里</a><h4 id="3-2-内存管理"><a href="#3-2-内存管理" class="headerlink" title="3.2 内存管理"></a>3.2 内存管理</h4><em>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</em><h5 id="3-2-1-brk"><a href="#3-2-1-brk" class="headerlink" title="3.2.1 brk"></a>3.2.1 brk</h5>brk是将数据段(.data)的最高地址指针_edata往高地址推，关于execve的详细用法可以参考<a href="https://linux.die.net/man/2/brk" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-2-2-mmap"><a href="#3-2-2-mmap" class="headerlink" title="3.2.2 mmap"></a>3.2.2 mmap</h5>mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存，关于mmap更详细的用法可以参考<a href="https://linux.die.net/man/3/mmap" title="这里" target="_blank" rel="noopener">这里</a><h4 id="3-3-文件管理"><a href="#3-3-文件管理" class="headerlink" title="3.3 文件管理"></a>3.3 文件管理</h4><em>Linux里一切皆文件</em><h5 id="3-3-1-open"><a href="#3-3-1-open" class="headerlink" title="3.3.1 open"></a>3.3.1 open</h5>open用于打开一个文件，关于open更详细的用法可以参考<a href="https://linux.die.net/man/3/open" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-3-2-close"><a href="#3-3-2-close" class="headerlink" title="3.3.2 close"></a>3.3.2 close</h5>close用于关闭一个文件，关于close更详细的用法可以参考<a href="https://linux.die.net/man/3/close" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-3-3-creat"><a href="#3-3-3-creat" class="headerlink" title="3.3.3 creat"></a>3.3.3 creat</h5>creat用于创建一个文件，关于creat更详细的用法可以参考<a href="https://linux.die.net/man/3/creat" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-3-4-lseek"><a href="#3-3-4-lseek" class="headerlink" title="3.3.4 lseek"></a>3.3.4 lseek</h5>lseek用于跳到文件的某个位置，关于lseek更详细的用法可以参考<a href="https://linux.die.net/man/3/lseek" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-3-5-read"><a href="#3-3-5-read" class="headerlink" title="3.3.5 read"></a>3.3.5 read</h5>read用于读取某个文件，关于read更详细的用法可以参考<a href="https://linux.die.net/man/3/read" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-3-6-write"><a href="#3-3-6-write" class="headerlink" title="3.3.6 write"></a>3.3.6 write</h5>write用于读取某个文件，关于write更详细的用法可以参考<a href="https://linux.die.net/man/3/write" title="这里" target="_blank" rel="noopener">这里</a><h4 id="3-4-信号处理"><a href="#3-4-信号处理" class="headerlink" title="3.4 信号处理"></a>3.4 信号处理</h4><h5 id="3-4-1-kill"><a href="#3-4-1-kill" class="headerlink" title="3.4.1 kill"></a>3.4.1 kill</h5>用户进程通过kill函数，将一个用户信号发送给另一个进程,<strong> 注意这里的kill是指代发送信号而不是杀死进程之类的…</strong>，关于sigaction更详细的用法可以参考<a href="https://linux.die.net/man/3/kill" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-4-2-sigaction"><a href="#3-4-2-sigaction" class="headerlink" title="3.4.2 sigaction"></a>3.4.2 sigaction</h5>sigaction用于注册信号处理函数，用kill发送的信号可以在sigaction中注册相应的信号处理函数用以处理，关于sigaction更详细的用法可以参考<a href="https://linux.die.net/man/3/sigaction" title="这里" target="_blank" rel="noopener">这里</a><h4 id="3-5-进程间通信"><a href="#3-5-进程间通信" class="headerlink" title="3.5 进程间通信"></a>3.5 进程间通信</h4><em>内核可以通过消息队列来实现进程间通信</em><h5 id="3-5-1-msgget"><a href="#3-5-1-msgget" class="headerlink" title="3.5.1 msgget"></a>3.5.1 msgget</h5>创建一个新的消息队列，关于msgget更详细的用法可以参考<a href="https://linux.die.net/man/3/msgget" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-5-2-msgget"><a href="#3-5-2-msgget" class="headerlink" title="3.5.2 msgget"></a>3.5.2 msgget</h5>将消息发送到消息队列，关于msgget更详细的用法可以参考<a href="https://linux.die.net/man/3/msgget" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-5-3-msgrcv"><a href="#3-5-3-msgrcv" class="headerlink" title="3.5.3 msgrcv"></a>3.5.3 msgrcv</h5>从消息队列中取出消息，关于msgget更详细的用法可以参考<a href="https://linux.die.net/man/3/msgget" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-5-4-shmget"><a href="#3-5-4-shmget" class="headerlink" title="3.5.4 shmget"></a>3.5.4 shmget</h5>创建一个共享内存块，关于shmget更详细的用法可以参考<a href="https://linux.die.net/man/3/shmget" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-5-5-shmmat"><a href="#3-5-5-shmmat" class="headerlink" title="3.5.5 shmmat"></a>3.5.5 shmmat</h5>将共享内存块映射到自己的内存空间（比如说自己的进程地址空间，关于shmmat更详细的用法可以参考<a href="https://linux.die.net/man/3/shmmat" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-5-6-sem-wait"><a href="#3-5-6-sem-wait" class="headerlink" title="3.5.6 sem_wait"></a>3.5.6 sem_wait</h5>持有信号量，信号量-1，关于sem_wait更详细的用法可以参考<a href="https://linux.die.net/man/3/sem_wait" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-5-7-sem-post"><a href="#3-5-7-sem-post" class="headerlink" title="3.5.7 sem_post"></a>3.5.7 sem_post</h5>释放信号量，信号量+1，关于sem_post更详细的用法可以参考<a href="https://linux.die.net/man/3/sem_post" title="这里" target="_blank" rel="noopener">这里</a><h4 id="3-6-网络通信"><a href="#3-6-网络通信" class="headerlink" title="3.6 网络通信"></a>3.6 网络通信</h4><h5 id="3-6-1-socket"><a href="#3-6-1-socket" class="headerlink" title="3.6.1 socket"></a>3.6.1 socket</h5>从tcp/ip 的解度看 socket ，它更多地体现了用户 API 与协议栈的一个中间层接口层。用户通过调用socket API 将报文递交给协议栈，或者从协议栈中接收报文件。关于socket更详细的用法可以参考<a href="https://linux.die.net/man/3/socket" title="这里" target="_blank" rel="noopener">这里</a></li></ul><h4 id="3-7-小结"><a href="#3-7-小结" class="headerlink" title="3.7 小结"></a>3.7 小结</h4><p><img src="/images/biji_os_01/WX20190407-101258@2x.png" alt=""></p><h4 id="3-8-课堂练习"><a href="#3-8-课堂练习" class="headerlink" title="3.8 课堂练习"></a>3.8 课堂练习</h4><p>以执行strace cat /dev/null 为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;/usr/bin/cat&quot;, [&quot;cat&quot;, &quot;/dev/null&quot;, &quot;-o&quot;, &quot;/root/straceout.txt&quot;], [/* 23 vars */]) = 0</span><br><span class="line">brk(NULL)                               = 0x1cda000</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe3f1515000</span><br><span class="line">access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=36309, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 36309, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fe3f150c000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/lib64/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P%\2\0\0\0\0\0&quot;..., 832) = 832</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=2173512, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 3981792, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fe3f0f28000</span><br><span class="line">mprotect(0x7fe3f10eb000, 2093056, PROT_NONE) = 0</span><br><span class="line">mmap(0x7fe3f12ea000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c2000) = 0x7fe3f12ea000</span><br><span class="line">mmap(0x7fe3f12f0000, 16864, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fe3f12f0000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe3f150b000</span><br><span class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe3f1509000</span><br><span class="line">arch_prctl(ARCH_SET_FS, 0x7fe3f1509740) = 0</span><br><span class="line">mprotect(0x7fe3f12ea000, 16384, PROT_READ) = 0</span><br><span class="line">mprotect(0x60b000, 4096, PROT_READ)     = 0</span><br><span class="line">mprotect(0x7fe3f1516000, 4096, PROT_READ) = 0</span><br><span class="line">munmap(0x7fe3f150c000, 36309)           = 0</span><br><span class="line">brk(NULL)                               = 0x1cda000</span><br><span class="line">brk(0x1cfb000)                          = 0x1cfb000</span><br><span class="line">brk(NULL)                               = 0x1cfb000</span><br><span class="line">open(&quot;/usr/lib/locale/locale-archive&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=106070960, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 106070960, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fe3ea9ff000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/usr/share/locale/locale.alias&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=2502, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe3f1514000</span><br><span class="line">read(3, &quot;# Locale name alias data base.\n#&quot;..., 4096) = 2502</span><br><span class="line">read(3, &quot;&quot;, 4096)                       = 0</span><br><span class="line">close(3)                                = 0</span><br><span class="line">munmap(0x7fe3f1514000, 4096)            = 0</span><br><span class="line">open(&quot;/usr/share/locale/zh_CN.UTF-8/LC_MESSAGES/libc.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/usr/share/locale/zh_CN.utf8/LC_MESSAGES/libc.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/usr/share/locale/zh_CN/LC_MESSAGES/libc.mo&quot;, O_RDONLY) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=81139, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 81139, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fe3f14f5000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/usr/lib64/gconv/gconv-modules.cache&quot;, O_RDONLY) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=26254, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 26254, PROT_READ, MAP_SHARED, 3, 0) = 0x7fe3f150e000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">write(2, &quot;cat\357\274\232\346\227\240\346\225\210\351\200\211\351\241\271 -- o\n&quot;, 24cat：无效选项 -- o</span><br><span class="line">) = 24</span><br><span class="line">open(&quot;/usr/share/locale/zh_CN.UTF-8/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/usr/share/locale/zh_CN.utf8/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/usr/share/locale/zh_CN/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=190751, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 190751, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fe3f14c6000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/usr/share/locale/zh.UTF-8/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/usr/share/locale/zh.utf8/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/usr/share/locale/zh/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">write(2, &quot;Try &apos;cat --help&apos; for more inform&quot;..., 39Try &apos;cat --help&apos; for more information.</span><br><span class="line">) = 39</span><br><span class="line">close(1)                                = 0</span><br><span class="line">close(2)                                = 0</span><br><span class="line">exit_group(1)                           = ?</span><br><span class="line">+++ exited with 1 +++</span><br></pre></td></tr></table></figure></p><h3 id="4-引用链接"><a href="#4-引用链接" class="headerlink" title="4 引用链接"></a>4 引用链接</h3><p><a href="https://computer.howstuffworks.com/computer-run-without-operating-system1.htm" title="computer-run-without-operating-system" target="_blank" rel="noopener">computer-run-without-operating-system</a><br><a href="https://time.geekbang.org/column/article/88060" title="极客时间" target="_blank" rel="noopener">极客时间</a><br><a href="https://www.kernel.org/" title="kernel" target="_blank" rel="noopener">kernel</a><br><a href="https://courses.linuxchix.org/kernel-hacking-2002/08-overview-kernel-source.html" title="overview-kernel-source" target="_blank" rel="noopener">overview-kernel-source</a><br><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html" title="strace" target="_blank" rel="noopener">strace</a><br><a href="https://linux.die.net/man/2/fork" title="linux man" target="_blank" rel="noopener">linux man</a><br><a href="https://www.cnblogs.com/sky-heaven/p/10005642.html" title="Linux内存分配小结--malloc、brk、mmap" target="_blank" rel="noopener">Linux内存分配小结–malloc、brk、mmap</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实习小结</title>
      <link href="/2019/01/19/suibi-01/"/>
      <url>/2019/01/19/suibi-01/</url>
      
        <content type="html"><![CDATA[<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p>仔细算一算实习也已经3个多月了，期间犯过一些很严重的错误，导致了同事们的不愉快，我深感抱歉和自责，在此我会分析自己行为的各个方面，希望以后引以为戒。</p><h3 id="1-缺陷"><a href="#1-缺陷" class="headerlink" title="1. 缺陷"></a>1. 缺陷</h3><ul><li>对代码的理解太过自信，但是局限于个人的能力，我还是会犯一些低级错误，在对代码的语义和上下文不够了解的情况下进行了更改，解决方案：就像我的一位学长兼同事所言，遇事不决先商讨，具体到这个场景就是不确定的时候，整理出解决方案找同事确认，商讨得出结论。</li><li>deadline前自乱阵脚，这事的具体体现就是项目进度太过紧凑，一些代码没有经过深思熟虑就提交了，短期看起来似乎是想要为同事分忧，但是其实是给同事增加了很大的review负担以及坏了好心情（说实在的我觉得我非常的内疚），解决方案：首先认清自己的能力和经验，并且短时间不可能存在跨越式发展，虽然想获得同事的认可，但是必须慢下来保证质量，在质量的前提下提高速度，而不是作死猛肝。</li><li>抗压能力过强，虽然我其实是一个自己能做的事情不喜欢麻烦别人的人，毕竟大家的时间都很宝贵，但是在工作中该沟通的地方还是必须沟通不能怕麻烦，其实这也是变相的懒惰，长远的看不利于团队协作，解决方案：该定期交流的必须定期交流，另外必须给同事和leader及时反馈，以保证不会出现过多偏误。</li><li>部分能力尚且不足，比如说数据结构应用方面的不足，这里没什么好说的，该补的，该review优秀代码的肯定不能少，对数据结构合理应用以及系统设计能力是优先提高的。</li><li>三思而后行，这点和2有部分重叠，体现在了我在面对危机问题和压力面前选择盲目的行动其实这是一种战略上的懒惰，解决方案：思考并做出demo（编程方面），在对问题有多个纬度（编程方面，数据结构的选择，算法的选择，设计的选择，网络环境，库的使用，可读性，健壮性，正确性等的考虑）的思考以后再下决断，并且和同事和leader商讨得出的解决方案。</li><li>不够努力，对自身的精力管理做的不够好导致下班以后有时没有能够及时调整状态投入学习，解决方案：睡觉or慢跑or冥想，这三种途径可以恢复精力继续学习</li></ul><h3 id="2-需要坚持的地方"><a href="#2-需要坚持的地方" class="headerlink" title="2. 需要坚持的地方"></a>2. 需要坚持的地方</h3><ul><li>以周为区间划分任务，以天为单位去落实todo list，分治任务并留下部分时间应对其他情况</li><li>早睡早起（虽然在加班那段时间做的不够好），认识到自身的睡眠是保证精力来源的重要途径，将作息调整在23～7.30有意义身体机能的balance</li><li>针对性的学习，在刚接触scala以及类库的那会先看理论然后找exercise去实践是一种有效的途径，当然这不适用于系统的学习，但对于工程实践性价比颇高</li><li>在自身能力和时间允许的条件下帮助同事，这也可以提高团队的凝聚力以后为以后的有效沟通做铺垫</li><li>理性的看待失败并总结，找出失败的本质并且避免这一类问题，多学习多实践，保持一颗纯粹的心</li></ul><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><p>白驹过隙，三个月就这么过去了，在mesoor的日子里收获了很多经验和教训，也认识了很多很棒的同事，感谢扬哥，火火，小晖，法师等同事一直以来以各种形式帮助我成长，我犯下过一些愚蠢的错误，但是我会不断努力成为更优秀的工程师和团队一起奋斗！</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>随想——2018/12/8/22:13</title>
      <link href="/2018/12/08/suibi-00/"/>
      <url>/2018/12/08/suibi-00/</url>
      
        <content type="html"><![CDATA[<h3 id="1-内省（序言）"><a href="#1-内省（序言）" class="headerlink" title="1. 内省（序言）"></a>1. 内省（序言）</h3><p>我之前一直觉得自己是个自制力较好的人，事实证明我自制力只在精神上勉强合格，除此之外自制力还受精力管理，时间管理的影响，但在后两者我做的一塌糊涂，一直单纯的相信自己能hold住的我还是too young too somple，实习2个月了，一直感觉自己做的不够好，安排了路线却发现执行力不行，让我很是难过，经过一段时间的反省我总结出了作为学生的我初入职场在学习与工作之间balance的心得，下面从三个维度精神，精力，时间管理来叙述</p><h3 id="2-精神"><a href="#2-精神" class="headerlink" title="2.精神"></a>2.精神</h3><p>我认为人类发展的核心在于探索，而探索来自于好奇心，如果丧失了好奇心人类文明将会停泄不前，无论是在工作中还是学习中，保持一颗好奇的心很重要，你可能会问好奇为什么会这么重要，好奇心可以让你从以下几个维度来思考一个问题，我相信在大多数领域都是通用的：</p><ol><li>xxx到底是什么,如何产生的（过去）</li><li>xxx所引起的后果（现在）</li><li>如何解决xxx，是否可以借鉴其他领域（未来）</li></ol><p>在工业界可能没有很多时间给你思考问题背后的脉络，这就得靠你平常花更多的时间反思梳理和总结了（说起来实习项目组老大给我起了个绰号好奇宝宝= =，也在这里非常感谢我的同事们给我这个萌新解答各种问题），技术的更迭比摩尔定律还快得多，但是看清历史的脉络，以及发展的本质，结合计算机的本质足以成为一个优秀的程序员，但不仅限与此。<br>除了好奇心，自信也很重要，或许今后将会面对各种各样的未知困难，至少在计算机领域一个好的基础就是你思考的基础点，没有什么天马行空的猜测，一切都是按着逻辑行事，所以要相信自己可以在面对未知苦难时利用过去掌握的领域知识逐步求解新问题。<br>最后就是责任心了，程序员作为工程师的一种必然应该具备责任心，体现在工作中就是对自己写的每一行代码负责，力求简洁清晰，我之前天真的想在工程代码中用Y combinator等PL偏向数学的技术在代码里应该没什么问题，但是这个想法在我review各种历史代码的途中被废除了。工程代码的核心是 <font color="red"><em>简洁 健壮 高效 （而不是魔法，魔法可以用在必要的场景比如某些库里封装好）</em></font>，追求cool的编码在工程项目中其实是不负责任的，当然在极客社区不是 ：），最重要的是自己写的代码有时间最好自己维护，不到万不得已不要让别人擦屁股，就算离职至少写好注释（这一点我同事做的挺好，能自己维护自己的代码就自己维护，但有一些N手代码看起来还是很费劲）</p><p>简而言之，我认为工程中最重要的精神是：</p><ol><li>好奇心</li><li>自信心</li><li>责任心</li></ol><h3 id="3-精力管理"><a href="#3-精力管理" class="headerlink" title="3.精力管理"></a>3.精力管理</h3><p>说句实话这个问题在我实习之前是完全没有考虑过的（毕竟在学校可以心无旁骛的学习），但是事实证明传统的前后端都比较拼体力，不做好精力管理的话下班就累成猪头了。<br>以下几点是我认为精力管理分四个阶段：</p><ol><li>体能<br>1.1 规律的作息，没有规律的作息=没有规律的生活，对于程序员来说保护自己的身体=保护了自己的未来<br>1.2 饮食，不能过多的摄入碳水化合物以及糖分，前者会让你血糖身高，胰岛素分泌上升产生困乏，后者还能让你肥胖找不到对象QAQ，我推荐少吃多餐，早上10点和下午4点加餐坚果，水果，平常吃NQI指数高的食物（不懂NQI就吃绿色的蔬菜！）<br>1.3 运动 平常抽20-30min运动，慢跑等</li><li>情绪<br>我认为比较好的方法是回忆回忆你生命中遇到的那些贵人，怀着一颗感恩的心会让使得内心宁静</li><li>注意力<br>慢慢培养自己对于一件事的注意力，人脑在我的不科学理解下（我没有意思的挖掘我人脑的可能性）是一个单核CPU，当然他有异步模式，但只支持并发不支持并行，这样一次只做好一件事就是必然的，不要幻想着自己能同时做两件烧脑的事情，培养注意力的关键就在于一次做好一件事然后下一件<br>event sort map _.do()</li><li>意义感<br>想象一下现在正在做的事对未来的影响！荣耀到最后！</li></ol><h3 id="4-时间管理"><a href="#4-时间管理" class="headerlink" title="4. 时间管理"></a>4. 时间管理</h3><p>时间管理其实和精力管理密不可分，没有精力的时间管理就是没有汽油的汽车，你想开也发动不了。<br>那么如何做好时间管理呢，我认为最重要的首先是了解自己，认识自己不是个机器人，不可能２４小时都按一个模式执行，并且天天如此，在这里我想强调的是，认识并接纳自己作为人的一面，认识到人性的弱点，做好风险预案，然后将过程拆解的足够仔细，这样成功就不会是一个结果而是process。对于时间的管理我认为以下几点很重要：</p><ol><li>安排切实可行的计划</li><li>拆解计划到每个周（当然也可以每一天）</li><li>将每天要做的todo list sort by 优先级</li><li>做好风险管理，留出时间给偶发事件</li><li>假如上一天未完成，或者遇上偶发事件，将目前的event sort by 优先级继续做事</li></ol><p>以上就是我对时间管理的心得，原谅我曾经把自己当个机器人，每天15小时坚持一礼拜学习效率大打折扣…</p><h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h3><p>以前欠下的技术债从今天开始还，Brain fuck也好，JIT也好，我一定会用心写好每一篇文章，绝不滥竽充数。</p><h3 id="6-结语"><a href="#6-结语" class="headerlink" title="6.结语"></a>6.结语</h3><p>感谢学习赋予了我不断探索的乐趣，也感谢一路上的良师益友以及同道之人的指点，书山有路勤为径，学海无涯苦作舟，愿与诸君共勉。</p><p><font color="blue">PS: 有在魔都的同学可以联系我呀~周末有空可以一起交流学习（目前主要兴趣在k8s和PL,职业是full stack）</font><br>qq：754572491  wechat: ztq491537461q (加我备注blog~)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 闲话二三 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ucore lab1实验小结</title>
      <link href="/2018/09/16/ucore-lab1/"/>
      <url>/2018/09/16/ucore-lab1/</url>
      
        <content type="html"><![CDATA[<h3 id="0-序言"><a href="#0-序言" class="headerlink" title="0 序言"></a>0 序言</h3><p>一直感觉自己这操作系统学的一点也不扎实：（，果然之前秋招提前批被教育了，所以痛定思痛有了本系列文章，CS之路漫漫兮，吾将上下而求索~</p><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h3><h4 id="1-1-BIOS"><a href="#1-1-BIOS" class="headerlink" title="1.1 BIOS"></a>1.1 BIOS</h4><p>BIOS实际上是被固化在计算机ROM（只读存储器）芯片上的一个特殊的软件，为上层软件提供最底层的、最直接的硬件控制与支持。更形象地说，BIOS就是PC计算机硬件与上层软件程序之间的一个”桥梁”，负责访问和控制硬件。（BIOS以系统调用trap的形式提供IO 且 只能存在于系统的实模式下）</p><h4 id="1-2-BIOS是如何启动的"><a href="#1-2-BIOS是如何启动的" class="headerlink" title="1.2 BIOS是如何启动的"></a>1.2 BIOS是如何启动的</h4><p><img src="/images/ucore_01/bios.jpg" alt=""><br>首先我们必须明白计算机加电的时候是从哪读出第一条指令的，以x86为例，CPU根据CS（代码段寄存器）,IP（指令指针寄存器）的值计算得出<font color="red">PC=16*CS + IP</font>,此时PC为20位的二进制值（因为在实模式下只有20根地址总线，所以只能寻址1MB），在X86架构中 CS:IP 用来表示寻址（这里的PC就是一个概念上的寻址寄存器，实际递增的是IP寄存器），在ARM架构中PC寄存器是存在的（R15），得到地址取出地址中的执行，这条指令是个跳转指令，通过跳转指令跳到BIOS例行程序起始点。BIOS做完计算机硬件自检和初始化后，会选择一个启动设备（例如软盘、硬盘、光盘等），并且读取该设备的第一扇区(即主引导扇区或启动扇区)到内存一个特定的地址0x7c00处，然后CPU控制权会转移到那个地址继续执行。至此BIOS的初始化工作做完了，进一步的工作交给了ucore的bootloader。</p><h4 id="1-3-BIOS是如何启动系统的"><a href="#1-3-BIOS是如何启动系统的" class="headerlink" title="1.3 BIOS是如何启动系统的"></a>1.3 BIOS是如何启动系统的</h4><p><img src="/images/ucore_01/bios start.jpg" alt=""></p><ol><li>BIOS将bootloader（加载程序）从磁盘的主引导扇区(MBR)加载到内存0x7c00</li><li>跳转到0000（CS）:7c00（IP）</li><li>执行2中地址的bootloader</li><li>初始化各种寄存器，禁用中断，使能A20（拓宽地址总线宽度），加载GDT，使能cr0进入保护模式，修改保护模式下的各寄存器值，设置堆栈调用bootmain.c</li><li>加载elf格式的OS</li></ol><h3 id="2-分析make生成执行文件的过程"><a href="#2-分析make生成执行文件的过程" class="headerlink" title="2 分析make生成执行文件的过程"></a>2 分析make生成执行文件的过程</h3><h4 id="2-1-分析操作系统镜像文件ucore-img是如何一步一步生成的？"><a href="#2-1-分析操作系统镜像文件ucore-img是如何一步一步生成的？" class="headerlink" title="2.1 分析操作系统镜像文件ucore.img是如何一步一步生成的？"></a>2.1 分析操作系统镜像文件ucore.img是如何一步一步生成的？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   // 生成系统镜像</span><br><span class="line">UCOREIMG    := $(call totarget,ucore.img)</span><br><span class="line"></span><br><span class="line">$(UCOREIMG): $(kernel) $(bootblock)</span><br><span class="line">$(V)dd if=/dev/zero of=$@ count=10000 // 创建一个大小为10000字节的串</span><br><span class="line">$(V)dd if=$(bootblock) of=$@ conv=notrunc // 将bootblock默认写入第一个块</span><br><span class="line">$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc  // 将kernel默认写入第二个块</span><br><span class="line"></span><br><span class="line">$(call create_target,ucore.img)</span><br><span class="line"></span><br><span class="line"> // 生成kernel</span><br><span class="line">kernel = $(call totarget,kernel)</span><br><span class="line"></span><br><span class="line">$(kernel): tools/kernel.ld</span><br><span class="line"></span><br><span class="line">$(kernel): $(KOBJS)</span><br><span class="line">@echo + ld $@</span><br><span class="line">$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)</span><br><span class="line">@$(OBJDUMP) -S $@ &gt; $(call asmfile,kernel)</span><br><span class="line">@$(OBJDUMP) -t $@ | $(SED) &apos;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&apos; &gt; $(call symfile,kernel)</span><br><span class="line"></span><br><span class="line">$(call create_target,kernel)</span><br><span class="line"></span><br><span class="line">// 创建启动块</span><br><span class="line">bootfiles = $(call listf_cc,boot)</span><br><span class="line">$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))</span><br><span class="line"></span><br><span class="line">bootblock = $(call totarget,bootblock)</span><br><span class="line"></span><br><span class="line">$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)</span><br><span class="line">@echo + ld $@</span><br><span class="line">$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)</span><br><span class="line">@$(OBJDUMP) -S $(call objfile,bootblock) &gt; $(call asmfile,bootblock)</span><br><span class="line">@$(OBJDUMP) -t $(call objfile,bootblock) | $(SED) &apos;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&apos; &gt; $(call symfile,bootblock)</span><br><span class="line">@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)</span><br><span class="line">@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)</span><br><span class="line"></span><br><span class="line">$(call create_target,bootblock)</span><br></pre></td></tr></table></figure><h4 id="2-2-一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><a href="#2-2-一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？" class="headerlink" title="2.2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"></a>2.2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</h4><ol><li>主引导记录MBR的大小为512字节</li><li>MBR结束字为[0x55 0xAA]<br>在tool/sign.c中可以很清晰的看到MBR的结束标志字（55AA）2字节以及主引导记录大小512字节<br><img src="/images/ucore_01/MBR.jpg" alt=""><h3 id="3-调试BIOS的加载"><a href="#3-调试BIOS的加载" class="headerlink" title="3 调试BIOS的加载"></a>3 调试BIOS的加载</h3></li></ol><p>实验步骤如下：</p><ol><li>qemu -hda ucore.img -s -S  # 打开qemu并附加参数-s设置连接端口1234</li><li>gdb </li><li>target remote localhost:1234 # gdb连接qemu（也可忽略前三步直接make debug）</li><li>输入 b  *0x7c00设置断点</li><li>continue</li><li>x/i $pc # 查看一条当前的指令<br>可以看到0x7c00处的代码和bootasm.S处的代码一致<br><img src="/images/ucore_01/init.jpg" alt=""><br><img src="/images/ucore_01/bootasm.jpg" alt=""></li></ol><h3 id="4-分析bootloader进入保护模式的过程"><a href="#4-分析bootloader进入保护模式的过程" class="headerlink" title="4 分析bootloader进入保护模式的过程"></a>4 分析bootloader进入保护模式的过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># start address should be 0:7c00, in real mode, the beginning address of the running bootloader</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">.code16                                             # Assemble for 16-bit mode</span><br><span class="line">    cli                                             # Disable interrupts</span><br><span class="line">    cld                                             # String operations increment</span><br><span class="line"></span><br><span class="line">    # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">    xorw %ax, %ax                                   # Segment number zero</span><br><span class="line">    movw %ax, %ds                                   # -&gt; Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; Extra Segment</span><br><span class="line">    movw %ax, %ss                                   # -&gt; Stack Segment</span><br><span class="line"></span><br><span class="line">    # Enable A20:</span><br><span class="line">    #  For backwards compatibility with the earliest PCs, physical</span><br><span class="line">    #  address line 20 is tied low, so that addresses higher than</span><br><span class="line">    #  1MB wrap around to zero by default. This code undoes this.</span><br><span class="line">seta20.1:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    outb %al, $0x64                                 # 0xd1 means: write data to 8042&apos;s P2 port</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">    outb %al, $0x60                                 # 0xdf = 11011111, means set P2&apos;s A20 bit(the 1 bit) to 1</span><br><span class="line"></span><br><span class="line">    # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">    # and segment translation that makes virtual addresses</span><br><span class="line">    # identical to physical addresses, so that the</span><br><span class="line">    # effective memory map does not change during the switch.</span><br><span class="line">    lgdt gdtdesc</span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $CR0_PE_ON, %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line"></span><br><span class="line">    # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">    # Switches processor into 32-bit mode.</span><br><span class="line">    ljmp $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure><p>根据代码注释可以总结得bootloaer进入保护模式的流程为：</p><ol><li>禁用中断</li><li>复位标志寄存器</li><li>初始化ds，es，ss三个段（设置为0）</li><li>使能A20（扩大寻址空间）</li><li>跳转到gdtdes中，加载GDT（全局描述符表）</li><li>使能cr0，切换到保护模式</li></ol><h3 id="5-分析bootloader加载ELF格式的OS的过程"><a href="#5-分析bootloader加载ELF格式的OS的过程" class="headerlink" title="5 分析bootloader加载ELF格式的OS的过程"></a>5 分析bootloader加载ELF格式的OS的过程</h3><h4 id="5-2-elf文件格式"><a href="#5-2-elf文件格式" class="headerlink" title="5.2 elf文件格式"></a>5.2 elf文件格式</h4><p><img src="/images/ucore_01/elf.png" alt=""><br><img src="/images/ucore_01/elf_seek.png" alt=""></p><h4 id="5-1-bootloader如何读取硬盘扇区的？"><a href="#5-1-bootloader如何读取硬盘扇区的？" class="headerlink" title="5.1 bootloader如何读取硬盘扇区的？"></a>5.1 bootloader如何读取硬盘扇区的？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">* waitdisk - wait for disk ready */</span><br><span class="line">static void</span><br><span class="line">waitdisk(void) &#123;</span><br><span class="line">    while ((inb(0x1F7) &amp; 0xC0) != 0x40)</span><br><span class="line">        /* do nothing */;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* readsect - read a single sector at @secno into @dst */</span><br><span class="line">static void</span><br><span class="line">readsect(void *dst, uint32_t secno) &#123;</span><br><span class="line">    // wait for disk to be ready</span><br><span class="line">    waitdisk(); // 等待磁盘就绪</span><br><span class="line"></span><br><span class="line">    outb(0x1F2, 1);    // 将要存取的扇区数（此处为1）存到0x1F2</span><br><span class="line">    outb(0x1F3, secno &amp; 0xFF);</span><br><span class="line">    outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);</span><br><span class="line">    outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF); </span><br><span class="line">    outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);// 0x1F3-0x1F6被用来设置扇区偏移</span><br><span class="line">    outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors，将READ命令存储到0x1F7（用来发起命令读取扇区）</span><br><span class="line"></span><br><span class="line">    // wait for disk to be ready</span><br><span class="line">    waitdisk(); // 等待磁盘就绪</span><br><span class="line"></span><br><span class="line">    // read a sector</span><br><span class="line">    insl(0x1F0, dst, SECTSIZE / 4);  // 通过CPU将数据从磁盘读到RAM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读扇区的流程总结为：</p><ol><li>等待磁盘准备好</li><li>写地址0x1f2~0x1f5,0x1f7,发出读取磁盘的命令</li><li>等待磁盘准备好</li><li>调用函数insl把扇区数据读到内存</li></ol><h4 id="5-2-bootloader是如何加载ELF格式的OS？"><a href="#5-2-bootloader是如何加载ELF格式的OS？" class="headerlink" title="5.2 bootloader是如何加载ELF格式的OS？"></a>5.2 bootloader是如何加载ELF格式的OS？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/* *</span><br><span class="line"> * readseg - read @count bytes at @offset from kernel into virtual address @va,</span><br><span class="line"> * might copy more than asked.</span><br><span class="line"> * */</span><br><span class="line">static void</span><br><span class="line">readseg(uintptr_t va, uint32_t count, uint32_t offset) &#123;</span><br><span class="line">    uintptr_t end_va = va + count;</span><br><span class="line"></span><br><span class="line">    // round down to sector boundary</span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    // translate from bytes to sectors; kernel starts at sector 1</span><br><span class="line">    uint32_t secno = (offset / SECTSIZE) + 1;</span><br><span class="line"></span><br><span class="line">    // If this is too slow, we could read lots of sectors at a time.</span><br><span class="line">    // We&apos;d write more to memory than asked, but it doesn&apos;t matter --</span><br><span class="line">    // we load in increasing order.</span><br><span class="line">    for (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">        readsect((void *)va, secno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* bootmain - the entry of bootloader */</span><br><span class="line">void</span><br><span class="line">bootmain(void) &#123;</span><br><span class="line">    // 读取磁盘的第一页(大小为4K),这里一个sectsize为512字节</span><br><span class="line">    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);</span><br><span class="line"></span><br><span class="line">    // 判断是否是合法的elf文件格式</span><br><span class="line">    if (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        goto bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct proghdr *ph, *eph;</span><br><span class="line"></span><br><span class="line">    // ELF头部有描述ELF文件应加载到内存什么位置的描述表，这里读取出来将之存入ph</span><br><span class="line">    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">// 读出elf文件的段个数作为索引值</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    for (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">// 读取每个elf文件段的内容</span><br><span class="line">        readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // call the entry point from the ELF header</span><br><span class="line">    // note: does not return</span><br><span class="line">    ((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    outw(0x8A00, 0x8A00);</span><br><span class="line">    outw(0x8A00, 0x8E00);</span><br><span class="line"></span><br><span class="line">    /* do nothing */</span><br><span class="line">    while (1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出程序控制流：</p><ol><li>运行bootmain，调用readseg读取多个扇区</li><li>readseg循环执行readsect读取每个扇区</li><li>返回bootmain，判断elf格式</li><li>将ELFheader读入ph（pragram header,程序头表）</li><li>将ph中各个section读入内存</li><li>通过内核入口函数加载内核</li></ol><h3 id="6-实现函数调用堆栈跟踪函数"><a href="#6-实现函数调用堆栈跟踪函数" class="headerlink" title="6 实现函数调用堆栈跟踪函数"></a>6 实现函数调用堆栈跟踪函数</h3><p>这里的代码根据注释不难写出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    void print_stackframe(void) &#123;</span><br><span class="line">        uint32_t ebp=read_ebp();        //(1) call read_ebp() to get the value of ebp. the type is (uint32_t)</span><br><span class="line">        uint32_t eip=read_eip();        //(2) call read_eip() to get the value of eip. the type is (uint32_t)</span><br><span class="line">        for(int i=0;i&lt;STACKFRAME_DEPTH&amp;&amp;ebp!=0;i++)&#123;    //(3) from 0 .. STACKFRAME_DEPTH</span><br><span class="line">              cprintf(&quot;ebp:0x%08x   eip:0x%08x &quot;,ebp,eip);    //(3.1)printf value of ebp, eip</span><br><span class="line">              uint32_t *tmp=(uint32_t *)ebp+2;</span><br><span class="line">              cprintf(&quot;arg :0x%08x 0x%08x 0x%08x 0x%08x&quot;,*(tmp+0),*(tmp+1),*(tmp+2),*(tmp+3));    //(3.2)(uint32_t)calling </span><br><span class="line"></span><br><span class="line">arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4]</span><br><span class="line">              cprintf(&quot;\n&quot;);            //(3.3) cprintf(&quot;\n&quot;);</span><br><span class="line">              print_debuginfo(eip-1);    //(3.4) call print_debuginfo(eip-1) to print the C calling function name and line </span><br><span class="line"></span><br><span class="line">number, etc.</span><br><span class="line">              eip=((uint32_t *)ebp)[1];</span><br><span class="line">              ebp=((uint32_t *)ebp)[0];    //(3.5) popup a calling stackframe</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如图所示：<br><img src="/images/ucore_01/5lab.jpg" alt=""></p><p>ebp是栈底指针，从该地址为基准，向上（栈底方向）能获取返回地址、参数值，向下（栈顶方向）能获取函数局部变量值，而该地址处又存储着上一层函数调用时的ebp值，eip则是指令指针寄存器保存着下一条指令的地址,最后一行输出的信息是debug_info，查看该函数定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void print_debuginfo(uintptr_t eip) &#123;</span><br><span class="line">    struct eipdebuginfo info;</span><br><span class="line">    if (debuginfo_eip(eip, &amp;info) != 0) &#123;</span><br><span class="line">        cprintf(&quot;    &lt;unknow&gt;: -- 0x%08x --\n&quot;, eip);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        char fnname[256];</span><br><span class="line">        int j;</span><br><span class="line">        for (j = 0; j &lt; info.eip_fn_namelen; j ++) &#123;</span><br><span class="line">            fnname[j] = info.eip_fn_name[j];</span><br><span class="line">        &#125;</span><br><span class="line">        fnname[j] = &apos;\0&apos;;</span><br><span class="line">        cprintf(&quot;    %s:%d: %s+%d\n&quot;, info.eip_file, info.eip_line,</span><br><span class="line">                fnname, eip - info.eip_fn_addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出最行一行输出的信息是源码所在文件名，源码所在行数（eip指向的指令对应），函数名，源码的长度（当前指令执行位置-函数起始位置）或者是不合法的eip（没找到eip对应的info，这里的info就是eipdebuginfo数据结构）<br>最后一个0x00007d63不合法的原因是我们还没有写内存管理模块（没有引入虚拟地址的抽象）…这里程序的堆栈空间范围在0~0x7c00(在bootasm.S中,感谢TsushimaAlice同学告知)所以超出堆栈的行为是未定义的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">kern_init(void)&#123;</span><br><span class="line">    extern char edata[], end[];</span><br><span class="line">    memset(edata, 0, end - edata);</span><br><span class="line"></span><br><span class="line">    cons_init();                // init the console</span><br><span class="line"></span><br><span class="line">    const char *message = &quot;(THU.CST) os is loading ...&quot;;</span><br><span class="line">    cprintf(&quot;%s\n\n&quot;, message);</span><br><span class="line"></span><br><span class="line">    print_kerninfo();</span><br><span class="line"></span><br><span class="line">    grade_backtrace();</span><br><span class="line"></span><br><span class="line">    pmm_init();                 // init physical memory management</span><br><span class="line"></span><br><span class="line">    pic_init();                 // init interrupt controller</span><br><span class="line">    idt_init();                 // init interrupt descriptor table</span><br><span class="line"></span><br><span class="line">    clock_init();               // init clock interrupt</span><br><span class="line">    intr_enable();              // enable irq interrupt</span><br><span class="line"></span><br><span class="line">    //LAB1: CAHLLENGE 1 If you try to do it, uncomment lab1_switch_test()</span><br><span class="line">    // user/kernel mode switch test</span><br><span class="line">    lab1_switch_test();</span><br><span class="line"></span><br><span class="line">    /* do nothing */</span><br><span class="line">    while (1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="7-完善中断初始化和处理"><a href="#7-完善中断初始化和处理" class="headerlink" title="7 完善中断初始化和处理"></a>7 完善中断初始化和处理</h3><p>在X86架构中，中断可以分为3种：</p><ol><li>和CPU无关的，比如外设的请求等，这些属于Interrupt。</li><li>和CPU有关的，比如除0，page fault等，这些属于Exception。</li><li>系统调用，这些属于Trap</li></ol><h4 id="7-1-中断描述符表项及字段含义"><a href="#7-1-中断描述符表项及字段含义" class="headerlink" title="7.1 中断描述符表项及字段含义"></a>7.1 中断描述符表项及字段含义</h4><p><img src="/images/ucore_01/IDT.png" alt=""><br>可以看出，一个表项占32*2位，8个字节。0到15位和48到63位为偏移量的低位和高位。16到31位是段选择子。 通过这几个数据来找到中断处理代码的入口。</p><h4 id="7-2-初始化idt"><a href="#7-2-初始化idt" class="headerlink" title="7.2 初始化idt"></a>7.2 初始化idt</h4><p>中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void idt_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* LAB1 YOUR CODE : STEP 2 */</span><br><span class="line">    /* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?</span><br><span class="line">      *     All ISR&apos;s entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?</span><br><span class="line">      *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c</span><br><span class="line">      *     (try &quot;make&quot; command in lab1, then you will find vector.S in kern/trap DIR)</span><br><span class="line">      *     You can use  &quot;extern uintptr_t __vectors[];&quot; to define this extern variable which will be used later.</span><br><span class="line">      * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT).</span><br><span class="line">      *     Can you see idt[256] in this file? Yes, it&apos;s IDT! you can use SETGATE macro to setup each item of IDT</span><br><span class="line">      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using &apos;lidt&apos; instruction.</span><br><span class="line">      *     You don&apos;t know the meaning of this instruction? just google it! and check the libs/x86.h to know more.</span><br><span class="line">      *     Notice: the argument of lidt is idt_pd. try to find it!</span><br><span class="line">      */</span><br><span class="line">    int i = 0;</span><br><span class="line">    extern uintptr_t __vectors[];</span><br><span class="line">    for(i = 0; i &lt; 255; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">//  vectors 中存储了中断处理程序的入口地址。vectors 定义在 vector.S 文件中，通过一个工具程序 vector.c 生成</span><br><span class="line">        SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], 0); </span><br><span class="line">    &#125;</span><br><span class="line">// 切换用户模式到内核模式</span><br><span class="line">    SETGATE(idt[T_SWITCH_TOK], 1, GD_KTEXT, __vectors[T_SWITCH_TOK], 3);// </span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思路是：</p><ol><li>通过SETGATE宏初始化idt表（这里体现为一维数组）</li><li>准备执行lidt指令，因为trap是系统调用，所以执行idt_init的时候是在DPL_USER（3）的模式，而根据实验指导书，lidt需要在DPL_KERNEL（0）模式执行，所以需要切换用户模式到内核模式</li><li>执行lidt，使用一个包含线性地址基址和界限的内存操作数来加载IDT</li></ol><h4 id="7-3-时钟中断"><a href="#7-3-时钟中断" class="headerlink" title="7.3 时钟中断"></a>7.3 时钟中断</h4><p>中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">/* LAB1 YOUR CODE : STEP 3 */</span><br><span class="line">/* handle the timer interrupt */</span><br><span class="line">/* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in </span><br><span class="line"></span><br><span class="line">kern/driver/clock.c</span><br><span class="line">* (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().</span><br><span class="line">* (3) Too Simple? Yes, I think so!</span><br><span class="line">*/</span><br><span class="line">ticks ++;</span><br><span class="line">if (ticks % TICK_NUM == 0) &#123;</span><br><span class="line">print_ticks();</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br></pre></td></tr></table></figure><p>思路是：每次 handles or dispatches an exception/interrupt都会调用trap，trap中通过累加tick这个时钟周期的全局变量（定义在clock.c）到100来触发时钟中断</p><h3 id="8-小结"><a href="#8-小结" class="headerlink" title="8 小结"></a>8 小结</h3><p>bootloader的启动到OS的加载流程为：</p><ol><li>禁用中断</li><li>复位标志寄存器</li><li>初始化ds，es，ss三个段（设置为0）</li><li>使能A20（扩大寻址空间）</li><li>跳转到gdtdes中，加载GDT（全局描述符表）</li><li>使能cr0，切换到保护模式</li><li>切换到32位模式</li><li>修改保护模式下各个寄存器的值</li><li>设置堆栈以调用C,初始化栈区（0x0~0x7c00）</li><li>调用bootmain.c</li><li>运行bootmain，调用readseg读取多个扇区</li><li>readseg循环执行readsect读取每个扇区</li><li>返回bootmain，判断elf格式</li><li>将ELFheader读入ph（pragram header,程序头表）</li><li>将ph中各个section读入内存</li><li>通过内核入口函数加载内核</li></ol><p>总的来说实验量还是很好的，实验指导书也很到位，看项目级代码果然需要一个静态分析利器啊，感谢清华！</p><h3 id="9-Reference"><a href="#9-Reference" class="headerlink" title="9 Reference"></a>9 Reference</h3><p><a href="https://www.jianshu.com/p/47dd6d3f551e" title="TsushimaAlice同学 简书 lab1" target="_blank" rel="noopener">TsushimaAlice同学 简书 lab1</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uCore </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>西天取经之设计模式之道（序言）</title>
      <link href="/2018/09/07/design-pattern_00/"/>
      <url>/2018/09/07/design-pattern_00/</url>
      
        <content type="html"><![CDATA[<p>本系列文章用于学习设计模式之道</p><h3 id="0-序言"><a href="#0-序言" class="headerlink" title="0 序言"></a>0 序言</h3><p>随着写了各种各样范型的语言（OOP，过程式，声明式，一点点逻辑Coq），我觉得是时候总结该怎么有效的组织代码了，毕竟再过不久就要面向业务需求编程，本系列对于每个模式分为三个部分</p><ol><li>模式的讲解（what and why ，how）</li><li>模式实战</li><li>模式之融汇贯通</li></ol><p>考虑到本人目前为一个尚未从业的计算机本科生（马上大四了…），工程方面只能说勉强入了个门，所以总结暂时集中在1和2部分，以后在源码分析系列会与剖析各类源码的设计思想穿插讲解第3部分，在这里非常希望各位前辈和同学能给我留言交流，十分感谢！</p><h3 id="1-目录"><a href="#1-目录" class="headerlink" title="1 目录"></a>1 目录</h3>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计之道 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从零开始的编译原理之旅----Parser篇(四)</title>
      <link href="/2018/09/06/parser_04/"/>
      <url>/2018/09/06/parser_04/</url>
      
        <content type="html"><![CDATA[<p>本篇主要阐述使用递归下降非回溯或回溯解析LL(1)文法，并比较两者优缺点</p><h3 id="1-目录"><a href="#1-目录" class="headerlink" title="1 目录"></a>1 目录</h3><p>本系列旨在学习各种parser思路及技巧，分为以下几个部分</p><ol start="0"><li><a href="https://belyenochi.github.io/2018/08/28/parser_00/#more" target="_blank" rel="noopener"> 清晨入古寺—-论世间parser为何物</a></li><li><a href="https://belyenochi.github.io/2018/09/03/parser_01/#more" target="_blank" rel="noopener"> 初日照高林—-初探First集，Follow集 </a></li><li><a href="https://belyenochi.github.io/2018/09/04/parser_02/#more" target="_blank" rel="noopener"> 曲径通幽处—-预测分析表的构建 </a></li><li><a href="https://belyenochi.github.io/2018/09/04/parser_06/#more" target="_blank" rel="noopener"> 禅房花木深—-实现LL(1) parser </a></li><li><a href="https://belyenochi.github.io/2018/09/04/parser_06/#more" target="_blank" rel="noopener"> 山光悦鸟性—-递归下降的两种实现 <strong>[本篇]</strong> </a></li><li>潭影空人心—-浅谈recursive ascent parser(SLR,LALR(1))</li><li>万籁此俱寂—-parser combinator（从ohm.js源码说起）</li><li>但余钟磬音—-反思与总结</li></ol><h3 id="2-什么是递归下降？"><a href="#2-什么是递归下降？" class="headerlink" title="2 什么是递归下降？"></a>2 什么是递归下降？</h3><p>一个递归下降语法分析程序由一组过程组成，每个非终结符有一个对应的过程。程序的执行从开始符号对应的过程开始，如果这个过程扫描了整个输入串，它就停止执行并宣布语法分析成功完成。<br>举一个直观的栗子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Grammar:</span></span><br><span class="line"><span class="comment">S-&gt;cAd</span></span><br><span class="line"><span class="comment">A-&gt;ab|a</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">compilerEngile</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(input) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compilerS() &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compilerA() &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run() &#123;</span><br><span class="line"><span class="keyword">this</span>.compilerS(); <span class="comment">// Start !!!</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><font color="red">使用递归下降解析文法通俗的讲就是调用compilerS()根据函数调用是否成功（判断是否有非法字符串）且输入串是否完全匹配（是否有多余字符）来判断解析是否成功</font><br>### 3 为什么使用递归下降解析LL（1）文法<br>上一章介绍了使用显式的维护一个stack来解析LL（1）文法，这种方法不如直接使用递归隐式的维护call stack来的直观，<font color="blue">本质上两者是等价的，唯一的区别是一个使用了系统的控制流一个自己构造控制流。</font><h3 id="4-递归下降的预测分析（不带回溯）"><a href="#4-递归下降的预测分析（不带回溯）" class="headerlink" title="4 递归下降的预测分析（不带回溯）"></a>4 递归下降的预测分析（不带回溯）</h3><p>这种递归下降属于递归下降中一种特殊的情况，不需要回溯的前提是LL（1）文法中每个非终结符的产生式<font color="red">不存在可以合并的左公因子</font>,举个栗子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Grammar:</span></span><br><span class="line"><span class="comment">S-&gt;sAd</span></span><br><span class="line"><span class="comment">A-&gt;ab|c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">compilerEngile</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(input) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compilerS() &#123;</span><br><span class="line">eat(<span class="string">'s'</span>);</span><br><span class="line"><span class="keyword">this</span>.compilerA();</span><br><span class="line">eat(<span class="string">'d'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compilerA() &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.input[cursor] === <span class="string">'a'</span>) &#123;</span><br><span class="line">eat(<span class="string">'a'</span>);</span><br><span class="line">eat(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.input[cursor] === <span class="string">'c'</span>) &#123;</span><br><span class="line">eat(<span class="string">'c'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run() &#123;</span><br><span class="line"><span class="keyword">this</span>.compilerS(); <span class="comment">// Start !!!</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码如上，可以看出并不需要回溯，但是我们来分析一下之前定义的文法，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Grammar:</span><br><span class="line">S-&gt;sAd</span><br><span class="line">A-&gt;ab|a</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>你会发现在解析A这个终结符的时候，hmmm，它第一个字母竟然是相同的也就是说没办法通过第一个字母来区分进入哪个分支，你可能会觉得这时候看第二个不就行了吗，是行了，不过因为这里的例子简单，看第二个字母的hack不会太丑，实际上编程语言的解析比这复杂很多，如果一直写，看第二个，看第三个的代码，那么代码会异常难看（我第一次不信邪的写出来过），还有同学可能会觉得这时候手动合并左公因子就行了嘛，嗯，这确实是一种方法，实际上一种更为优雅的方式就是<strong>回溯</strong>，通过回溯进入每一个分支看看是否正确。</p><h3 id="5-递归下降的预测分析（带回溯）"><a href="#5-递归下降的预测分析（带回溯）" class="headerlink" title="5 递归下降的预测分析（带回溯）"></a>5 递归下降的预测分析（带回溯）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Grammar:</span></span><br><span class="line"><span class="comment">S-&gt;sAd</span></span><br><span class="line"><span class="comment">A-&gt;ab|a</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">compilerEngile</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(input) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compilerS() &#123;</span><br><span class="line">eat(<span class="string">'s'</span>);</span><br><span class="line"><span class="keyword">this</span>.compilerA();</span><br><span class="line">eat(<span class="string">'d'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compilerA() &#123;</span><br><span class="line"><span class="keyword">if</span>(firstOf(A) === <span class="string">'a'</span>) &#123;</span><br><span class="line">eat(<span class="string">'a'</span>);</span><br><span class="line">eat(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(firstOf(A) === <span class="string">'c'</span>) &#123;</span><br><span class="line">eat(<span class="string">'c'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run() &#123;</span><br><span class="line"><span class="keyword">this</span>.compilerS(); <span class="comment">// Start !!!</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又出现一个问题，假如进行回溯那么意味着要遍历所有分支，假如有n个非终结符，m个产生式，那么时间复杂度就是O（n*m），这势必会降低效率，所以会采取一些优化，比如使用动态规划缓存结果，之后在讲解ohm.js源码的时候会详述 Incremental Packrat Parsing（递归下降回溯的优化），计算机科学嘛总是要在空间和时间之间做一个trade off。</p><p>到底使用表驱动的非递归预测分析算法还是采用递归下降就要看需求仁者见仁智者见智了。</p><h3 id="6-递归下降的非回溯实现"><a href="#6-递归下降的非回溯实现" class="headerlink" title="6 递归下降的非回溯实现"></a>6 递归下降的非回溯实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Grammar:</span></span><br><span class="line"><span class="comment">S-&gt;sAd</span></span><br><span class="line"><span class="comment">A-&gt;ab|c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">compilerEngile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(input) &#123;</span><br><span class="line">        <span class="keyword">this</span>.input  = input;</span><br><span class="line">        <span class="keyword">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    compilerS() &#123;</span><br><span class="line">        <span class="keyword">this</span>.eat(<span class="string">'s'</span>);</span><br><span class="line">        <span class="keyword">this</span>.compilerA();</span><br><span class="line">        <span class="keyword">this</span>.eat(<span class="string">'d'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    compilerA() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.input[<span class="keyword">this</span>.cursor] === <span class="string">'a'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.eat(<span class="string">'a'</span>);</span><br><span class="line">            <span class="keyword">this</span>.eat(<span class="string">'b'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.input[<span class="keyword">this</span>.cursor] === <span class="string">'c'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.eat(<span class="string">'c'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.compilerS(); <span class="comment">// Start !!!</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.input.length !== <span class="keyword">this</span>.cursor) &#123; <span class="comment">// deal with Extra unmatched characters</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`unexpected Extra unmatched characters with <span class="subst">$&#123;<span class="keyword">this</span>.input.slice(<span class="keyword">this</span>.cursor)&#125;</span>`</span> +</span><br><span class="line">                 <span class="string">`at position <span class="subst">$&#123;<span class="keyword">this</span>.cursor&#125;</span> in inputstring: <span class="subst">$&#123;<span class="keyword">this</span>.input&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`Error: <span class="subst">$&#123;e.message&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eat(inputChar) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputChar === <span class="keyword">this</span>.input[<span class="keyword">this</span>.cursor]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cursor++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`unexpected match <span class="subst">$&#123;inputChar&#125;</span> with <span class="subst">$&#123;<span class="keyword">this</span>.input&#125;</span> at position <span class="subst">$&#123;<span class="keyword">this</span>.cursor&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">assert(<span class="keyword">new</span> compilerEngile(<span class="string">"sasbds"</span>).run() === <span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line">assert(<span class="keyword">new</span> compilerEngile(<span class="string">"sasbd"</span>).run()  === <span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line">assert(<span class="keyword">new</span> compilerEngile(<span class="string">"ssbds"</span>).run()  === <span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line">assert(<span class="keyword">new</span> compilerEngile(<span class="string">"sasds"</span>).run()  === <span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line">assert(<span class="keyword">new</span> compilerEngile(<span class="string">"sabds"</span>).run()  === <span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line">assert(<span class="keyword">new</span> compilerEngile(<span class="string">"sabd"</span>).run()   === <span class="literal">true</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="7-递归下降的回溯实现"><a href="#7-递归下降的回溯实现" class="headerlink" title="7 递归下降的回溯实现"></a>7 递归下降的回溯实现</h3><p>递归下降的DFS算法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Grammar:</span></span><br><span class="line"><span class="comment">S-&gt;sAd</span></span><br><span class="line"><span class="comment">A-&gt;ab|c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">compilerEngile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(input) &#123;</span><br><span class="line">        <span class="keyword">this</span>.input  = input;</span><br><span class="line">        <span class="keyword">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    compilerS() &#123;</span><br><span class="line">        <span class="keyword">this</span>.eat(<span class="string">'s'</span>);</span><br><span class="line">        <span class="keyword">this</span>.compilerA();</span><br><span class="line">        <span class="keyword">this</span>.eat(<span class="string">'d'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    compilerA() &#123;</span><br><span class="line">        <span class="keyword">let</span> save;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (save = <span class="keyword">this</span>.saveCursor(<span class="keyword">this</span>.cursor) , <span class="keyword">this</span>.compilerA1()) ||</span><br><span class="line">            (<span class="keyword">this</span>.backtrack(save) , <span class="keyword">this</span>.compilerA2());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    compilerA1() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.eat(<span class="string">'a'</span>) &amp;&amp; <span class="keyword">this</span>.eat(<span class="string">'b'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    compilerA2() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.eat(<span class="string">'c'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.compilerS(); <span class="comment">// Start !!!</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.input.length !== <span class="keyword">this</span>.cursor) &#123; <span class="comment">// deal with Extra unmatched characters</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`unexpected Extra unmatched characters with <span class="subst">$&#123;<span class="keyword">this</span>.input.slice(<span class="keyword">this</span>.cursor)&#125;</span>`</span> +</span><br><span class="line">                    <span class="string">`at position <span class="subst">$&#123;<span class="keyword">this</span>.cursor&#125;</span> in input string: <span class="subst">$&#123;<span class="keyword">this</span>.input&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`Error: <span class="subst">$&#123;e.message&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// help function</span></span><br><span class="line"></span><br><span class="line">    eat(inputChar) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputChar === <span class="keyword">this</span>.input[<span class="keyword">this</span>.cursor]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cursor++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    backtrack(fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cursor = fn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    saveCursor(cursor) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">assert(<span class="keyword">new</span> compilerEngile(<span class="string">"sasbds"</span>).run() === <span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line">assert(<span class="keyword">new</span> compilerEngile(<span class="string">"sasbd"</span>).run()  === <span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line">assert(<span class="keyword">new</span> compilerEngile(<span class="string">"ssbds"</span>).run()  === <span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line">assert(<span class="keyword">new</span> compilerEngile(<span class="string">"sasds"</span>).run()  === <span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line">assert(<span class="keyword">new</span> compilerEngile(<span class="string">"sabds"</span>).run()  === <span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line">assert(<span class="keyword">new</span> compilerEngile(<span class="string">"sabd"</span>).run()   === <span class="literal">true</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> parser </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从零开始的编译原理之旅----Parser篇(三)</title>
      <link href="/2018/09/06/parser_03/"/>
      <url>/2018/09/06/parser_03/</url>
      
        <content type="html"><![CDATA[<p>本篇将使用非递归的预测分析来构建LL(1) Parser，下面就让我们开始吧:-)</p><h3 id="1-目录"><a href="#1-目录" class="headerlink" title="1 目录"></a>1 目录</h3><p>本系列旨在学习各种parser思路及技巧，分为以下几个部分</p><ol start="0"><li><a href="https://belyenochi.github.io/2018/08/28/parser_00/#more" target="_blank" rel="noopener"> 清晨入古寺—-论世间parser为何物</a></li><li><a href="https://belyenochi.github.io/2018/09/03/parser_01/#more" target="_blank" rel="noopener"> 初日照高林—-初探First集，Follow集 </a></li><li><a href="https://belyenochi.github.io/2018/09/04/parser_02/#more" target="_blank" rel="noopener"> 曲径通幽处—-预测分析表的构建 </a></li><li><a href="https://belyenochi.github.io/2018/09/04/parser_06/#more" target="_blank" rel="noopener"> 禅房花木深—-实现LL(1) parser <strong>[本篇]</strong></a></li><li><a href="https://belyenochi.github.io/2018/09/04/parser_06/#more" target="_blank" rel="noopener"> 山光悦鸟性—-递归下降的两种实现 </a></li><li>潭影空人心—-浅谈recursive ascent parser(SLR,LALR(1))</li><li>万籁此俱寂—-parser combinator（从ohm.js源码说起）</li><li>但余钟磬音—-反思与总结</li></ol><h3 id="2-非递归的预测分析"><a href="#2-非递归的预测分析" class="headerlink" title="2 非递归的预测分析"></a>2 非递归的预测分析</h3><p>所谓的非递归预测分析就是使用之前构建的parsing table+stack来解析input buffer。<br>算法可以描述如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">stack=[<span class="string">'S'</span>,<span class="string">'$'</span>]; <span class="comment">// S代表Start，表示起始符号，$表示栈为空</span></span><br><span class="line">cursor=第一个输入符号；</span><br><span class="line">top=栈顶符号；</span><br><span class="line"><span class="keyword">while</span>（top != $） &#123; <span class="comment">// $ 表示空的含义</span></span><br><span class="line"><span class="keyword">if</span> (isTerminal(top)) &#123;</span><br><span class="line"><span class="keyword">if</span> (top === input[cursor]) &#123;</span><br><span class="line">stack.pop();</span><br><span class="line">cursor++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">SyntaxError</span>(<span class="string">`can't match <span class="subst">$&#123;input[cursor]&#125;</span> with <span class="subst">$&#123;top&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!getProduction) &#123; <span class="comment">// 预测表不存在对应的产生式</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"parsing table don't match $&#123;top&#125; item"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到了预测表对应的产生式</span></span><br><span class="line">stack.pop();</span><br><span class="line">production字符依次压栈;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">更新top指向新的栈顶;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-非递归的预测分析实现"><a href="#3-非递归的预测分析实现" class="headerlink" title="3 非递归的预测分析实现"></a>3 非递归的预测分析实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * = LL parser =</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * by Dmitry Soshnikov &lt;dmitry.soshnikov@gmail.com&gt;</span></span><br><span class="line"><span class="comment"> * MIT Style license</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Often one can see manually written LL parsers implemented as</span></span><br><span class="line"><span class="comment"> * recursive descent. Approach in this diff is a classical parse table</span></span><br><span class="line"><span class="comment"> * state machine.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  LL parser consists of:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. input buffer (source code)</span></span><br><span class="line"><span class="comment"> * 2. stack</span></span><br><span class="line"><span class="comment"> * 3. parsing table (state machine)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parsing table:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Table is used to get the next production number to apply, based on current</span></span><br><span class="line"><span class="comment"> *   symbol from the buffer, and the symbol (terminal or non-terminal)</span></span><br><span class="line"><span class="comment"> *   on top of the stack.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - Rows in the table are non-terminals</span></span><br><span class="line"><span class="comment"> *   - Columns are terminals</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parsing algorithm:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - if the top of the stack is *terminal*, and matches current symbol in</span></span><br><span class="line"><span class="comment"> *     buffer, then just discard it from the stack, and move cursor further.</span></span><br><span class="line"><span class="comment"> *     (if doesn't match -- parse error).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - Else (it must be a non-terminal), replace it with an</span></span><br><span class="line"><span class="comment"> *     alternative production, corresponding to the production number.</span></span><br><span class="line"><span class="comment"> *     (if no production -- parse error).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * $ - is a special symbol used to mark bottom of the stack</span></span><br><span class="line"><span class="comment"> *     and end of the buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * S - is a start symbol.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * At the beginning stack is:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [S, $]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Grammar:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   1. S -&gt; F</span></span><br><span class="line"><span class="comment"> *   2. S -&gt; (S + F)</span></span><br><span class="line"><span class="comment"> *   3. F -&gt; a</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Input:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (a + a)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parse table:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   +------------------+</span></span><br><span class="line"><span class="comment"> *   |    (  )  a  +  $ |</span></span><br><span class="line"><span class="comment"> *   +------------------+</span></span><br><span class="line"><span class="comment"> *   | S  2  -  1  -  - |</span></span><br><span class="line"><span class="comment"> *   | F  -  -  3  -  - |</span></span><br><span class="line"><span class="comment"> *   +------------------+</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The production rules which are applied to parse `(a + a)` are: 2, 1, 3, 3:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * S -&gt; ( S + F ) -&gt; ( F + F ) -&gt; ( a + F ) -&gt; ( a + a )</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We see that each time the *left most* non-terminal is replaced. Hence, the</span></span><br><span class="line"><span class="comment"> * name of the parser: LL - scan source from Left to right, and apply the</span></span><br><span class="line"><span class="comment"> * Left most derivation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Our grammar representation. Key is a production number from</span></span><br><span class="line"><span class="comment"> * the grammar, the value is: 0 - LHS, 1 - RHS of the production.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> grammar = &#123;</span><br><span class="line">    <span class="number">1</span>: [<span class="string">'S'</span>, <span class="string">'F'</span>],       <span class="comment">// 1. S -&gt; F</span></span><br><span class="line">    <span class="number">2</span>: [<span class="string">'S'</span>, <span class="string">'(S + F)'</span>], <span class="comment">// 2. S -&gt; (S + F)</span></span><br><span class="line">    <span class="number">3</span>: [<span class="string">'F'</span>, <span class="string">'a'</span>],       <span class="comment">// 3. F -&gt; a</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initial stack: bottom is the "end of the stack" ($),</span></span><br><span class="line"><span class="comment"> * and the start symbol ('S' in our case) is there too.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> stack = [<span class="string">'S'</span>, <span class="string">'$'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parseFromTable(source, buildTable(grammar, source));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printGrammar</span>(<span class="params">grammar</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Grammar:\n'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> grammar) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'  '</span> + k + <span class="string">'.'</span>, grammar[k][<span class="number">0</span>], <span class="string">'-&gt;'</span>, grammar[k][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Builds a state-machine table where table[non-terminal][terminal]</span></span><br><span class="line"><span class="comment"> * coordinates determine which next production rule to apply.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildTable</span>(<span class="params">grammar, source</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// For now we assume a correct table was already built from</span></span><br><span class="line">    <span class="comment">// the grammar and source for us. We'll cover how to build it</span></span><br><span class="line">    <span class="comment">// automatically in the next lessons (see "first" and "follow"</span></span><br><span class="line">    <span class="comment">// sets topic). We encode only valid rules here and skip all other</span></span><br><span class="line">    <span class="comment">// (they return `undefined` meaning a parse error).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// +------------------+</span></span><br><span class="line">    <span class="comment">// |    (  )  a  +  $ |</span></span><br><span class="line">    <span class="comment">// +------------------+</span></span><br><span class="line">    <span class="comment">// | S  2  -  1  -  - |</span></span><br><span class="line">    <span class="comment">// | F  -  -  3  -  - |</span></span><br><span class="line">    <span class="comment">// +------------------+</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'S'</span>: &#123;<span class="string">'('</span>: <span class="number">2</span>, <span class="string">'a'</span>: <span class="number">1</span>&#125;,</span><br><span class="line">        <span class="string">'F'</span>: &#123;<span class="string">'a'</span>: <span class="number">3</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> productionNumbers = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parses a source using parse table.</span></span><br><span class="line"><span class="comment"> * Doesn't build a parse tree yet, but just checks a source</span></span><br><span class="line"><span class="comment"> * string for acceptance (prints production rules appled in case</span></span><br><span class="line"><span class="comment"> * of successful parse, or throws on parse errors).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseFromTable</span>(<span class="params">source, table</span>) </span>&#123;</span><br><span class="line">    printGrammar(grammar);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Source:'</span>, source);</span><br><span class="line">    source = source.replace(<span class="regexp">/\s+/g</span>, <span class="string">''</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> cursor = <span class="number">0</span>; cursor &lt; source.length;) &#123;</span><br><span class="line">        <span class="keyword">var</span> current = source[cursor];</span><br><span class="line">        <span class="keyword">var</span> top = stack.shift();</span><br><span class="line">        <span class="comment">// Terminal is on the stack, just advance.</span></span><br><span class="line">        <span class="keyword">if</span> (isTerminal(top, table) &amp;&amp; top === current) &#123;</span><br><span class="line">            <span class="comment">// We already shifted the symbol from the stack,</span></span><br><span class="line">            <span class="comment">// so just advance the cursor.</span></span><br><span class="line">            cursor++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Else, it's a non-terminal, do derivation (replace it</span></span><br><span class="line">        <span class="comment">// in the stack with corresponding production).</span></span><br><span class="line">        stack.unshift.apply(stack, getProduction(table, top, current));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Accepted. Productions:'</span>, productionNumbers.join(<span class="string">', '</span>), <span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isTerminal</span>(<span class="params">symbol, table</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !table.hasOwnProperty(symbol);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProduction</span>(<span class="params">table, top, current</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nextProductionNumber = table[top][current];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nextProductionNumber) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Parse error, unexpected token: '</span> + current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nextProduction = grammar[nextProductionNumber];</span><br><span class="line"></span><br><span class="line">    productionNumbers.push(nextProductionNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return an array of symbols from a production, e.g.</span></span><br><span class="line">    <span class="comment">// '(', 'S', '+', 'F', ')' for '(S + F)', since</span></span><br><span class="line">    <span class="comment">// each symbol should be pushed onto the stack.</span></span><br><span class="line">    <span class="keyword">return</span> nextProduction[<span class="number">1</span>].split(<span class="regexp">/\s*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test:</span></span><br><span class="line">parse(<span class="string">'(a + a)'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Grammar:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   1. S -&gt; F</span></span><br><span class="line"><span class="comment">//   2. S -&gt; (S + F)</span></span><br><span class="line"><span class="comment">//   3. F -&gt; a</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source: (a + a)</span></span><br><span class="line"><span class="comment">// Accepted. Productions: 2, 1, 3, 3</span></span><br></pre></td></tr></table></figure><font color="red">可以看到表驱动的LL(1)Parser generator就完成了，后文讲解ohm.js还可以看到递归下降的parser generator，不过下文递归下降的两种实现都是手写递归下降的parser.</font><h3 id="4-Reference"><a href="#4-Reference" class="headerlink" title="4 Reference"></a>4 Reference</h3><p><a href="https://gist.github.com/DmitrySoshnikov/29f7a9425cdab69ea68f" title="DmitrySoshnikov gist" target="_blank" rel="noopener">DmitrySoshnikov gist</a></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> parser </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从零开始的编译原理之旅----Parser篇(二)</title>
      <link href="/2018/09/04/parser_02/"/>
      <url>/2018/09/04/parser_02/</url>
      
        <content type="html"><![CDATA[<h3 id="1-目录"><a href="#1-目录" class="headerlink" title="1 目录"></a>1 目录</h3><p>本系列旨在学习各种parser思路及技巧，分为以下几个部分</p><ol start="0"><li><a href="https://belyenochi.github.io/2018/08/28/parser_00/#more" target="_blank" rel="noopener"> 清晨入古寺—-论世间parser为何物</a></li><li><a href="https://belyenochi.github.io/2018/09/03/parser_01/#more" target="_blank" rel="noopener"> 初日照高林—-初探First集，Follow集 </a></li><li><a href="https://belyenochi.github.io/2018/09/04/parser_02/#more" target="_blank" rel="noopener"> 曲径通幽处—-预测分析表的构建 <strong>[本篇]</strong></a></li><li><a href="https://belyenochi.github.io/2018/09/04/parser_06/#more" target="_blank" rel="noopener"> 禅房花木深—-实现LL(1) parser </a></li><li><a href="https://belyenochi.github.io/2018/09/04/parser_06/#more" target="_blank" rel="noopener"> 山光悦鸟性—-递归下降的两种实现 </a></li><li>潭影空人心—-浅谈recursive ascent parser(SLR,LALR(1))</li><li>万籁此俱寂—-parser combinator（从ohm.js源码说起）</li><li>但余钟磬音—-反思与总结</li></ol><h3 id="2-什么是预测分析表"><a href="#2-什么是预测分析表" class="headerlink" title="2 什么是预测分析表"></a>2 什么是预测分析表</h3><p>预测分析表是在语法分析中用于进行预测分析的数据结构，龙书上有比较详细的定义，在这里就举一个栗子来说明：</p><p>假定有如下文法：</p><pre><code>S -&gt; FS -&gt; (S + F)F -&gt; a</code></pre><p>它的预测分析表长这个样：</p><table><thead><tr><th>非终结符/终结符</th><th style="text-align:right">(</th><th style="text-align:center">)</th><th>a</th><th>+</th><th>$</th></tr></thead><tbody><tr><td>S</td><td style="text-align:right">S -&gt; (S + F)</td><td style="text-align:center">-</td><td>S -&gt; F</td><td>-</td><td>-</td></tr><tr><td>F</td><td style="text-align:right">-</td><td style="text-align:center">-</td><td>F -&gt; a</td><td>-</td><td>-</td></tr></tbody></table><p>假如这时我们要解析一个字符串”(a + a)”</p><ol><li>读入”(“</li><li>查询预测分析表</li><li>根据预测分析表结果，进入相应的产生式（也可称展开产生式）</li><li>这里有两种等价的方式实现匹配<br>4.1 使用程序的调用栈递归进行预测分析，当程序正常结束且输入完全匹配时，语法分析成功<br>4.2 使用栈数据结构来非递归的预测分析，当栈为空且完全匹配时，语法分析成功</li></ol><p><font color="red">Tip:这里有同学可能会问，为啥总是能用非递归来模拟递归？</font><br>其实在Forthan的年代，人们还木有意识到递归对于程序的用处，第一个倡导编程语言应该实现递归的就是大名鼎鼎的Dijkstra ，随着<a href="https://dijkstrascry.com/node/4" title="Dijkstra的论文" target="_blank" rel="noopener">Dijkstra的论文</a>发表，在 那之后的语言比如ALGOL 60便使用了call stack这个概念来实现递归，不过据说在forthan的年代（也就是50年代早期）IBM的机器还没有堆栈实现，并且机器很小，估计用了递归效率也够呛，不过递归的威力早在Church提出lambda calculus以及 Church encoding就已经显现出来了。</p><h3 id="3-为什么需要预测分析表"><a href="#3-为什么需要预测分析表" class="headerlink" title="3 为什么需要预测分析表"></a>3 为什么需要预测分析表</h3><p>其实你也可以不用实现预测分析表，预测分析表的本质就是对当前字符进行分支判断吗，只不过这分支比较多，然后你懂的代码写出来都是if-else，嵌套if-else，这一点都不优雅：（，据说优雅的程序员能找到女朋友：），所以我们需要预测分析表来驱动预测语义分析（这部分龙书语法分析部分讲的挺细）</p><h3 id="4-实现预测分析表"><a href="#4-实现预测分析表" class="headerlink" title="4 实现预测分析表"></a>4 实现预测分析表</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Building LL(1) parsing table from First and Follow sets.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * by Dmitry Soshnikov &lt;dmitry.soshnikov@gmail.com&gt;</span></span><br><span class="line"><span class="comment"> * MIT Style License</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This diff is a continuation of what we started in the previous two diffs:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Dependencies:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   1. Actual LL Parser, that uses parsing table:</span></span><br><span class="line"><span class="comment"> *      https://gist.github.com/DmitrySoshnikov/29f7a9425cdab69ea68f</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   2. First and Follow sets construction:</span></span><br><span class="line"><span class="comment"> *      https://gist.github.com/DmitrySoshnikov/924ceefb1784b30c5ca6</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * As we implemented in diff (1), LL Parser uses a parsing table. This</span></span><br><span class="line"><span class="comment"> * table is built based on First and Follow sets which we built in</span></span><br><span class="line"><span class="comment"> * the diff (2). In this diff we finishing constructing the parsing table</span></span><br><span class="line"><span class="comment"> * based on the data from previous analysis.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The purpose of the parsing table is to tell which next production to use</span></span><br><span class="line"><span class="comment"> * based on the symbol on the stack, and the current symbol in the buffer.</span></span><br><span class="line"><span class="comment"> * As we said in (1), rows of the table are non-terminals, and columns are</span></span><br><span class="line"><span class="comment"> * terminals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Grammar:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   1. S -&gt; F</span></span><br><span class="line"><span class="comment"> *   2. S -&gt; (S + F)</span></span><br><span class="line"><span class="comment"> *   3. F -&gt; a</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parsing table:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   +------------------+</span></span><br><span class="line"><span class="comment"> *   |    (  )  a  +  $ |</span></span><br><span class="line"><span class="comment"> *   +------------------+</span></span><br><span class="line"><span class="comment"> *   | S  2  -  1  -  - |</span></span><br><span class="line"><span class="comment"> *   | F  -  -  3  -  - |</span></span><br><span class="line"><span class="comment"> *   +------------------+</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The rules for constructing the table are the following:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   1. Scan all non-terminals in the grammar, and put their derivations under</span></span><br><span class="line"><span class="comment"> *      the columns which are in the First set of the RHS for this non-terminal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   2. If this non-terminal has `ε` (epsilon, "empty" symbol) as one of its</span></span><br><span class="line"><span class="comment"> *      derivations, then put the corresponding ε-derivation into the columns</span></span><br><span class="line"><span class="comment"> *      which are in the Follow set of this non-terminal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Let's see it on the implementation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Special "empty" symbol.</span></span><br><span class="line"><span class="keyword">let</span> EPSILON = <span class="string">'ε'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given a grammar builds a LL(1) parsing table based on the</span></span><br><span class="line"><span class="comment"> * First and Follow sets of this grammar.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildParsingTable</span>(<span class="params">grammar, firstSets, followSets</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> parsingTable = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> grammar) &#123;</span><br><span class="line">        <span class="keyword">let</span> production = grammar[k];</span><br><span class="line">        <span class="keyword">let</span> LHS = getLHS(production);</span><br><span class="line">        <span class="keyword">let</span> RHS = getRHS(production);</span><br><span class="line">        <span class="keyword">let</span> productionNumber = <span class="built_in">Number</span>(k);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Init columns for this non-terminal.</span></span><br><span class="line">        <span class="keyword">if</span> (!parsingTable[LHS]) &#123;</span><br><span class="line">            parsingTable[LHS] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// All productions goes under the terminal column, if</span></span><br><span class="line">        <span class="comment">// this terminal is not epsilon.</span></span><br><span class="line">        <span class="keyword">if</span> (RHS !== EPSILON) &#123;</span><br><span class="line">            getFirstSetOfRHS(RHS, firstSets).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">terminal</span>) </span>&#123;</span><br><span class="line">                parsingTable[LHS][terminal] = productionNumber;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Otherwise, this ε-production goes under the columns from</span></span><br><span class="line">            <span class="comment">// the Follow set.</span></span><br><span class="line">            followSets[LHS].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">terminal</span>) </span>&#123;</span><br><span class="line">                parsingTable[LHS][terminal] = productionNumber;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parsingTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given production `S -&gt; F`, returns `S`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLHS</span>(<span class="params">production</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> production.split(<span class="string">'-&gt;'</span>)[<span class="number">0</span>].replace(<span class="regexp">/\s+/g</span>, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given production `S -&gt; F`, returns `F`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRHS</span>(<span class="params">production</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> production.split(<span class="string">'-&gt;'</span>)[<span class="number">1</span>].replace(<span class="regexp">/\s+/g</span>, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns First set of RHS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFirstSetOfRHS</span>(<span class="params">RHS, firstSets</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For simplicity, in this educational parser, we assume that</span></span><br><span class="line">    <span class="comment">// the first symbol (if it's a non-terminal) cannot produces `ε`.</span></span><br><span class="line">    <span class="comment">// Since in real parser, we need to get the First set of the whole RHS.</span></span><br><span class="line">    <span class="comment">// This means, that if `B` in the production `X -&gt; BC` can be `ε`, then</span></span><br><span class="line">    <span class="comment">// the First set should of course include First(C) as well, i.e. RHS[1], etc.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// That is, in a real parser, one usually combines steps of building a</span></span><br><span class="line">    <span class="comment">// parsing table, First and Follow sets in one step: when a parsing table</span></span><br><span class="line">    <span class="comment">// needs the First set of a RHS, it's calculated in place.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// But here we just return First of RHS[0].</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> firstSets[RHS[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Testing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Example 1 of a simple grammar, generates: a, or (a + a), etc.</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We just manually define our First and Follow sets for a given grammar,</span></span><br><span class="line"><span class="comment">// see again diff (2) where we automatically generated these sets.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grammar_1 = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="string">'S -&gt; F'</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">'S -&gt; (S + F)'</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">'F -&gt; a'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See https://gist.github.com/DmitrySoshnikov/924ceefb1784b30c5ca6</span></span><br><span class="line"><span class="comment">// for the sets construction.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstSets_1 = &#123;</span><br><span class="line">    <span class="string">'S'</span>: [<span class="string">'a'</span>, <span class="string">'('</span>],</span><br><span class="line">    <span class="string">'F'</span>: [<span class="string">'a'</span>],</span><br><span class="line">    <span class="string">'a'</span>: [<span class="string">'a'</span>],</span><br><span class="line">    <span class="string">'('</span>: [<span class="string">'('</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> followSets_1 = &#123;</span><br><span class="line">    <span class="string">'S'</span>: [<span class="string">'$'</span>, <span class="string">'+'</span>],</span><br><span class="line">    <span class="string">'F'</span>: [<span class="string">'$'</span>, <span class="string">'+'</span>, <span class="string">')'</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buildParsingTable(grammar_1, firstSets_1, followSets_1));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Results:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// S: &#123; a: 1, '(': 2 &#125;</span></span><br><span class="line"><span class="comment">// F: &#123; a: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// That corresponds to the following table:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +------------------+</span></span><br><span class="line"><span class="comment">// |    (  )  a  +  $ |</span></span><br><span class="line"><span class="comment">// +------------------+</span></span><br><span class="line"><span class="comment">// | S  2  -  1  -  - |</span></span><br><span class="line"><span class="comment">// | F  -  -  3  -  - |</span></span><br><span class="line"><span class="comment">// +------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Example 2, for the "calculator" grammar, e.g. (a + a) * a.</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grammar_2 = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="string">'E -&gt; TX'</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">'X -&gt; +TX'</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="string">'X -&gt; ε'</span>,</span><br><span class="line">    <span class="number">4</span>: <span class="string">'T -&gt; FY'</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">'Y -&gt; *FY'</span>,</span><br><span class="line">    <span class="number">6</span>: <span class="string">'Y -&gt; ε'</span>,</span><br><span class="line">    <span class="number">7</span>: <span class="string">'F -&gt; a'</span>,</span><br><span class="line">    <span class="number">8</span>: <span class="string">'F -&gt; (E)'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See https://gist.github.com/DmitrySoshnikov/924ceefb1784b30c5ca6</span></span><br><span class="line"><span class="comment">// for the sets construction.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstSets_2 = &#123;</span><br><span class="line">    <span class="string">'E'</span>: [<span class="string">'a'</span>, <span class="string">'('</span>],</span><br><span class="line">    <span class="string">'T'</span>: [<span class="string">'a'</span>, <span class="string">'('</span>],</span><br><span class="line">    <span class="string">'F'</span>: [<span class="string">'a'</span>, <span class="string">'('</span>],</span><br><span class="line">    <span class="string">'a'</span>: [<span class="string">'a'</span>],</span><br><span class="line">    <span class="string">'('</span>: [<span class="string">'('</span>],</span><br><span class="line">    <span class="string">'X'</span>: [<span class="string">'+'</span>, <span class="string">'ε'</span>],</span><br><span class="line">    <span class="string">'+'</span>: [<span class="string">'+'</span>],</span><br><span class="line">    <span class="string">'Y'</span>: [<span class="string">'*'</span>, <span class="string">'ε'</span>],</span><br><span class="line">    <span class="string">'*'</span>: [<span class="string">'*'</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> followSets_2 = &#123;</span><br><span class="line">    <span class="string">'E'</span>: [<span class="string">'$'</span>, <span class="string">')'</span>],</span><br><span class="line">    <span class="string">'X'</span>: [<span class="string">'$'</span>, <span class="string">')'</span>],</span><br><span class="line">    <span class="string">'T'</span>: [<span class="string">'+'</span>, <span class="string">'$'</span>, <span class="string">')'</span>],</span><br><span class="line">    <span class="string">'Y'</span>: [<span class="string">'+'</span>, <span class="string">'$'</span>, <span class="string">')'</span>],</span><br><span class="line">    <span class="string">'F'</span>: [<span class="string">'*'</span>, <span class="string">'+'</span>, <span class="string">'$'</span>, <span class="string">')'</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buildParsingTable(grammar_2,firstSets_2,followSets_2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Results:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// E: &#123; a: 1, '(': 1 &#125;,</span></span><br><span class="line"><span class="comment">// X: &#123; '+': 2, '$': 3, ')': 3 &#125;,</span></span><br><span class="line"><span class="comment">// T: &#123; a: 4, '(': 4 &#125;,</span></span><br><span class="line"><span class="comment">// Y: &#123; '*': 5, '+': 6, '$': 6, ')': 6 &#125;,</span></span><br><span class="line"><span class="comment">// F: &#123; a: 7, '(': 8 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// That corresponds to the following table:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// +---------------------+</span></span><br><span class="line"><span class="comment">// |    a  +  *  (  )  $ |</span></span><br><span class="line"><span class="comment">// +---------------------+</span></span><br><span class="line"><span class="comment">// | E  1  -  -  1  -  - |</span></span><br><span class="line"><span class="comment">// | X  -  2  -  -  3  3 |</span></span><br><span class="line"><span class="comment">// | T  4  -  -  4  -  - |</span></span><br><span class="line"><span class="comment">// | Y  -  6  5  -  6  6 |</span></span><br><span class="line"><span class="comment">// | F  7  -  -  8  -  - |</span></span><br><span class="line"><span class="comment">// +---------------------+</span></span><br></pre></td></tr></table></figure><h3 id="4-Reference"><a href="#4-Reference" class="headerlink" title="4 Reference"></a>4 Reference</h3><p><a href="https://en.wikipedia.org/wiki/Parse_table" title="parsing table" target="_blank" rel="noopener">parsing table</a><br><a href="chrome-extension://cdonnmffkdaoajfknoeeecmchibpmkmg/static/pdf/web/viewer.html?file=http%3A%2F%2Fwww.yorku.ca%2Fwalker%2Fmath2320%2FDijkstra.pdf" title="Dijikstra’s Algorithm" target="_blank" rel="noopener">Dijikstra’s Algorithm</a><br><a href="https://gist.github.com/DmitrySoshnikov/644383a86b045a3a8ad3" title="DmitrySoshnikov blog" target="_blank" rel="noopener">DmitrySoshnikov gitst</a></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> parser </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从零开始的编译原理之旅----Parser篇(一)</title>
      <link href="/2018/09/03/parser_01/"/>
      <url>/2018/09/03/parser_01/</url>
      
        <content type="html"><![CDATA[<h3 id="1-目录"><a href="#1-目录" class="headerlink" title="1 目录"></a>1 目录</h3><p>本系列旨在学习各种parser思路及技巧，分为以下几个部分</p><ol start="0"><li><a href="https://belyenochi.github.io/2018/08/28/parser_00/#more" target="_blank" rel="noopener"> 清晨入古寺—-论世间parser为何物</a></li><li><a href="https://belyenochi.github.io/2018/09/03/parser_01/#more" target="_blank" rel="noopener"> 初日照高林—-初探First集，Follow集 <strong>[本篇]</strong></a></li><li><a href="https://belyenochi.github.io/2018/09/04/parser_02/#more" target="_blank" rel="noopener"> 曲径通幽处—-预测分析表的构建 </a></li><li><a href="https://belyenochi.github.io/2018/09/04/parser_06/#more" target="_blank" rel="noopener"> 禅房花木深—-实现LL(1) parser </a></li><li><a href="https://belyenochi.github.io/2018/09/04/parser_06/#more" target="_blank" rel="noopener"> 山光悦鸟性—-递归下降的两种实现 </a></li><li>潭影空人心—-浅谈recursive ascent parser(SLR,LALR(1))</li><li>万籁此俱寂—-parser combinator（从ohm.js源码说起）</li><li>但余钟磬音—-反思与总结</li></ol><h3 id="1-何谓First集，何谓Follow集合"><a href="#1-何谓First集，何谓Follow集合" class="headerlink" title="1 何谓First集，何谓Follow集合"></a>1 何谓First集，何谓Follow集合</h3><p>所谓First集就是你在根据非终结符推导产生式的依据，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S -&gt; aAb</span><br><span class="line">A -&gt; a | &lt;epsilon&gt;</span><br></pre></td></tr></table></figure></p><p>在分析S这个非终结符的时候，判断进入S产生式就需要查看S产生式的第一个字符是否与输入字符串匹配，像上面例子中每个产生式可以从左往右推导，并且只需要一个前看字符就可以判断进入哪个产生式，我们就说它是LL（1）文法,实际上first集是递归下降分析过程中使用的一种技术，通过对前看字符的预测分析（predicitive parsing）可以消除对非终结符解析的二义性，那么为啥还需要follow集呢，答案是可能存在相同的First集，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S -&gt; aEb</span><br><span class="line">E -&gt; &apos;a&apos; | ε</span><br></pre></td></tr></table></figure></p><p>加入我们要解析字符串”ab”，从S（Start）开始，a（匹配），E（匹配中），咦，E的First集没有产生式为终结符’b’啊，难道我就要抛出一个解析失败的异常吗？兄弟别急，如果非终结符的产生式包含了ε，那么这时候就要查看Follow(E),此处的Follow(E) = {b},这时文法解析器看到b match follow(E)就安心的在E这个终结符处选择了ε这个产生式，接着S的产生式匹配b，整个字符串匹配成功：）。</p><p>这里有同学可能会好奇为啥平白无故的我定义一个非终结符E生成产生式ε呢？<br>我们来看看上面的文法没有使用ε（表示空）定义的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S -&gt; Sb</span><br></pre></td></tr></table></figure></p><p>总结一下First集和Follow集的使用：<br>First集用来做分支预测，follow集用来出来非终结符中含有ε（空）的情况。<br>对与LL（1）文法一种简单有效的解析手法是使用递归下降，所谓的递归下降就是将每一个非终结符对应一个解析函数。举个栗子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">S</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">eat(<span class="string">'a'</span>)</span><br><span class="line">E()</span><br><span class="line">eat(<span class="string">'b'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">E</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(First(<span class="string">'a'</span>).indexOf(input) !== <span class="number">-1</span>) &#123;</span><br><span class="line">eat(<span class="string">'a'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (Follow(E).indexOf(input) !== <span class="number">-1</span>) &#123;</span><br><span class="line">eat(<span class="string">'ε'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很简单粗暴，如果你没有ε代码就会写成这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">S</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">S()</span><br><span class="line">eat(<span class="string">'b'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是左递归，调用栈很快就满了不是，所以我们要消除左递归就引入了ε</p><h3 id="2-如何构造First集，Follow集合"><a href="#2-如何构造First集，Follow集合" class="headerlink" title="2 如何构造First集，Follow集合"></a>2 如何构造First集，Follow集合</h3><h4 id="2-1-first集的构造"><a href="#2-1-first集的构造" class="headerlink" title="2.1 first集的构造"></a>2.1 first集的构造</h4><ul><li>If X is a terminal then First(X) is just X!</li><li>If there is a Production X → ε then add ε to first(X)</li><li>If there is a Production X → Y1Y2..Yk then add first(Y1Y2..Yk) to first(X)</li><li>First(Y1Y2..Yk) is either<ul><li>First(Y1) (if First(Y1) doesn’t contain ε)</li><li>OR (if First(Y1) does contain ε) then First (Y1Y2..Yk) is everything in First(Y1) <except for="" ε=""> as well as everything in First(Y2..Yk)</except></li><li>If First(Y1) First(Y2)..First(Yk) all contain ε then add ε<br>to First(Y1Y2..Yk) as well.</li></ul></li></ul><h4 id="2-2-follow集的构造"><a href="#2-2-follow集的构造" class="headerlink" title="2.2 follow集的构造"></a>2.2 follow集的构造</h4><ul><li>First put $ (the end of input marker) in Follow(S) (S is the start symbol)</li><li>If there is a production A → aBb, (where a can be a whole string) then everything in FIRST(b) except for ε is placed in FOLLOW(B).</li><li>If there is a production A → aB, then everything in FOLLOW(A) is in FOLLOW(B)</li><li>If there is a production A → aBb, where FIRST(b) contains ε, then everything in FOLLOW(A) is in FOLLOW(B)</li></ul><h4 id="2-3实例讲解"><a href="#2-3实例讲解" class="headerlink" title="2.3实例讲解"></a>2.3实例讲解</h4><p>首先定义一组Grammar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">The Grammar</span><br><span class="line"></span><br><span class="line">E → TE&apos;</span><br><span class="line"></span><br><span class="line">E&apos; → +TE&apos;</span><br><span class="line"></span><br><span class="line">E&apos; → ε</span><br><span class="line"></span><br><span class="line">T → FT&apos;</span><br><span class="line"></span><br><span class="line">T&apos; → *FT&apos;</span><br><span class="line"></span><br><span class="line">T&apos; → ε</span><br><span class="line"></span><br><span class="line">F → (E)</span><br><span class="line"></span><br><span class="line">F → id</span><br></pre></td></tr></table></figure><p><img src="/images/parser_01/1.png" alt=""><br><img src="/images/parser_01/2.png" alt=""><br><img src="/images/parser_01/3.png" alt=""></p><p><font color="red">以下为对first集合和follow集求解的代码实现</font><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Special "empty" symbol.</span></span><br><span class="line"><span class="keyword">let</span> EPSILON = <span class="string">"ε"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rules for First Sets</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - If X is a terminal then First(X) is just X!</span></span><br><span class="line"><span class="comment"> * - If there is a Production X → ε then add ε to first(X)</span></span><br><span class="line"><span class="comment"> * - If there is a Production X → Y1Y2..Yk then add first(Y1Y2..Yk) to first(X)</span></span><br><span class="line"><span class="comment"> * - First(Y1Y2..Yk) is either</span></span><br><span class="line"><span class="comment"> *     - First(Y1) (if First(Y1) doesn't contain ε)</span></span><br><span class="line"><span class="comment"> *     - OR (if First(Y1) does contain ε) then First (Y1Y2..Yk) is everything</span></span><br><span class="line"><span class="comment"> *       in First(Y1) &lt;except for ε &gt; as well as everything in First(Y2..Yk)</span></span><br><span class="line"><span class="comment"> *     - If First(Y1) First(Y2)..First(Yk) all contain ε then add ε</span></span><br><span class="line"><span class="comment"> *       to First(Y1Y2..Yk) as well.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildFirstSets</span>(<span class="params">grammar, Sets</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> buildSet(firstOf, grammar, Sets, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstOf</span>(<span class="params">symbol, firstSets</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A set may already be built from some previous analysis</span></span><br><span class="line">  <span class="comment">// of a RHS, so check whether it's already there and don't rebuild.</span></span><br><span class="line">  <span class="keyword">if</span> (firstSets[symbol]) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstSets[symbol];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Else init and calculate.</span></span><br><span class="line">  <span class="keyword">let</span> first = firstSets[symbol] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If it's a terminal, its first set is just itself.</span></span><br><span class="line">  <span class="keyword">if</span> (isTerminal(symbol)) &#123;</span><br><span class="line">    first[symbol] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> firstSets[symbol];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> productionsForSymbol = getProductionsForSymbol(symbol,grammar);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> productionsForSymbol) &#123;</span><br><span class="line">    <span class="keyword">let</span> production = getRHS(productionsForSymbol[k]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; production.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> productionSymbol = production[i];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Epsilon goes to the first set.</span></span><br><span class="line">      <span class="keyword">if</span> (productionSymbol === EPSILON) &#123;</span><br><span class="line">        first[EPSILON] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Else, the first is a non-terminal,</span></span><br><span class="line">      <span class="comment">// then first of it goes to first of our symbol</span></span><br><span class="line">      <span class="comment">// (unless it's an epsilon).</span></span><br><span class="line">      <span class="keyword">let</span> firstOfNonTerminal = firstOf(productionSymbol, firstSets);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If first non-terminal of the RHS production doesn't</span></span><br><span class="line">      <span class="comment">// contain epsilon, then just merge its set with ours.</span></span><br><span class="line">      <span class="keyword">if</span> (!firstOfNonTerminal[EPSILON]) &#123;</span><br><span class="line">        merge(first, firstOfNonTerminal);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Else (we got epsilon in the first non-terminal),</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//   - merge all except for epsilon</span></span><br><span class="line">      <span class="comment">//   - eliminate this non-terminal and advance to the next symbol</span></span><br><span class="line">      <span class="comment">//     (i.e. don't break this loop)</span></span><br><span class="line">      merge(first, firstOfNonTerminal, [EPSILON]);</span><br><span class="line">      <span class="comment">// don't break, go to the next `productionSymbol`.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * We have the following data structure for our grammars:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * let grammar = &#123;</span></span><br><span class="line"><span class="comment"> *   1: 'S -&gt; F',</span></span><br><span class="line"><span class="comment"> *   2: 'S -&gt; (S + F)',</span></span><br><span class="line"><span class="comment"> *   3: 'F -&gt; a',</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given symbol `S`, the function returns `S -&gt; F`,</span></span><br><span class="line"><span class="comment"> * and `S -&gt; (S + F)` productions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProductionsForSymbol</span>(<span class="params">symbol,grammar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> productionsForSymbol = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> grammar) &#123;</span><br><span class="line">    <span class="keyword">if</span> (grammar[k][<span class="number">0</span>] === symbol) &#123;</span><br><span class="line">      productionsForSymbol[k] = grammar[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> productionsForSymbol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given production `S -&gt; F`, returns `S`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLHS</span>(<span class="params">production</span>) </span>&#123;</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">function getLHS(production) &#123;</span></span><br><span class="line"><span class="regexp">function getLHS(production) &#123;</span></span><br><span class="line"><span class="regexp">  return production.split('-&gt;')[0].replace(/</span>\s+<span class="regexp">/g, '');</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * Given production <span class="string">`S -&gt; F`</span>, returns <span class="string">`F`</span>.</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">function getRHS(production) &#123;</span></span><br><span class="line"><span class="regexp">  return production.split('-&gt;')[1].replace(/</span>\s+<span class="regexp">/g, '');</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * Rules <span class="keyword">for</span> Follow Sets</span><br><span class="line"> *</span><br><span class="line"> * - First put $ (the end <span class="keyword">of</span> input marker) <span class="keyword">in</span> Follow(S) (S is the start symbol)</span><br><span class="line"> * - If there is a production A → aBb, (where a can be a whole string)</span><br><span class="line"> *   then everything <span class="keyword">in</span> FIRST(b) except <span class="keyword">for</span> ε is placed <span class="keyword">in</span> FOLLOW(B).</span><br><span class="line"> * - If there is a production A → aB, then everything <span class="keyword">in</span></span><br><span class="line"> *   FOLLOW(A) is <span class="keyword">in</span> FOLLOW(B)</span><br><span class="line"> * - If there is a production A → aBb, where FIRST(b) contains ε,</span><br><span class="line"> *   then everything <span class="keyword">in</span> FOLLOW(A) is <span class="keyword">in</span> FOLLOW(B)</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function buildFollowSets(grammar, Sets) &#123;</span></span><br><span class="line"><span class="regexp">  return buildSet(followOf,grammar, Sets, 1);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function followOf(symbol, firstSets, followSets) &#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ If was already calculated from some previous run.</span></span><br><span class="line"><span class="regexp">  if (followSets[symbol]) &#123;</span></span><br><span class="line"><span class="regexp">    return followSets[symbol];</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ Else init and calculate.</span></span><br><span class="line"><span class="regexp">  let follow = followSets[symbol] = &#123;&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ Start symbol always contain `$` in its follow set.</span></span><br><span class="line"><span class="regexp">  if (symbol === START_SYMBOL) &#123;</span></span><br><span class="line"><span class="regexp">    follow['$'] = true;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ We need to analyze all productions where our</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ symbol is used (i.e. where it appears on RHS).</span></span><br><span class="line"><span class="regexp">  let productionsWithSymbol = getProductionsWithSymbol(symbol);</span></span><br><span class="line"><span class="regexp">  for (let k in productionsWithSymbol) &#123;</span></span><br><span class="line"><span class="regexp">    let production = productionsWithSymbol[k];</span></span><br><span class="line"><span class="regexp">    let RHS = getRHS(production);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ Get the follow symbol of our symbol.</span></span><br><span class="line"><span class="regexp">    let symbolIndex = RHS.indexOf(symbol);</span></span><br><span class="line"><span class="regexp">    let followIndex = symbolIndex + 1;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ We need to get the following symbol, which can be `$` or</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ may contain epsilon in its first set. If it contains epsilon, then</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ we should take the next following symbol: `A -&gt; aBCD`: if `C` (the</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ follow of `B`) can be epsilon, we should consider first of `D` as well</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ as the follow of `B`.</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    while (true) &#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      if (followIndex === RHS.length) &#123; /</span><span class="regexp">/ "$"</span></span><br><span class="line"><span class="regexp">        let LHS = getLHS(production);</span></span><br><span class="line"><span class="regexp">        if (LHS !== symbol) &#123; /</span><span class="regexp">/ To avoid cases like: B -&gt; aB</span></span><br><span class="line"><span class="regexp">          merge(follow, followOf(LHS, followSets, firstSets));</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        break;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      let followSymbol = RHS[followIndex];</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ Follow of our symbol is anything in the first of the following symbol:</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ followOf(symbol) is firstOf(followSymbol), except for epsilon.</span></span><br><span class="line"><span class="regexp">      let firstOfFollow = firstOf(followSymbol, firstSets);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ If there is no epsilon, just merge.</span></span><br><span class="line"><span class="regexp">      if (!firstOfFollow[EPSILON]) &#123;</span></span><br><span class="line"><span class="regexp">        merge(follow, firstOfFollow);</span></span><br><span class="line"><span class="regexp">        break;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      merge(follow, firstOfFollow, [EPSILON]);</span></span><br><span class="line"><span class="regexp">      followIndex++;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  return follow;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function buildSet(builder, grammar, Sets, index) &#123;</span></span><br><span class="line"><span class="regexp">  for (let k in grammar) &#123;</span></span><br><span class="line"><span class="regexp">    builder(grammar[k][0], ...Sets);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 0 stand for first Set 1 stands for follow Set</span></span><br><span class="line"><span class="regexp">  return Sets[index];</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span>**</span><br><span class="line"> * Finds productions where a non-terminal is used. E.g., <span class="keyword">for</span> the</span><br><span class="line"> * symbol <span class="string">`S`</span> it finds production <span class="string">`(S + F)`</span>, and <span class="keyword">for</span> the symbol <span class="string">`F`</span></span><br><span class="line"> * it finds productions <span class="string">`F`</span> and <span class="string">`(S + F)`</span>.</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">function getProductionsWithSymbol(symbol) &#123;</span></span><br><span class="line"><span class="regexp">  let productionsWithSymbol = &#123;&#125;;</span></span><br><span class="line"><span class="regexp">  for (let k in grammar) &#123;</span></span><br><span class="line"><span class="regexp">    let production = grammar[k];</span></span><br><span class="line"><span class="regexp">    let RHS = getRHS(production);</span></span><br><span class="line"><span class="regexp">    if (RHS.indexOf(symbol) !== -1) &#123;</span></span><br><span class="line"><span class="regexp">      productionsWithSymbol[k] = production;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  return productionsWithSymbol;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function isTerminal(symbol) &#123;</span></span><br><span class="line"><span class="regexp">  return !/</span>[A-Z]/.test(symbol);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">to, from, exclude</span>) </span>&#123;</span><br><span class="line">  exclude || (exclude = []);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> <span class="keyword">from</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (exclude.indexOf(k) === <span class="number">-1</span>) &#123;</span><br><span class="line">      to[k] = <span class="keyword">from</span>[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printGrammar</span>(<span class="params">grammar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Grammar:\n'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> grammar) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'  '</span>, grammar[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSet</span>(<span class="params">name, set</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name + <span class="string">': \n'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> set) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'  '</span>, k, <span class="string">':'</span>, <span class="built_in">Object</span>.keys(set[k]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Testing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Example 1 of a simple grammar, generates: a, or (a + a), etc.</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grammar = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">'S -&gt; F'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'S -&gt; (S + F)'</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">'F -&gt; a'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> START_SYMBOL = <span class="string">'S'</span>;</span><br><span class="line"></span><br><span class="line">printGrammar(grammar);</span><br><span class="line"></span><br><span class="line">printSet(<span class="string">'First sets'</span>, buildFirstSets(grammar, [&#123;&#125;]));</span><br><span class="line"></span><br><span class="line">printSet(<span class="string">'Follow sets'</span>, buildFollowSets(grammar, [buildFirstSets(grammar, [&#123;&#125;]),&#123;&#125;]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Results:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Grammar:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    S -&gt; F</span></span><br><span class="line"><span class="comment">//    S -&gt; (S + F)</span></span><br><span class="line"><span class="comment">//    F -&gt; a</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// First sets:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    S : [ 'a', '(' ]</span></span><br><span class="line"><span class="comment">//    F : [ 'a' ]</span></span><br><span class="line"><span class="comment">//    a : [ 'a' ]</span></span><br><span class="line"><span class="comment">//    ( : [ '(' ]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Follow sets:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    S : [ '$', '+' ]</span></span><br><span class="line"><span class="comment">//    F : [ '$', '+', ')' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Example 2 of a "calculator" grammar (with removed left recursion, which</span></span><br><span class="line"><span class="comment">// is replaced with a right recursion and epsilons), it generates language</span></span><br><span class="line"><span class="comment">// for e.g. (a + a) * a.</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grammar = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">'E -&gt; TX'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'X -&gt; +TX'</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">'X -&gt; ε'</span>,</span><br><span class="line">  <span class="number">4</span>: <span class="string">'T -&gt; FY'</span>,</span><br><span class="line">  <span class="number">5</span>: <span class="string">'Y -&gt; *FY'</span>,</span><br><span class="line">  <span class="number">6</span>: <span class="string">'Y -&gt; ε'</span>,</span><br><span class="line">  <span class="number">7</span>: <span class="string">'F -&gt; a'</span>,</span><br><span class="line">  <span class="number">8</span>: <span class="string">'F -&gt; (E)'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> START_SYMBOL = <span class="string">'E'</span>;</span><br><span class="line"></span><br><span class="line">printGrammar(grammar);</span><br><span class="line"></span><br><span class="line">printSet(<span class="string">'First sets'</span>, buildFirstSets(grammar, [&#123;&#125;]));</span><br><span class="line"></span><br><span class="line">printSet(<span class="string">'Follow sets'</span>, buildFollowSets(grammar, [buildFirstSets(grammar, [&#123;&#125;]),&#123;&#125;]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Results:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Grammar:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    E -&gt; TX</span></span><br><span class="line"><span class="comment">//    X -&gt; +TX</span></span><br><span class="line"><span class="comment">//    X -&gt; ε</span></span><br><span class="line"><span class="comment">//    T -&gt; FY</span></span><br><span class="line"><span class="comment">//    Y -&gt; *FY</span></span><br><span class="line"><span class="comment">//    Y -&gt; ε</span></span><br><span class="line"><span class="comment">//    F -&gt; a</span></span><br><span class="line"><span class="comment">//    F -&gt; (E)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// First sets:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    E : [ 'a', '(' ]</span></span><br><span class="line"><span class="comment">//    T : [ 'a', '(' ]</span></span><br><span class="line"><span class="comment">//    F : [ 'a', '(' ]</span></span><br><span class="line"><span class="comment">//    a : [ 'a' ]</span></span><br><span class="line"><span class="comment">//    ( : [ '(' ]</span></span><br><span class="line"><span class="comment">//    X : [ '+', 'ε' ]</span></span><br><span class="line"><span class="comment">//    + : [ '+' ]</span></span><br><span class="line"><span class="comment">//    Y : [ '*', 'ε' ]</span></span><br><span class="line"><span class="comment">//    * : [ '*' ]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Follow sets:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    E : [ '$', ')' ]</span></span><br><span class="line"><span class="comment">//    X : [ '$', ')' ]</span></span><br><span class="line"><span class="comment">//    T : [ '+', '$', ')' ]</span></span><br><span class="line"><span class="comment">//    Y : [ '+', '$', ')' ]</span></span><br><span class="line"><span class="comment">//    F : [ '*', '+', '$', ')' ]</span></span><br></pre></td></tr></table></figure></p><p>代码部分参考了<a href="https://github.com/DmitrySoshnikov" title="DmitrySoshnikov" target="_blank" rel="noopener">DmitrySoshnikov</a>的parser</p><h3 id="3-Reference"><a href="#3-Reference" class="headerlink" title="3 Reference"></a>3 Reference</h3><p><a href="compiler-design-first-in-syntax-analysis" title="https://www.geeksforgeeks.org/compiler-design-first-in-syntax-analysis/">compiler-design-first-in-syntax-analysis</a><br><a href="compiler-design-why-first-and-follow" title="https://www.geeksforgeeks.org/compiler-design-why-first-and-follow/">compiler-design-why-first-and-follow</a></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> parser </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算的要素第十二章总结</title>
      <link href="/2018/09/01/jsys_12_summary/"/>
      <url>/2018/09/01/jsys_12_summary/</url>
      
        <content type="html"><![CDATA[<p>本章是针对Hack OS各个模块的概述及其实现，其中某几个模块实现的算法很有意思，让我们马上开始吧~</p><h3 id="1-什么是OS（以Hack-OS为例）"><a href="#1-什么是OS（以Hack-OS为例）" class="headerlink" title="1 什么是OS（以Hack OS为例）"></a>1 什么是OS（以Hack OS为例）</h3><ol><li>以一种对软件友好的方式封装了不同的硬件服务</li><li>用不同的函数和抽象数据类型扩展了高级语言。在这个意义上的操作系统与语言的标准程序库的分界线就不那么明显。事实上，某些现代语言（例如Java）就趋向于将很多经典的操作系统服务（比如GUI管理，内存管理，和多任务处理等）连同很多语言拓展一起打包到其标准程序库中，这么做的目的以我的理解是为了屏蔽系统层面的差异（比如C的fopen等）以及减少系统调用（比如Java的内存管理，向内存申请一大片空间，Java NIO等）</li></ol><h3 id="2-为什么我们需要OS"><a href="#2-为什么我们需要OS" class="headerlink" title="2 为什么我们需要OS"></a>2 为什么我们需要OS</h3><p>计算机是用来解决实际问题的，所以我们构建计算机硬件用来计算，基于硬件我们造了编译器用来写更可读的汇编程序，然后有了用汇编程序写的应用，随着应用程序越来越到，我们需要抽象出能够将控制（硬件和外围设备以及软件）和分配资源的常用功能集一体的概念，它就是Operating System，感兴趣的同学可以看看操作系统的演化。（有时间去研究研究发出来）<br>计算机系统的基本目标是执行用户程序并以更容易的方式解决用户的问题。</p><h3 id="3-数学操作"><a href="#3-数学操作" class="headerlink" title="3 数学操作"></a>3 数学操作</h3><p>首先，这里明确的告诉了我下意识想到的通过累加和累减来实现乘除法来操作系统层面是不可行的，原因很简单，效率太低了高达O（n）的输入敏感复杂度会让计算一个100000000000000*10000000000000的人在凳子上坐上几天（只是举个例子，数据不具备代表性），那么就让我们来看一看Hack OS的做法</p><font color="red">注：以下所有运算都假定操作数为16位（Hacl硬件规范字长16位）</font><h4 id="3-1-乘法"><a href="#3-1-乘法" class="headerlink" title="3.1 乘法"></a>3.1 乘法</h4><p><img src="/images/jsys_12/乘法.jpg" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>,index = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y.toString(<span class="number">2</span>).padStart(<span class="number">16</span>,<span class="string">"0"</span>).charAt(index) !== <span class="string">"0"</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(y, index,y.toString(<span class="number">2</span>).padStart(<span class="number">16</span>,<span class="string">"0"</span>));</span><br><span class="line">             sum = sum + x;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x + x;</span><br><span class="line">       index = index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实际上乘法就是在模拟我们日常生活中的乘法，通过逐位相乘，并且再每一次乘完以后将被乘数左移一位，迭代这个过程直到遍历完所有位数，在日常生活中我们看到某个算术53*20，当我们处理完5这一位不会再用0去乘20，但是在计算机中你需要一套规则去运算，这套规则在这里就是遍历完操作数的所有位，即便它全是0。</p><h4 id="3-2-除法"><a href="#3-2-除法" class="headerlink" title="3.2 除法"></a>3.2 除法</h4><p><img src="/images/jsys_12/除法.jpg" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> q,result,flag;</span><br><span class="line"></span><br><span class="line">    flag = !((x &lt; <span class="number">0</span>) ^ (y &lt; <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    x = <span class="built_in">Math</span>.abs(x);</span><br><span class="line">    y = <span class="built_in">Math</span>.abs(y);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q = divide(x,y + y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x - (<span class="number">2</span> * q * y) &lt; y) &#123;</span><br><span class="line">        result = q + q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = q + q + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flag ? result : -result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路也是模仿人除法的过程，选择一个尽可能从x上减去y的最大倍数（假定算式x/y），直到y比x大，这个过程的递归形式如上。</p><h4 id="3-3-平方根"><a href="#3-3-平方根" class="headerlink" title="3.3 平方根"></a>3.3 平方根</h4><p><img src="/images/jsys_12/二叉树.jpg" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sqrt</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y,j,temp,tempQ;</span><br><span class="line"></span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    j = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">      temp = y + <span class="built_in">Math</span>.pow(<span class="number">2</span>,j);</span><br><span class="line">      tempQ = temp * temp;</span><br><span class="line">      <span class="comment">//avoid overflow</span></span><br><span class="line">      <span class="keyword">if</span>((tempQ &lt;= x) &amp; (tempQ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">        y = temp;</span><br><span class="line">      &#125;</span><br><span class="line">      j = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法就是根据y²&lt;= x &lt;(y+1)²，使得y从0开始逐步逼近x使得y满足上述区间</p><h3 id="4-内存管理"><a href="#4-内存管理" class="headerlink" title="4 内存管理"></a>4 内存管理</h3><p>内存管理很有趣，首先说一说内存管理的背景</p><h4 id="4-1-背景"><a href="#4-1-背景" class="headerlink" title="4.1 背景"></a>4.1 背景</h4><p>计算机的程序会声明并使用各种类型的变量，包括整数、布尔数等简单的数据类型以及如数组、对象等复杂的数据类型。高级语言的最大优点之一是程序员不必关心内存管理细节：比如为变量分配内存空间；以及当该变量不再使用时，回收为其分配的内存空间。所有关于内存管理的琐碎工作都由编译器、操作系统和虚拟机在后端完成。<br>不同的变量的内存在程序生命周期中的不同时刻被分配。例如，<strong>静态变量</strong>在编译期间由编译器为其分配内存，而<strong>局部变量</strong>则在每个子程序开始运行时被分配在堆栈内。其他变量的内存则是在程序的执行过程中被动态分配，这时候OS就要上了。<font color="red">注意操作系统本身并不自带垃圾回收功能，这是高级语言提供的内存管理手段，比如Java，JVM先向OS请求一大块内存用于程序运行，然后在这块内存中可以“自动内存管理”，本质是在OS层面之上进行内存管理，这样就不用频繁的调用系统的malloc，free了</font></p><p>在OS看来内存其实就是一块大数组（big buffer），当然真实的内存实现我们已经在之前看到过了(多个Register-&gt;多个RAM-&gt;Memory)。</p><h4 id="4-2-内存管理算法"><a href="#4-2-内存管理算法" class="headerlink" title="4.2 内存管理算法"></a>4.2 内存管理算法</h4><h5 id="4-2-1-alloc"><a href="#4-2-1-alloc" class="headerlink" title="4.2.1 alloc"></a>4.2.1 alloc</h5><p><img src="/images/jsys_12/malloc.jpg" alt=""><br>上图的freeList的节点乍看可能有点疑惑，其实这里的freeList是经历过deAlloc的，一开是freeList只有一个节点就是整块内存区，然后随着alloc-deAlloc，链表节点逐渐增多，碎片化也越来越严重…</p><h5 id="4-2-2-deAlloc"><a href="#4-2-2-deAlloc" class="headerlink" title="4.2.2 deAlloc"></a>4.2.2 deAlloc</h5><p><img src="/images/jsys_12/delloc.jpg" alt=""><br>deAlloc的算法其实可以总结如下：<br>假设待释放节点值为o</p><ol><li>找到freeList中节点的地址值比待释放节点值大的节点（A）</li><li>将待释放的节点的next域设为A的地址<br>3.将A的上一个节点的next域设为o</li></ol><p>然而我刚开始的做法是：</p><ol><li>将o的next域设为freeList指向的节点</li><li>修改freeList指向o的地址（这和上图Mark的做法有点出路，个人觉得这样头插效率比根据Address来的高且简单）<br>当然我所谓的优于，是建立在没有合并的基础上的…</li></ol><h5 id="4-2-3-defragmentation（碎片合并）"><a href="#4-2-3-defragmentation（碎片合并）" class="headerlink" title="4.2.3 defragmentation（碎片合并）"></a>4.2.3 defragmentation（碎片合并）</h5><p>细心的读者已经发现了，上图中还包含这碎片合并的动作，这个碎片合并的动作如果链表不是根据address有序的话复杂度是O（n²）级别的，这带来的直接后果就是，咦，为什么我的程序关的这么慢。。。所以我们在deAlloc的时候要用第一个算法的原因就是如此。</p><p>defragmentation算法如下：<br>1.遍历链表<br>2.如果当前节点的地址值+size+1（存储size的存储单元） = 下一个节点的地址，merge</p><h3 id="5-输入输出管理"><a href="#5-输入输出管理" class="headerlink" title="5 输入输出管理"></a>5 输入输出管理</h3><p>这部分我就说两个比较有意思的地方</p><h4 id="5-1-输出"><a href="#5-1-输出" class="headerlink" title="5.1 输出"></a>5.1 输出</h4><h5 id="5-1-1-绘制三角形"><a href="#5-1-1-绘制三角形" class="headerlink" title="5.1.1 绘制三角形"></a>5.1.1 绘制三角形</h5><p><img src="/images/jsys_12/sanjiao.jpg" alt=""><br>这里说绘制三角形，不如说如何模拟三角形，实际上我们画出的三角形是以堆砌一个个像素形成的，可以把像素看出3*1的正方形，而绘制三角形的过程，就是如何堆砌正方形让它更像三角形，下面是过程图示<br><img src="/images/jsys_12/sanjiaoxing.png" alt=""></p><p><strong>图中最关键的一点在于    当前的坐标斜率&lt;=(y2-y1)/(x2-x1),a++，否则b++</strong></p><h5 id="5-1-2-绘制圆"><a href="#5-1-2-绘制圆" class="headerlink" title="5.1.2 绘制圆"></a>5.1.2 绘制圆</h5><p><img src="/images/jsys_12/circle.jpg" alt=""><br>绘制圆的本质就是绘制一系列的矩形，算法如上</p><h4 id="5-2-输入"><a href="#5-2-输入" class="headerlink" title="5.2 输入"></a>5.2 输入</h4><p>这一部分主要描述操作系统如何在三个递增的抽象层级上来管理面向文本的输入：</p><ol><li>捕获单字符输入</li><li>捕获多字符输入</li><li>捕获多字符输入（也就是字符串）</li></ol><h5 id="5-2-1-侦测键盘输入"><a href="#5-2-1-侦测键盘输入" class="headerlink" title="5.2.1 侦测键盘输入"></a>5.2.1 侦测键盘输入</h5><p><img src="/images/jsys_12/keyboard.jpg" alt=""><br>在底层捕获键盘输入时，程序直接从硬件获取数据，并确定用户当前按下哪个键。对该原始数据的访问依赖于键盘接口的具体特性。比如，若接口是被键盘持续更新的内存映像（比如Hack），就可以通过检测对应的内存映像来确定按下了哪个键</p><h5 id="5-2-2-读取单一字符"><a href="#5-2-2-读取单一字符" class="headerlink" title="5.2.2 读取单一字符"></a>5.2.2 读取单一字符</h5><p><img src="/images/jsys_12/readchar.jpg" alt=""></p><h5 id="5-2-3-读取字符串"><a href="#5-2-3-读取字符串" class="headerlink" title="5.2.3 读取字符串"></a>5.2.3 读取字符串</h5><p><img src="/images/jsys_12/readLine.jpg" alt=""></p><p><strong>其他模块String，Array，Output，Sys是在以上模块上的封装，具体的实现细节就参考书吧。</strong></p><h3 id="6-Q-amp-A"><a href="#6-Q-amp-A" class="headerlink" title="6 Q&amp;A"></a>6 Q&amp;A</h3><p>Q：关于平方根算法有更高效的算法吗？<br>A：除了书中提到的牛顿法求平方根（不动点算法），泰勒展开，<a href="http://nand2tetris-questions-and-answers-forum.32033.n3.nabble.com/A-more-efficient-square-root-algorithm-td4028140.htmla" title="这里" target="_blank" rel="noopener">这里</a>实现了一个长除法的实现，除了平方根算法，书中对于圆的绘制也有<a href="http://nand2tetris-questions-and-answers-forum.32033.n3.nabble.com/Fast-circle-algorithm-td4030808.html" title="更高效的算法" target="_blank" rel="noopener">更高效的算法</a></p><h3 id="7-Reference"><a href="#7-Reference" class="headerlink" title="7 Reference"></a>7 Reference</h3><p><a href="http://sites.google.com/site/johnkennedyshome/home/downloadable-papers/bcircle.pdf" title="用于绘制圆的快速Bresenham型算法，John Kennedy" target="_blank" rel="noopener">用于绘制圆的快速Bresenham型算法，John Kennedy</a><br><a href="https://sites.google.com/site/johnkennedyshome/home/downloadable-papers/bcircle.pdf?attredirects=0" title="用于绘制椭圆的快速Bresenham型算法，John Kennedy" target="_blank" rel="noopener">用于绘制椭圆的快速Bresenham型算法，John Kennedy</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nand2tetris </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>迭代器实现（零）</title>
      <link href="/2018/08/31/iterator-00/"/>
      <url>/2018/08/31/iterator-00/</url>
      
        <content type="html"><![CDATA[<h3 id="1-迭代器是什么"><a href="#1-迭代器是什么" class="headerlink" title="1 迭代器是什么"></a>1 迭代器是什么</h3><p>在计算机编程中，迭代器是一个对象，它使程序员能够遍历容器，特别是列表。通常通过容器的接口提供各种类型的迭代器。虽然给定迭代器的接口和语义是固定的，但迭代器通常是根据容器实现的底层结构实现的，并且通常紧密耦合到容器以启用迭代器的操作语义。迭代器执行遍历并且还允许访问容器中的数据元素，但本身不执行迭代（即，并非没有采用该概念或使用术语的轻微自由）。迭代器在行为上类似于数据库游标。迭代器可以追溯到1974年的CLU编程语言。</p><h3 id="2-为什么会需要迭代器？"><a href="#2-为什么会需要迭代器？" class="headerlink" title="2 为什么会需要迭代器？"></a>2 为什么会需要迭代器？</h3><ol><li>便于数据流的控制，假定有一个数据流，这时如果有迭代器就可以很方便的操作这个数据流，当然也可以把迭代器理解为延时求值（lazy eval）啦</li><li>解耦算法和数据结构，比如你想找到树中符合条件的节点，传统的做法是使用一个查找算法，传入一个树对象和查找条件，遍历树进行匹配，而拥有迭代器之后，你只需不停的next直到迭代器末尾，大大增加了代码的可读性（毕竟是线性的）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器前</span></span><br><span class="line">select(node, condition,result) &#123;</span><br><span class="line"><span class="keyword">if</span> (node) &#123;</span><br><span class="line"><span class="keyword">if</span>(node.left !== <span class="string">''</span>) &#123;</span><br><span class="line">select(node.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (condition(node.value)) &#123;</span><br><span class="line">result.push(node.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node.right !== <span class="string">''</span>) &#123;</span><br><span class="line">select(node.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器后,可读性增强了</span></span><br><span class="line">select(treeIterator, condition， result) &#123;</span><br><span class="line"><span class="keyword">for</span>(treeNode <span class="keyword">of</span> treeIterator) &#123; <span class="comment">// 假定这里for of调用迭代器，事实上在JS中也确实如此</span></span><br><span class="line"><span class="keyword">if</span>(condition(treeNode)) &#123;</span><br><span class="line">result.push(treeNode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然线性的代码更可读，但我个人觉得递归的代码真的很美…我个人在可以递归的条件下是不会去写迭代的（除了效率限制），不过现在部分编译器支持Tail call optimization，虽然JavaScript没有，但是你可以将任何递归用黑魔法 Trampoline转化为形式上的尾递归~</p><h3 id="3-实现迭代器"><a href="#3-实现迭代器" class="headerlink" title="3 实现迭代器"></a>3 实现迭代器</h3><p>迭代器的本质是延迟求值或者说部分求值（令我想到了SICP的流模型），那么由于传统的程序执行比如递归，你是无法控制程序的控制流的，拿之前的递归遍历树的例子来看，你无法在它遍历到某个子树（这时这个子树的左右节点还存在）的情况下马上回到根节点的，这是因为受限于函数的调用栈，当然你可以通过cps变换来手动控制你的代码，这是另外一回事，这里暂不予展开。既然我们不能控制函数调用栈，那我们就一不做二不休的自己创建栈来模拟之前的遍历函数运行，这样代码就在我们的掌控下了（基于栈的程序控制其实体现着栈式虚拟机的思想，通过push和pop来控制”计算”，而CPS变换更多的体现的是续算（continuation）的传递，PL的魔法啦）</p><p>接下来我们可以看看，基于栈的非递归遍历实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于栈的非递归查询算法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inorder_tarverse_nonrecursive</span>(<span class="params">node,condition,result</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> stack = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 压入所有左子节点</span></span><br><span class="line"><span class="keyword">while</span> (node) &#123;</span><br><span class="line">stack.push(node);</span><br><span class="line">node = node.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Pop出左子节点，进入右子节点或者返回父节点</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> top = stack.pop();</span><br><span class="line"><span class="keyword">if</span> (condition(top)) &#123;</span><br><span class="line">result.push(top.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (top.right) &#123;</span><br><span class="line">node = top.right;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时根节点和根中所有左子节点已经遍历完毕</span></span><br><span class="line"><span class="keyword">if</span> (stack.length === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历完毕所有节点</span></span><br><span class="line"><span class="keyword">if</span> (stack.length === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里给出递归实现以做对比<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inorder_traverse</span>(<span class="params">node,condition,result</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node) &#123;</span><br><span class="line">inorder_traverse(node.left);</span><br><span class="line"><span class="keyword">if</span> (condition(node.value)) &#123;</span><br><span class="line">result.push(result);</span><br><span class="line">&#125;;</span><br><span class="line">inorder_traverse(node.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>递归的调用栈和非递归模拟的程序栈对比<br>树：<br><img src="/images/tools/iterator/树.jpg" alt=""></p><p>非递归：<br><img src="/images/tools/iterator/栈1.jpg" alt=""><br><img src="/images/tools/iterator/栈2.jpg" alt=""></p><p>递归<br><img src="/images/tools/iterator/callStack.jpg" alt=""></p><font color="red">可以看出非递归模拟递归的本质就在于程序控制流的模拟，这里的控制流并不是调用栈的模拟，而是计算顺序的模拟（体现在上面的例子中就是对节点值的访问顺序），非递归模拟代码就是用栈中的节点来模拟访问的次序</font><p>既然现在我们已经能够用栈来模拟控制流，这也意味着对程序的遍历的控制已经完全受制于我们（这里的完全受制是逻辑上的，屏蔽底层编译的细节），我们终于摆脱了了call stack :)</p><p>现在我们可以肆意的操控我们的遍历程序,接下来用闭包保存栈，每次next调用pop一次来实现迭代<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeTreeIterator</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> controlStack = [];</span><br><span class="line"></span><br><span class="line">((<span class="function"><span class="keyword">function</span> <span class="title">InorderIterator</span>(<span class="params">currNode</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 将当前节点的所有左子节点入栈</span></span><br><span class="line"><span class="keyword">while</span> (currNode) &#123;</span><br><span class="line">controlStack.push(currNode);</span><br><span class="line">currNode = currNode.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(node))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (controlStack.length) &#123;</span><br><span class="line"><span class="comment">// 取出当前节点</span></span><br><span class="line"><span class="keyword">let</span> top = controlStack.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (top.right) &#123;</span><br><span class="line"><span class="keyword">let</span> currNode = top.right;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前节点的右子节点的所有左子节点压栈</span></span><br><span class="line"><span class="keyword">while</span> (currNode) &#123;</span><br><span class="line">controlStack.push(currNode);</span><br><span class="line">currNode = currNode.left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">value</span>: top.value, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拉出迭代器遛遛<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tree = &#123;</span><br><span class="line">value: <span class="number">5</span>,</span><br><span class="line">left: &#123;</span><br><span class="line">value: <span class="number">4</span>,</span><br><span class="line">left: <span class="string">''</span>,</span><br><span class="line">right: <span class="string">''</span></span><br><span class="line">&#125;,</span><br><span class="line">right: &#123;</span><br><span class="line">value: <span class="number">8</span>,</span><br><span class="line">left: &#123;</span><br><span class="line">value: <span class="number">6</span>,</span><br><span class="line">left: <span class="string">''</span>,</span><br><span class="line">right: <span class="string">''</span></span><br><span class="line">&#125;,</span><br><span class="line">right: <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test = makeTreeIterator(tree),result = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = test.next(); i.done !== <span class="literal">true</span>; i=test.next()) &#123;</span><br><span class="line"><span class="keyword">if</span> (i.value &lt; <span class="number">5</span>) &#123;</span><br><span class="line">result.push(i.value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [4]</span></span><br></pre></td></tr></table></figure></p><p>还有一种实现迭代器的方法就是使用continuation来实现控制反转啦~<br>下一篇博客会去讲解如何用continuation来实现迭代器，这里先用ES6的generator来预热<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inOrder</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node) &#123;</span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">of</span> inOrder(node.left)) &#123;</span><br><span class="line"><span class="keyword">yield</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">yield</span> node.value;</span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">of</span> inOrder(node.right)) &#123;</span><br><span class="line"><span class="keyword">yield</span> x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test = inOrder(tree),result = [];</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">of</span> test) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">result.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [4]</span></span><br></pre></td></tr></table></figure></p><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h3><p>基于栈可以模拟控制流，这也是栈式虚拟机的思想，堆栈处理不愧是计算机领域强劲的技术，从迭代引申到控制流，看来“取指-执行”模型不仅仅用在CPU啊。</p><h3 id="5-Reference"><a href="#5-Reference" class="headerlink" title="5 Reference"></a>5 Reference</h3><p><a href="https://coolshell.cn/articles/9886.html/comment-page-1#comments" title="二叉树迭代器算法" target="_blank" rel="noopener">二叉树迭代器算法</a><br><a href="http://effbot.org/pyfaq/what-is-an-iterator.htm" title="What is an iterator?" target="_blank" rel="noopener">What is an iterator?</a><br><a href="https://stackoverflow.com/questions/49052473/folder-iterator-continuation-token-recursive-loop" title="Folder Iterator Continuation Token Recursive Loop" target="_blank" rel="noopener">Folder Iterator Continuation Token Recursive Loop</a><br><a href="http://gallium.inria.fr/blog/generators-iterators-control-and-continuations/" title="generators-iterators-control-and-continuations/" target="_blank" rel="noopener">generators-iterators-control-and-continuations/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Jason Tomas的造轮子之旅 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算的要素第七-八章小结</title>
      <link href="/2018/08/29/jsys_07-08_summary/"/>
      <url>/2018/08/29/jsys_07-08_summary/</url>
      
        <content type="html"><![CDATA[<p><em>Programmers are creators of universes for which they alone are responsiable. Universes of virtually unlimited complexity can be created in the form of computer programms. —-Joseph Weizenbaum, Computer Power and Human Reason, 1974</em></p><p>因为书中第七章和第八章都在讲虚拟机的后端部分，故这里将其合并总结。</p><h3 id="1-虚拟机"><a href="#1-虚拟机" class="headerlink" title="1 虚拟机"></a>1 虚拟机</h3><h4 id="1-1-虚拟机是什么"><a href="#1-1-虚拟机是什么" class="headerlink" title="1.1 虚拟机是什么"></a>1.1 虚拟机是什么</h4><p><img src="/images/jsys_07-08/VM.jpg" alt=""><br>虚拟机（VM）是在本机操作系统之上的高级抽象，它模拟物理机器。在本书中，我们讨论的是中间编译目标，既不是进程虚拟机(process virtual machine)，比如JVM，CLR等运行时平台，也不是系统虚拟机(system virtual machine)，系统虚拟机提供了系统级的硬件抽象，比如VirtualBox。虚拟机使同一平台能够在多个操作系统和硬件体系结构上运行。可以将Java和Python的解释器作为示例，其中代码被编译为JVM特定的字节码。在Microsoft .Net体系结构中也可以看到相同的情况，其中代码被编译为CLR（公共语言运行时）的中间语言。这里有一篇讲解<a href="http://nand2tetris-questions-and-answers-forum.32033.n3.nabble.com/What-does-quot-virtual-machine-quot-and-quot-real-platform-quot-mean-td4028959.html#a4028960" title="Hack VM" target="_blank" rel="noopener">Hack VM</a>的例子供大家参考。<br>虚拟机通常应该实现什么？它应该模拟物理CPU执行的操作，因此理想情况下应包含以下概念：</p><ol><li>将源语言编译为VM特定的字节码</li><li>包含指令和操作数的数据结构（指令处理的数据）</li><li>用于函数调用操作的调用堆栈</li><li>指向下一条要执行的指令的“指令指针”（IP）</li><li>一个虚拟的’CPU’ - 指令调度程序</li><li>获取下一条指令（由指令指针寻址）</li><li>解码操作数</li><li>执行指令</li></ol><h4 id="1-2-为什么需要虚拟机？"><a href="#1-2-为什么需要虚拟机？" class="headerlink" title="1.2 为什么需要虚拟机？"></a>1.2 为什么需要虚拟机？</h4><p>高级语言程序在运行在目标机器上之前，必须得翻译成对应的机器语言。这个编译过程是相当复杂的…通常，必须给任意给定的高级语言写对应到指定机器的编译器，但这种高级语言到机器语言的直接映射直接导致了强依赖，从软件工程的角度看减少依赖，没有什么是加一层抽象不能解决的，如果有，那就加两层。<br>结果就是，为了减少依赖，将整个编译过程划分为几乎独立的两个阶段。</p><ul><li>第一阶段，高级语言翻译到中间语言（IR）</li><li>第二阶段，中间语言翻译到对应的硬件机器语言</li></ul><p>你看这样语言的编译器实现人员在大部分情况下就不用再写各种各样的编译到机器语言的编译器，瞧瞧Clojure，站在JVM的肩膀上：），事实上这种行为也是软件工程的良好体现，良好的模块化设计（高层模块和底层模块，模块件通过VMcode这种语言通信）和抽象屏障（VMCode就是高层和底层之间的万里长城）意味着编写高级语言的编译器的程序员（高层模块）和将VMcode编译到硬件的程序员（底层模块）可以分头行动，抽象屏障万岁！！！</p><h4 id="1-3-Stack-based-Virtual-Machine"><a href="#1-3-Stack-based-Virtual-Machine" class="headerlink" title="1.3 Stack based Virtual Machine"></a>1.3 Stack based Virtual Machine</h4><p>VM的实现主流有两种，一种是堆栈模型，一种是寄存器模型（下一节讲），选择模型要考虑的关键因素是：<font color="red">在VM操作中的操作数和操作结果应该放在哪里。而在堆栈模型中，是将其放在堆栈（stack）这个数据结构中。</font><br>基于栈的虚拟机有以下几个特点</p><ul><li>指令长度是固定的</li><li>执行多个操作数计算时，会先将操作数做压入栈，由运算指令取出并计算</li></ul><p>下面以Add指令来说明stack machine的一般操作：<br><img src="/images/jsys_07-08/add.jpg" alt=""></p><ol><li>PUSH 4 // 当前栈指针指向的地址赋值4，SP=SP+1</li><li>PUSH 5 // 当前栈指针指向的地址赋值5，SP=SP+1</li><li>ADD     // 取出栈最上方的两个值相加，压入SP-2，SP=SP-1</li></ol><p>可以看出基于堆栈的模型的优点在于操作数由堆栈指针(SP)隐式地寻址。这意味着虚拟机不需要显式地知道操作数地址，因为调用堆栈指针将给（Pop）下一个操作数。在基于堆栈的VM中，所有算术和逻辑运算都是通过push和pop操作数并在堆栈中生成来执行的。</p><h4 id="1-4-Register-based-Virtual-Machine"><a href="#1-4-Register-based-Virtual-Machine" class="headerlink" title="1.4 Register based Virtual Machine"></a>1.4 Register based Virtual Machine</h4><p>在基于寄存器的虚拟机实现中，存储操作数的数据结构基于CPU的寄存器。这里没有PUSH或POP操作，但是指令需要包含操作数的地址（寄存器）。也就是说，指令的操作数在指令中明确地被寻址，不像基于堆栈的模型，其中我们有一个指向操作数的堆栈指针。例如，如果要在基于寄存器的虚拟机中执行ADD操作，则指令或多或少如下：<br><img src="/images/jsys_07-08/register.jpg" alt=""></p><p>正如前面提到的，没有POP或PUSH操作，因此添加指令只是一行。但是与堆栈不同，我们需要明确地将操作数的地址称为R1，R2和R3。这里的优点是<strong>不存在入栈出栈开销</strong>，并且基于寄存器的VM中的指令在指令调度循环内执行得更快。</p><p>基于寄存器的模型的另一个优点是它允许在基于堆栈的方法中无法完成的某些优化。一个这样的例子是当代码中有<strong>共同的子表达式</strong>时，寄存器模型可以计算一次并将结果存储在寄存器中以供将来使用时子表达式再次出现，这降低了重新计算表达式的成本。</p><p>基于寄存器的模型的<strong>问题</strong>是平均寄存器指令大于平均堆栈指令（指令长度也不是固定的），因为我们需要明确指定操作数地址。由于堆栈指针对堆栈机器的指令很短，相应的寄存器机器指令需要包含操作数位置，并且与堆栈代码相比产生更多的寄存器代码，并且如果利用寄存器做数据交换，就要经常保存和恢复寄存器的结果，这就导致基于寄存器的虚拟机在实现上要比基于栈的复杂，代码编译也要复杂得多</p><p>我遇到的一篇很棒的博客文章（在此链接中）包含基于寄存器的虚拟机的解释性和简单的C实现。如果实现虚拟机和解释器是您的主要兴趣，那么ANTLR创建者Terrence Parr的书名为“语言实现模式：创建您自己的特定领域和通用编程语言”，可能会非常方便。</p><h3 id="2-堆栈运算"><a href="#2-堆栈运算" class="headerlink" title="2 堆栈运算"></a>2 堆栈运算</h3><h4 id="2-1-算术和逻辑命令"><a href="#2-1-算术和逻辑命令" class="headerlink" title="2.1 算术和逻辑命令"></a>2.1 算术和逻辑命令</h4><p><img src="/images/jsys_07-08/arithic.jpg" alt=""><br>VM支持一元和二元操作命令。根据命令的操作数个数，从堆栈中弹出对应个元素，然后执行相应的运算，再将结果压入堆栈。这么做的好处很明显，每次操作不用管堆栈的其余部分（除了操作数）</p><h4 id="2-2-内存访问命令"><a href="#2-2-内存访问命令" class="headerlink" title="2.2 内存访问命令"></a>2.2 内存访问命令</h4><p><img src="/images/jsys_07-08/PushPop.jpg" alt=""><br>所有的内存段都通过两个命令来存取，PUSH，POP，这使得对内存的操作只需关注栈顶的变化。</p><h3 id="3-程序控制"><a href="#3-程序控制" class="headerlink" title="3 程序控制"></a>3 程序控制</h3><h4 id="3-1-程序控制流命令"><a href="#3-1-程序控制流命令" class="headerlink" title="3.1 程序控制流命令"></a>3.1 程序控制流命令</h4><p><img src="/images/jsys_07-08/goto.jpg" alt=""><br>计算机程序默认的执行顺序是线性的，即一个命令接着一个命令执行    ，这个连续的控制流偶尔被分支命令打断（比如在循环中执行迭代）。在底层编程中，分支逻辑采用goto destination 命令实现，该命令让计算机跳转到目标参数指定的位置（Hack是goto到ROM的指定位置），而不是接着原指令的下一条指令线性执行。目的地址的指定方式可以有多种形式，最原始的一种就是指定即将执行的指令的物理地址。应用标签label来描述jump的目的地址可以建立稍微抽象一点的重定向命令（redirection command）。这种改进需要程序语言配有标签指令（labeling directive），它可将标签绑定到程序中的指定位置。</p><h4 id="3-2-函数调用命令"><a href="#3-2-函数调用命令" class="headerlink" title="3.2 函数调用命令"></a>3.2 函数调用命令</h4><p><img src="/images/jsys_07-08/funCall.jpg" alt=""><br>高级语言所具有的这种能将表达式自由组合的能力使得我们可以编写抽象代码，让我们把主要精力放在算法的思想上面，而不是机器的执行上。当然高级语言抽象级别越高，在底层要做的工作就越多。特别是，必须在底层控制子程序（callee）和子程序调用者（caller）之间的相互影响。对于在运行期的每个子程序调用，底层必须处理下面的一些细节</p><ul><li>将参数从调用者(caller)传递给被调用者(callee)</li><li>在跳转并执行被调用者之前，先保存调用者的状态</li><li>为被调用者使用的局部变量分配空间</li><li>跳转并执行被调用者</li><li>将被调用者的运行结果返回给调用者</li><li>在从被调用者返回之前，回收其使用的内存空间</li><li>恢复调用者的状态</li><li>返回到调用语句之后的下一条语句继续执行</li></ul><p>有关上述命令的实现，书中都有详细介绍，这里就不再展开叙述。</p><h3 id="4-Q-amp-A"><a href="#4-Q-amp-A" class="headerlink" title="4 Q&amp;A"></a>4 Q&amp;A</h3><p>Q：有什么办法可以优化生成的asm代码吗？<br>A：<a href="http://nand2tetris-questions-and-answers-forum.32033.n3.nabble.com/Generated-code-size-td1201814.html" title="hack vmtranslator优化" target="_blank" rel="noopener">hack vmtranslator优化</a></p><p>Q：How is the VM really made?<br>A：VM Translator在您的计算机上运行，并将.vm文件转换为.asm文件。我用Python编写了我的VM Translator。编写本机VM是一项艰巨的任务，需要比Hack更复杂的计算机才能运行。Java VM是用C / C ++编写的。特定于平台的编译器允许它在各种不同的目标硬件上运行。已经用C / C ++编写了与目标操作系统连接的库。当您为32位Windows系统下载Java时，您将获得一个二进制文件，该二进制文件的目标是与适当的Windows支持库链接的32位Intel 处理器。在现实世界中，我们尽可能少地编写汇编代码。对于我（Mark）所做的嵌入式系统编程，工具（编译器等）在Windows上运行，只有二进制文件加载到实际的硬件上。所有代码都是用C语言编写的，带有一些小的汇编语言例程。512K ROM和64K RAM是一个很大的配置。现代C / C ++编译器是使用它们自己的早期版本编写的。第一个C编译器可能用B语言编写，B语言是C语言的前身。</p><p>Q：既然Hack VM只是个目标代码，那么如何用Jack来实现VM 模拟器呢（现在Jack的栈式虚拟机能跑都是多亏了Java编写的模拟器，实际上这个模拟器起了一个VM的作用，问题是现在要用Jack自我实现这个模拟器，通过JackOS的硬件）<br>A：事实上这里Mark已经有了尝试<a href="http://nand2tetris-questions-and-answers-forum.32033.n3.nabble.com/Hack-II-Escaping-the-Harvard-straitjacket-td2877780.html" title=" Hack II: Escaping the Harvard straitjacket" target="_blank" rel="noopener"> Hack II: Escaping the Harvard straitjacket</a></p><h3 id="5-Reference"><a href="#5-Reference" class="headerlink" title="5 Reference"></a>5 Reference</h3><p><a href="https://en.wikipedia.org/wiki/Virtual_machine" title="Virtual Machine" target="_blank" rel="noopener">Virtual Machine</a><br><a href="https://stackoverflow.com/questions/861422/is-the-java-virtual-machine-really-a-virtual-machine-in-the-same-sense-as-my-vmw" title="Is the Java Virtual Machine really a virtual machine in the same sense as my VMWare or Parallels file?" target="_blank" rel="noopener">Is the Java Virtual Machine really a virtual machine in the same sense as my VMWare or Parallels file?</a><br><a href="https://blog.csdn.net/mycwq/article/details/45653897" title="erlang虚拟机代码执行原理" target="_blank" rel="noopener">erlang虚拟机代码执行原理</a><br><a href="https://markfaction.wordpress.com/2012/07/15/stack-based-vs-register-based-virtual-machine-architecture-and-the-dalvik-vm/" title="Stack based vs Register based Virtual Machine Architecture, and the Dalvik VM" target="_blank" rel="noopener">Stack based vs Register based Virtual Machine Architecture, and the Dalvik VM</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nand2tetris </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从零开始的编译原理之旅----Parser篇(零)</title>
      <link href="/2018/08/28/parser_00/"/>
      <url>/2018/08/28/parser_00/</url>
      
        <content type="html"><![CDATA[<h3 id="0-序言"><a href="#0-序言" class="headerlink" title="0 序言"></a>0 序言</h3><p>自从去年学了编译原理已经过去快一年了，之前的编译知识体系的构建太松散，所以我准备重新梳理一遍编译的知识脉络，但我的能力毕竟有限，非常希望有能力的读者能指正我文章中的一些不足之处，编程之道，编译之路也才刚刚起步，能力有限之处也请大家多包涵。</p><p>本系列文章阅读前置条件</p><ul><li>熟悉常见的Grammar定义（Reference里有bnf、ebnf的grammar guide，不熟悉的朋友可以去看看）</li></ul><h3 id="1-目录"><a href="#1-目录" class="headerlink" title="1 目录"></a>1 目录</h3><p>本系列旨在学习各种parser思路及技巧，分为以下几个部分</p><ol start="0"><li><a href="https://belyenochi.github.io/2018/08/28/parser_00/#more" target="_blank" rel="noopener"> 清晨入古寺—-论世间parser为何物<strong>[本篇]</strong></a></li><li><a href="https://belyenochi.github.io/2018/09/03/parser_01/#more" target="_blank" rel="noopener"> 初日照高林—-初探First集，Follow集 </a></li><li><a href="https://belyenochi.github.io/2018/09/04/parser_02/#more" target="_blank" rel="noopener"> 曲径通幽处—-预测分析表的构建 </a></li><li><a href="https://belyenochi.github.io/2018/09/04/parser_06/#more" target="_blank" rel="noopener"> 禅房花木深—-实现LL(1) parser </a></li><li><a href="https://belyenochi.github.io/2018/09/04/parser_06/#more" target="_blank" rel="noopener"> 山光悦鸟性—-递归下降的两种实现 </a></li><li>潭影空人心—-浅谈recursive ascent parser(SLR,LALR(1))</li><li>万籁此俱寂—-parser combinator（从ohm.js源码说起）</li><li>但余钟磬音—-反思与总结</li></ol><h3 id="2-论世间parser为何物"><a href="#2-论世间parser为何物" class="headerlink" title="2 论世间parser为何物"></a>2 论世间parser为何物</h3><p>以下为王垠前辈原文的科普，Reference会提及建议大家读一读，说起来自己入了PL的坑还是看垠神的博客开始的。</p><p>首先来科普一下。所谓parser，一般是指把某种格式的文本（字符串）转换成某种数据结构的过程。最常见的parser，是把程序文本转换成编译器内部的一种叫做“抽象语法树”（AST）的数据结构。也有简单一些的parser，用于处理CSV，JSON，XML之类的格式。</p><p>举个例子，一个处理算数表达式的parser，可以把“1+2”这样的，含有1，+，2三个字符的字符串，转换成一个对象（object）。这个对象就像new BinaryExpression(ADD, new Number(1), new Number(2))这样的Java构造函数调用生成出来的那样。</p><p>之所以需要做这种从字符串到数据结构的转换，是因为编译器是无法直接操作“1+2”这样的字符串的。实际上，代码的本质根本就不是字符串，它本来就是一个具有复杂拓扑的数据结构，就像电路一样。“1+2”这个字符串只是对这种数据结构的一种“编码”，就像ZIP或者JPEG只是对它们压缩的数据的编码一样。</p><p>这种编码可以方便你把代码存到磁盘上，方便你用文本编辑器来修改它们，然而你必须知道，文本并不是代码本身。所以从磁盘读取了文本之后，你必须先“解码”，才能方便地操作代码的数据结构。比如，如果上面的Java代码生成的AST节点叫node，你就可以用node.operator来访问ADD，用node.left来访问1，node.right来访问2。这是很方便的。</p><p>对于程序语言，这种解码的动作就叫做parsing，用于解码的那段代码就叫做parser。</p><h3 id="3-为什么需要parser"><a href="#3-为什么需要parser" class="headerlink" title="3 为什么需要parser"></a>3 为什么需要parser</h3><p>正如上文中王垠说的，程序的运行其实是在不同的数据结构之间做转换，写过Web application的同学肯定对JSON，XML这类数据格式很熟悉，那么传输过程中经常涉及到将系统中的某种数据结构parser到某种传输格式上，包括很多时候从I/O中提取数据也是个parser的过程，只不过这些parser确实比较简单，但确实是日常生活工作中不可或缺的部分，而在编译过程中其实parser就体现了将程序从高人类可读性（比如字符串）转换成高机器可读性（AST）（这里的高机器可读和VMtranslator，汇编器，指令集没有直接关系，只是为了描述高度结构化的AST可以使代码生成更加容易，也就是编译过程友好），而没有parser就意味着手写AST这个过程对于大部分人来说并不是那么直观，不过这确实对于Lisp家族程序员是一件非常美妙的事情，S-Expression万岁~</p><h3 id="4-如何使用parser"><a href="#4-如何使用parser" class="headerlink" title="4 如何使用parser"></a>4 如何使用parser</h3><ol><li>定义好一组文法（CFG等）</li><li>构建好预测表并选择对应能够解析该文法的算法（LL(1)等）<font color="red">【可选】</font>（可以使用yacc，Bison等解析）</li><li>将输入数据读入paser<font color="red">【可选】</font>（可以手写tokenizer，也可以使用Lex生成）</li></ol><p>此时得到了另一种数据结构，在编译中往往是结构化的AST，当然也可以是XML或者JSON,接下来就是应用这种数据结构的事了。</p><h3 id="5-parser图解"><a href="#5-parser图解" class="headerlink" title="5 parser图解"></a>5 parser图解</h3><p>由ohm.js生成的AST结构，将1+2*3映射到AST，便于大家感性理解<br><img src="/images/parser_00/example.jpg" alt=""></p><h3 id="6-Reference"><a href="#6-Reference" class="headerlink" title="6 Reference"></a>6 Reference</h3><p><a href="https://github.com/harc/ohm" title="ohm.js" target="_blank" rel="noopener">ohm.js</a><br><a href="https://www.quora.com/What-exactly-does-parsing-mean-in-programming" title="What-exactly-does-parsing-mean-in-programming" target="_blank" rel="noopener">What-exactly-does-parsing-mean-in-programming</a><br><a href="http://www.yinwang.org/blog-cn/2015/09/19/parser" title="王垠前辈----对parser的误解" target="_blank" rel="noopener">王垠前辈—-对parser的误解</a><br><a href="http://matt.might.net/articles/grammars-bnf-ebnf/" title="Grammar" target="_blank" rel="noopener">Grammar</a></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> parser </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从零开始的正则引擎之旅(零)</title>
      <link href="/2018/08/27/regex-engine-00/"/>
      <url>/2018/08/27/regex-engine-00/</url>
      
        <content type="html"><![CDATA[<h3 id="1-序言"><a href="#1-序言" class="headerlink" title="1 序言"></a>1 序言</h3><p>距离挖这个坑已经过去3个月了，嗯，我没记错的的话4个月前我还挖了一个brainfuck解释器的坑，就作为下周的作业吧~<br>废话不多说，本系列旨在</p><ol><li>理解掌握一个简单parser的所作所为。</li><li>梳理正则引擎构建和优化过程中的各种该算法</li><li>造出一个能用的正则引擎（C++）</li><li>将该正则引擎作为Node.js的C++扩展</li></ol><h3 id="2-阶段构建图"><a href="#2-阶段构建图" class="headerlink" title="2 阶段构建图"></a>2 阶段构建图</h3><p><img src="/images/regex_engine_00/milestone.jpg" alt=""></p><ol><li>实现一个LL(1)的递归下降parser解析regex文法</li><li>将part1生成的AST转化为NFA</li><li>将NFA转化为DFA</li><li>优化DFA，最小化等</li><li><strong>【英雄难度副本】</strong>parser到VM code执行</li><li><strong>【史诗难度副本】</strong>采用JIT优化引擎<br>后两个阶段我现在并没有很大的把握做好，但我会尽力而为的，也欢迎熟悉这一块的同学能够给予我一些建议与指正，感激不尽。</li></ol><h3 id="3-Reference"><a href="#3-Reference" class="headerlink" title="3 Reference"></a>3 Reference</h3><p><a href="https://swtch.com/~rsc/regexp/" title="Implementing Regular Expressions Russ Cox " target="_blank" rel="noopener">Implementing Regular Expressions Russ Cox </a><br><a href="https://github.com/miura1729/ytljit/blob/master/sample/regexp.rb" title="ytljit" target="_blank" rel="noopener">ytljit</a><br><a href="https://www.zhihu.com/question/27434493" title="如何从零写一个正则表达式引擎？" target="_blank" rel="noopener">如何从零写一个正则表达式引擎？</a><br><a href="https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines" title="Comparison of regular expression engines" target="_blank" rel="noopener">Comparison of regular expression engines</a><br><a href="https://swtch.com/~rsc/regexp/regexp1.html" title="Regular Expression Matching Can Be Simple And Fast " target="_blank" rel="noopener">Regular Expression Matching Can Be Simple And Fast </a></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RegexEngine </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算的要素-第六章小结</title>
      <link href="/2018/08/27/jsys_06_summary/"/>
      <url>/2018/08/27/jsys_06_summary/</url>
      
        <content type="html"><![CDATA[<p><em>What’s in a name?That which we call a rose by any other name would smell as sweet</em></p><p>经历了前五个小节的学习，我们终于从硬件脱身了，请让我松一口气，毕竟熟悉各种各样的硬件细节可不是我的爱好…<br>好了，现在硬件对于我们来说就是一层抽象了，工程上的优势体现了出来，抽象屏蔽使得我们在写内存管理的时候不用去思考电信号:)<br>接下来我会总结一些关于第六章汇编器的知识，然后尽力的额外扩充一些知识，以后”有时间”去填坑</p><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h3><h4 id="1-1-机器语言"><a href="#1-1-机器语言" class="headerlink" title="1.1 机器语言"></a>1.1 机器语言</h4><p>机器语言分为两类，一类称作符号型（symbolic）和二进制型（binary），当然硬件实际执行的指令是二进制型号，那么为什么需要符号型呢，答案很简单，因为让机器读懂指令很容易，但让程序员读懂二进制型的机器指令（特别还不是他自己写的）就很困难了，可以想象如果有成千上百条不同的指令，那么对直接读取二进制的程序员来说想必并不舒服。此时，针对硬件可执行的二进制机器语言的抽象产生了，说是抽象其实是增加了可读性，此时可以用Load代表10000000（假定指令长度8位）的前5位，这种等效替换也出现在了marco，各种设计模式中，本质是对可读性的考虑。</p><h4 id="1-2-符号解析"><a href="#1-2-符号解析" class="headerlink" title="1.2 符号解析"></a>1.2 符号解析</h4><p>利用符号表进行符号解析</p><h4 id="1-3-汇编编译器"><a href="#1-3-汇编编译器" class="headerlink" title="1.3 汇编编译器"></a>1.3 汇编编译器</h4><p>汇编编译器的输入是一串汇编命令，然后产生一串等价的二进制指令作为输出。生成的代码被加载到计算机的内存中然后被硬件执行。<font color="blue">可见，汇编编译器主要是个文本处理程序，设计目的是用来提供翻译服务。</font>编写汇编编译器的程序员必须有完整的汇编语法说明文档和相应的二进制代码。有了这样的约定（通常称为机器语言规范），就不难编写程序，让其对每个符号命令执行下面的任务（顺序无关）</p><ul><li>解析出符号命令内在的域</li><li>对每个域，产生机器语言中相应的位域</li><li>用内存单元的数字地址来替换所有的符号引用</li><li>将二进制码汇编成完整的机器指令</li></ul><h3 id="2-指令"><a href="#2-指令" class="headerlink" title="2 指令"></a>2 指令</h3><p>Hack的指令集比较IA-32的指令可以说是很简单了，hack的指令分为寻址指令（A-指令，Addressing Instruction）和计算指令（C-指令，Comput Instruction）<br><img src="/images/jsys_06/instruction.jpg" alt=""><br>A指令的作用是将value读入A寄存器，比如你要访问内存地址为12的值，步骤如下</p><ol><li>@12 // 将12这个地址值读入A寄存器</li><li>M     // M的默认行为是将A寄存器中的值作为地址访问该地址存储的值<br><img src="/images/jsys_06/memory.jpg" alt=""></li></ol><h3 id="3-符号定义"><a href="#3-符号定义" class="headerlink" title="3 符号定义"></a>3 符号定义</h3><p>符号分为3种，分别是：</p><h4 id="3-1-预定义符号"><a href="#3-1-预定义符号" class="headerlink" title="3.1 预定义符号"></a>3.1 预定义符号</h4><p>预定义符号指代的是对应的符号在数据内存中的位置（RAM）<br><img src="/images/jsys_06/preDefine.jpg" alt=""></p><h4 id="3-2-标签符号"><a href="#3-2-标签符号" class="headerlink" title="3.2 标签符号"></a>3.2 标签符号</h4><p>标签符号中符号对应的是指令内存中的位置（ROM），且每个标签只能被定义一次，可以在程序的任何地方使用，包括在定义位置之前，这让我联想到了JS的预定义，估计也是先扫了一遍符号表，这里的符号表和编译器前端parser的符号表不是一个概念，虽然都是对符号的某种映射，但汇编器的符号表更加底层，它将符号映射到地址，而parser的符号表是一种上下文环境，这个在后面总结parser的时候会再提到。</p><p>标签符号例子：<br>(LOOP) 它的作用仅仅是更新符号表，其值为下一条指令的地址，这个在x86_64的反汇编也同样，可以看到标签语句是没有对应的二进制值的</p><h4 id="3-3-变量符号"><a href="#3-3-变量符号" class="headerlink" title="3.3 变量符号"></a>3.3 变量符号</h4><p>任何出现在汇编程序中的符号Xxx，不是预定义符号或标签符号，就将他作为变量符号处理，变量符号的地址默认从RAM[16]开始逐一分配,是的你没看错，逐一分配意味着在一个程序中已经废弃的变量也会永久持有内存，在第13章我会尝试用GC来解决部分堆内存问题，但这里的分配问题应该是指令集层面的考量所以除非修改分配策略否则无解。</p><p>变量例子：<br>@i 这里的i可以代表循环变量，默认变量从RAM地址16处开始分配</p><h3 id="4-Q-amp-A"><a href="#4-Q-amp-A" class="headerlink" title="4 Q&amp;A"></a>4 Q&amp;A</h3><ul><li><p><font color="red">Q：如何完成交叉汇编程序以及生成的代码如何读取.asm的文本输入以及如何维护其符号表?</font><br><strong>A：这些在这门课都没有涉及，感兴趣的同学可以学习<a href="http://www.davidsalomon.name/assem.advertis/AssemAd.html" title="Assemblers And Loaders." target="_blank" rel="noopener">Assemblers And Loaders.</a></strong></p></li><li><p><font color="red">Q：实际计算机中的汇编程序如何工作？我确信它不会使用高级语言将.asm文件转换为二进制文件……它是如何做到的呢？使用机器代码本身？</font><br><strong>A1：40年前，许多大型计算机程序仍然用汇编语言编写，因为每个字节都计算在内。例如，IBM 370型号145是IBM的第一台带有半导体内存的大型机，它的最大配置为512 千字节RAM。基本配置仅为112 KB。存储器周期速率约为3 MHz。 随着内存越来越大，速度越来越快，我们可以不再担心程序的大小，而是使用更高级别的语言来使编程更快，更不容易出错。 现代计算机的装配工几乎肯定是用高级语言编写的，很可能是’C’。例如，参见<a href="http://en.wikipedia.org/wiki/GNU_Assembler。" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/GNU_Assembler。</a> </strong><br><strong>A2：与任何其他科学领域一样，计算机科学领域由众多科学家和研究者建造，每个科学家和研究者都贡献了一小部分。所以，有很多英雄。 每种编程语言，无论是低级汇编语言还是高级现代语言，都是一种抽象。抽象是由语言设计师创造的，他们是一些有想法的人。<br>为了实现抽象，即将语言从正式规范转换为实用工具，您必须能够将用该语言编写的程序翻译成我们已经知道要执行的另一种语言。根据我们希望翻译的语言的抽象级别，此翻译代理称为“编译器”，“VM翻译器”，“汇编程序”等。无论名称如何，它总是翻译一个文本文件（例如包含C代码）到另一个文本文件（例如包含汇编代码）。因为这个翻译器本质上是非常精美的文本处理程序，所以它可以用你选择的任何语言编写。<br>尽管第一个汇编程序是用机器语言编写的，但你是正确的。但是一旦实现了第一步，生成的汇编程序就可以用来翻译符号程序，所以从那时起就不再需要用二进制代码编写代码了。剩下的就是历史……“智能是制造人造物品的能力，尤其是制造工具的工具。” （Henry Bergson，1859-1941）</strong></p></li><li><p><font color="red">Q：如果实际计算机中的汇编程序本身是用机器代码编写的，那么我是否可以使用hack汇编语言本身实现“项目6”？为什么要使用高级语言？</font><br><strong>A：使用Hack汇编语言编写汇编程序的限制因素是计算机模拟器没有I / O工具来访问主机上的文件。（但各种高级语言有I/O库）对于项目6，您需要处理存储在计算机上的.ASM文件，并编写将加载到模拟器中的.HACK文件。 </strong></p></li><li><p><font color="red">Q：我理解架构以及ROM中的二进制值如何工作，但我不知道我们如何从具有机器代码（.hack）的文本文件转到ROM中的实际二进制值。 因为它是文本文件，所以每个“1”和“0”都是ASCII字符。 那么，我们如何从硬件上的ASCII转换为真正的二进制值？</font><br><strong>A：将汇编程序的输出视为另一种中间“语言”。还有另一种工具可以读取该语言并将其加载到可以执行该语言的计算机中。<br>在像PC这样的通用计算机中，可执行文件由称为加载器的操作系统的一部分加载到存储器中。在基于ROM的计算机中，使用称为ROM编程器的硬件工具来编写ROM。<br>Hack CPU Emulator上的“加载程序”命令是模拟ROM programmer。<br>汇编器输出和可执行文件之间的软件链中通常还有另一个步骤。一个连接器  结合了多个汇编目标文件  和库 创建可执行文件。为了支持链接，目标文件包含额外的信息，告诉他们需要哪些外部函数以及外部函数可以调用的函数。 </strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nand2tetris </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算的要素第五章小结</title>
      <link href="/2018/08/04/jsys_05_summary/"/>
      <url>/2018/08/04/jsys_05_summary/</url>
      
        <content type="html"><![CDATA[<p><em>what I hear, I forget;     What see, I remember; What I do, I understand.</em></p><h3 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1 回顾"></a>1 回顾</h3><p><img src="/images/jsys_05/00-04.jpg" alt=""><br>经过了逻辑门，触发器，寄存器，RAM,PC，ALU，取址模式，I/O内存映像的学习，我们已经学习了实现CPU的前置条件，那么让我开始开始CPU以及进一步的Hack Machine的实现吧！</p><h3 id="2-背景"><a href="#2-背景" class="headerlink" title="2 背景"></a>2 背景</h3><h4 id="2-1-存储程序"><a href="#2-1-存储程序" class="headerlink" title="2.1 存储程序"></a>2.1 存储程序</h4><p>一个由有限硬件组件构成的计算机却可以执行无限的任务队列，从交互式游戏到字处理到科学计算，这些其实都是“存储设备    （stored program）”概念的功劳。<br>存储设备的概念想当简单：计算机基于固定的硬件平台，能够执行固定的指令集。同时，这些指令能够被当作构建模块，组成任意的模块。这种思想也体现在软件工程领域中的模块化设计，将机制（提供了什么能力）和策略（如何使用这些能力）分离。正是因为这种原因才使得Intel不用开发各种各样的游戏吧：-）</p><h4 id="2-2-冯诺依曼结构"><a href="#2-2-冯诺依曼结构" class="headerlink" title="2.2 冯诺依曼结构"></a>2.2 冯诺依曼结构</h4><p>冯诺依曼体系结构的基础是一个<strong>中央处理单元</strong>（CPU），它与<strong>内存</strong>进行交互，负责从<strong>输入设备</strong>接收数据，向<strong>输出设备</strong>发送数据。<br><img src="/images/jsys_05/stored program.jpg" alt=""><br>这个体系结构的核心在于存储程序的概念：计算机内存不仅存储着要进行操作的数据，还存储着指示计算机运行的指令。</p><h3 id="3-CPU的设计与实现"><a href="#3-CPU的设计与实现" class="headerlink" title="3 CPU的设计与实现"></a>3 CPU的设计与实现</h3><h4 id="3-1-CPU的构成"><a href="#3-1-CPU的构成" class="headerlink" title="3.1 CPU的构成"></a>3.1 CPU的构成</h4><p>CPU是计算机体系的核心，负责执行已被加载到指令内存中的指令。这些指令告诉CPU去执行不同的计算，对内存进行读/写操作，以及根据条件跳转去执行程序中其他指令。CPU通过使用三个主要的硬件要素来执行任务：算术逻辑单元（ALU，Aritmetic-Logic Unit），一组寄存器（registers）和控制单元（control unit）。<br><strong>算术逻辑单元（ALU）</strong>：ALU负责执行计算机中所有底层的算术操作和逻辑操作。比如，典型的ALU可以执行的操作包括：将两个数相加；检查一个数是否为整数；在一个数据字（word）中进行位操作；等等。<br><strong>寄存器（Registers）</strong>：CPU的设计是为了能够快速地执行简单计算。为了提高它的性能，将这些和运算相关的数据暂存到某个局部存储器中是十分必要的，这远比从内存中搬进般出要好。因此，每个CPU都配有一个一组高速寄存器（Intelx86_64中的各类寄存器），每个寄存器都能保存一个独立的字<br><strong>控制单元（Contrl Unit）</strong>：计算机指令用二进制代码来表示，通常具有16、32或64位宽。在指令能够被执行之前，须对其解码，指令里面包含的信息向不同的硬件设备（ALU，寄存器，内存）发送信号，指使它们如何执行指令。指令的解码过程是通过某些<strong>控制单元</strong>（Control Unit）。这些控制单元还负责决定下一步需要取出和执行哪一条指令。</p><h4 id="3-2-CPU的执行模型"><a href="#3-2-CPU的执行模型" class="headerlink" title="3.2 CPU的执行模型"></a>3.2 CPU的执行模型</h4><p>CPU操作现在可以被描述成一个<strong>重复的循环</strong>：从内存中取 一条指令（字）：将其解码；执行该指令，取下一条指令：如此往复循环。指令的执行过程中可能包含下面的一些子任务：让ALU计算一些值，控制内部寄存器，从存储设备中读取一个字，或向存储设备中写入一个字。在执行这些任务的过程中，CPU也会计算出下一步该读取并执行哪一条指令。<br><img src="/images/jsys_05/Cycle.jpg" alt=""><br>CPU的<strong>取指-执行循环</strong>（fetch-exec cycle）模型让人不禁联想到<strong>元语言循环</strong>上（eval-apply），不过后者是指称语义的实现（本质是递归求解子表达式）而前者则是一个迭代的物理模型（通过迭代求解子问题，在这里是每一条指令，两者区别从问题的规模看前者可以分解为n层，后者则是2层（在Hack Computer的CPU模型中））<br><img src="/images/jsys_05/exp and memory.jpg" alt=""></p><h4 id="3-3-eval-apply模型"><a href="#3-3-eval-apply模型" class="headerlink" title="3.3 eval-apply模型"></a>3.3 eval-apply模型</h4><p><img src="/images/jsys_05/eval-apply.jpg" alt=""><br>本质是通过将复合过程分解为原子（atom）过程来求解（当然途中可能会对求值环境产生作用）的过程。Evaluator就是另一个程序啦~，之前写过一个简单的<a href="https://github.com/Belyenochi/SchemeREPL/blob/master/js/Scheme.js" title="Scheme Evaluator" target="_blank" rel="noopener">Scheme Evaluator</a>,感兴趣的朋友可以参考实现</p><h3 id="4-图灵机（Turing-Machine）和冯诺依曼结构（von-Neumann-architecture）的大一统"><a href="#4-图灵机（Turing-Machine）和冯诺依曼结构（von-Neumann-architecture）的大一统" class="headerlink" title="4 图灵机（Turing Machine）和冯诺依曼结构（von Neumann architecture）的大一统"></a>4 图灵机（Turing Machine）和冯诺依曼结构（von Neumann architecture）的大一统</h3><p>TM和PL的初学者（比如在下）肯定会有疑问，这些抽象的东机器实非常美，但是是怎么映射到现实世界的呢，今天就以TM为例来谈一谈优雅的理论模型是如何转化到物理的取值-执行循环的（Fetch-Execute cycle）</p><h4 id="4-1-TM"><a href="#4-1-TM" class="headerlink" title="4.1 TM"></a>4.1 TM</h4><p><img src="/images/jsys_05/TM.png" alt=""><br><img src="/images/jsys_05/TM_increase.png" alt=""></p><blockquote><p>In his 1948 essay, “Intelligent Machinery”, Turing wrote that his machine consisted of:<br>…an unlimited memory capacity obtained in the form of <strong>an infinite tape</strong> marked out into squares, on each of which a symbol could be printed. At any moment there is one symbol in the machine; it is called the <strong>scanned symbol</strong>. The machine can alter the scanned symbol, and its behavior is in part determined by that symbol, but the symbols on the tape elsewhere do not affect the behavior of the machine. However, the tape can be <strong>moved back and forth </strong>through the machine, this being one of the elementary operations of the machine. Any symbol on the tape may therefore eventually have an innings.[17] (Turing 1948, p. 3[18])</p></blockquote><p>形象的定义图灵机就是由一条无限长的纸带，字符集，状态集，当前所在位置，状态转移函数。（严格的图灵机定义是由<a href="https://en.wikipedia.org/wiki/Turing_machine" title="七元组" target="_blank" rel="noopener">七元组</a>组成，但和这里的5元组在计算能力上是等价的）<br>图灵机相当于具有标准后进先出语义的双栈PDA ，通过使用一个堆栈来模拟右侧，另一个堆栈来模拟图灵机的左侧，从文法角度看TM的计算能力相当于<strong>递归可枚举</strong>文法。</p><p>Q：图灵机是当前计算机的极限了吗？<br>A：从计算模型上来看是的，实际上到现在为止还没有超出图灵机计算能力范畴的计算机出现，无论是人工神经网络还是遗传算法，“机器学习”和“人工智能”领域的算法都是确定，有穷的，也没有超出图灵机的计算范畴，当然这么多年来人类还是有尝试的，比如<a href="https://zh.wikipedia.org/wiki/%E9%A0%90%E8%A8%80%E6%A9%9F" title="Oracle machine" target="_blank" rel="noopener">Oracle machine</a></p><p>更多关于TM的内容，可以参考Reference，和我之前的blog<a href="https://blog.csdn.net/qq_36936155/article/details/79347364" title=" 理解图灵机及其边界" target="_blank" rel="noopener"> 理解图灵机及其边界</a></p><h4 id="4-2-如何统一"><a href="#4-2-如何统一" class="headerlink" title="4.2 如何统一"></a>4.2 如何统一</h4><p><img src="/images/jsys_05/compare.jpg" alt=""><br>介绍完了TM和冯诺依曼体系，是时候进行mapping了。<br>状态集合state set -&gt; state register<br>纸带tape -&gt; memory（通常意义上是RAM）<br>状态转换函数delta -&gt; 组合电路中的输出（输出至state register相当于进入了另一个状态）<br>当前所在位置current position -&gt; PC<br>字符集character set -&gt; memory中的instruction<br>实际上，取值-执行模型中从内存中取出指令，交给CPU运算然后决定下一条指令的地址（模拟了纸带头读取当前位置，并根据当前位置进行state判断，左移右移或停机），然后改变PC（对应当前所在位置发生改变），然后循环直达到Final State（对应TM中的停机）</p><font color="blue">学过数据结构的朋友会发现图灵机实际上也代表了链式存储，call by position而冯诺依曼的RAM实际上就是Vector，嗯，通过多路选择器随机访问，call by rank，这也说明了图灵机作为理论模型在实际应用中还是需要进行trade off</font><h3 id="5-Reference"><a href="#5-Reference" class="headerlink" title="5 Reference"></a>5 Reference</h3><p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/lecture-notes/lecture23webhan.pdf" title="Evaluation and universal machines The Eval/Apply Cycle Examining" target="_blank" rel="noopener">Evaluation and universal machines The Eval/Apply Cycle Examining</a><br><a href="https://en.wikipedia.org/wiki/Denotational_semantics" title="Denotational_semantics" target="_blank" rel="noopener">Denotational_semantics</a><br><a href="https://en.wikipedia.org/wiki/Turing_machine" title="Turing_machine_wiki" target="_blank" rel="noopener">Turing_machine_wiki</a><br><a href="https://philosophy.stackexchange.com/questions/48865/can-computers-do-things-turing-machines-cant" title="https://philosophy.stackexchange.com/questions/48865/can-computers-do-things-turing-machines-can&#39;t" target="_blank" rel="noopener">can-computers-do-things-turing-machines-cant</a><br><a href="chrome-extension://cdonnmffkdaoajfknoeeecmchibpmkmg/static/pdf/web/viewer.html?file=http%3A%2F%2Fport70.net%2F~nsz%2Fc%2Fc%252B%252B%2Fturing.pdf" title="C++ Templates are Turing Complete" target="_blank" rel="noopener">C++ Templates are Turing Complete</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nand2tetris </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算的要素-第四章小结</title>
      <link href="/2018/08/02/jsys_04_summary/"/>
      <url>/2018/08/02/jsys_04_summary/</url>
      
        <content type="html"><![CDATA[<p><em>Make everything as simple as possible, but bot simpler.—- 阿尔伯特 · 爱因斯坦（1879~1955）</em></p><p>本章关于Hack机器语言的细节都在书里写的很清楚，所以这里不再赘述</p><h3 id="1-register"><a href="#1-register" class="headerlink" title="1 register"></a>1 register</h3><p><img src="/images/jsys_04/register.jpg" alt=""><br><img src="/images/jsys_04/register_detail.jpg" alt=""><br>Hack Computer的register总共只有三种，除了上一章中构建的Memory register以外，分别加了CPU内的Data register和Address/data register，值得一提的是正如上图中所见，M寄存器是特指定RAM[A]所指定的Memory特定位置的存储单元，A寄存器和D寄存器的分工也很明确，A可以用来访存和存储数据，这个数据在书本和项目中的体现就是一个地址，就像指针，我在某个内存单元a中存了内存单元b的地址,如下</p><pre><code>@aA=M</code></pre><p>那么此时A寄存器的作用就是存储数据，只不过这个数据是一个地址，那么何时算存储地址呢？<br>Answer：@a的时候会a的值放入A寄存器此时就是一个地址啦~，因为在汇编器的层面像a这种variable都会对应这一个地址，比如从RAM的第16个地址开始每个存储单元（n位register）对应一个变量，那么这个第xx个地址a对应的地址值</p><h3 id="2-memory-mapping"><a href="#2-memory-mapping" class="headerlink" title="2 memory mapping"></a>2 memory mapping</h3><p>本节一个很重要的亮点就是讲清楚了内存映像（memory mapping），下面就键盘和屏幕两个外设来说明内存映像。</p><h4 id="2-1-Keyboard"><a href="#2-1-Keyboard" class="headerlink" title="2.1 Keyboard"></a>2.1 Keyboard</h4><p><img src="/images/jsys_04/keyboard.jpg" alt=""><br>从图中可以看出，当你按下键盘的那一刻，键盘中的电路选择出你现在按下的键并通过外设的数据线（无线键盘不算），将数据送入计算机对应的端口，实际上这里还触发了一个中断，CPU会根据中断类型对应有处理中断的例程（一般写在BIOS里），然后例程和读取对应端口的输入然后写到相应的内存中去，在本课程中这个阶段忽略了中断以及相应的处理。</p><h4 id="2-2-Screen"><a href="#2-2-Screen" class="headerlink" title="2.2 Screen"></a>2.2 Screen</h4><p><img src="/images/jsys_04/screen_ex.jpg" alt=""><br><img src="/images/jsys_04/screen.jpg" alt=""><br>聊完了键盘再聊聊屏幕，Hack Computer把屏幕分成了512*256个像素点，每个像素点对应存储单元中的一个比特位，这里关于Screen根据选取内存位置选取对应行列书中有详尽的描述，本质是通过修改内存中Screen设备对应的内存映像然后写入Screen设备对应的颜色存储区形成了屏幕上不断变化的效果。更多的细节可以参考下面给出的Reference，<strong>本质上外设的处理都可以基于memory mapping</strong>，包括这里没谈到的鼠标，感兴趣的同学可以玩玩MS的Spy++，利用Hook可以看到对应的鼠标事件消息实际上是基于像素的位置的移动，那么显而易见鼠标外设的内存映像就是对应处于的位置（current position）；-）。</p><h3 id="3-mmap"><a href="#3-mmap" class="headerlink" title="3 mmap"></a>3 mmap</h3><p>mmap是一个符合POSIX标准的Unix 系统调用，它将文件或设备映射到内存中。它是一种内存映射文件 I / O的方法。它实现了请求分页，因为文件内容最初不是从磁盘读取的，根本不使用物理RAM。在访问特定位置之后，以“ lazy ”方式执行来自磁盘的实际读取</p><font color="blue">联想到Linux下的mmap，我觉得有必要深入研究一下它，所以下次专门开一篇文章谈一谈这个话题 </font><h3 id="4-Reference"><a href="#4-Reference" class="headerlink" title="4 Reference"></a>4 Reference</h3><p><a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O" title="memory map From Wikipedia" target="_blank" rel="noopener">memory map from Wikipedia</a><br><a href="https://en.wikipedia.org/wiki/Mmap" title="mmap from Wikipedia" target="_blank" rel="noopener">mmap from Wikipedia</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nand2tetris </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算的要素-第三章小结</title>
      <link href="/2018/08/01/jsys_03_summary/"/>
      <url>/2018/08/01/jsys_03_summary/</url>
      
        <content type="html"><![CDATA[<p><em>It’s a poor sort of memory that only works backward.—- Lewis Carroll</em></p><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h3><p><strong>时钟（Clock）</strong>：其精确的硬件实现通常基于振荡器，其在两个信号值0-1，或称“高-低电平”。两个相邻的信号上升沿称为时钟周期，时钟周期非常重要，所有的时序逻辑都是基于时钟周期的，比如写入内存（读取内存是个时序无关操作），内存值的真实修改（假设当前时钟周期进行写入内存操作）是发生在下一个时钟周期上升沿的时候，可以参见书本的多路转换DFF实现。</p><p><strong>触发器（Filp-Flops）</strong>：此项目采用DFF（Data Filp-Flops），DFF有个时钟输入，根据主时钟信号连续地交变。数据和时钟的输入使得DFF能够实现基于时间行为out（t）=in（t-1）</p><p><strong>寄存器（register）</strong>：这里的寄存器指的是广义上的存储设备，并不仅仅是通常意义上的CPU内的register，它的存储行为是out（t）=out（t-1），也就是说他能够输出他上一个时钟周期的输入，并通过Mux（多路转换器）在条件允许（load控制）时输出至输入信号，这也就说明了它为什么能够维持自身的“状态”</p><p><img src="/images/jsys_03/DFF.jpg" alt=""></p><h3 id="2-Memories"><a href="#2-Memories" class="headerlink" title="2 Memories"></a>2 Memories</h3><p>作为一个程序员，和内存打交道的时候还是很多的，所以让我们来重点看看内存这个家伙的构造。<br><img src="/images/jsys_03/memories.jpg" alt=""><br>如图3.3所示，内存可以通过将很多寄存器堆叠起来形成随机存取RAM单元来实现。随机存取内存（RAM）这个概念由此得来：在RAM上能够随机访问被选择的字而不会受限于访问顺序。也就是说，我们要求内存中的任何字（无论具体物理位置在哪里）都能以相等的速度被直接访问。</p><p><font color="red">说到这里在数据结构课上老师说的，同学们，我们的数组具有随机性啊，随机性，当时还不太清楚这个随机性到底是怎么实现的，那么现在就真相大白了，数组的随机性实际上就是指RAM的随机性（数组可以理解成在内存中连续的片断，连续很重要，实际上在编译器层面对数组的处理也是看成一段连续的内存）</font><br>那么现在让我们一起看看RAM的随机性是如何实现的；-)</p><p>注意图3.3的输入管脚有一个address，那么实际上<strong>内存是由8个16位寄存器构成的</strong>（假定），那么在address处输入的就是3位的电信号，聪明的大家已经想到了，通过3位的电信号经过DMux（多路选择器）选择出一个唯一的8位寄存器位置，比如输入010，那么第一个0代表选择了前二分之一个内存区域（以寄存器数量为单位），010-&gt;前四个中的后两个中的第一个，完美的命中了第三个寄存器位置，你看这就完成了内存寻址。。是不是没有你想的那么复杂，当然真实环境下的内存肯定比这里来的复杂，但是这里探索的是模型和原理，具体的细节欢迎大家在评论下面补充说明。</p><h3 id="3-时序芯片和逻辑芯片的比较"><a href="#3-时序芯片和逻辑芯片的比较" class="headerlink" title="3 时序芯片和逻辑芯片的比较"></a>3 时序芯片和逻辑芯片的比较</h3><p><img src="/images/jsys_03/compare.jpg" alt=""><br>前面说到的组合逻辑芯片的输出随其输入的变化而变化，而不去考虑时间。相比之下，时序结构中包含的DFF保证了它们的输出变化仅仅发生在一个时钟周期到下一个时钟周期的转换点上（比如上升沿），而不在时钟周期内。实际上，我们允许时序芯片在时钟周期之内出现不稳定的状态，但是必须保证在下一个时钟周期的起始点，其输出值是正确的</p><p><strong>时序芯片输出这种“离散化（discretization）”过程有个重要作用：它能被用来对整个计算机系统进行同步。</strong><br>假设指示ALU计算x+y，x和y分别属于距离ALU远近程度不一的RAM（远近程度说明了他们有效的电信号到达ALU的时间），那么由于他俩在不同时刻到达ALU而ALU作为一个组合逻辑毫无时序的概念，它只会不停的从输入管脚读取数据，那么在ALU的两端输入达到稳定前，它只会不断的产生垃圾值。那么如何解决这个问题呢？既然ALU会在某个时间点给出正确的输出并且达到稳定（持续的正确输出..个人理解），在此前是输出垃圾值，那么就可以将ALU的输出连接至一个时序逻辑设备，这个设备在时钟上升沿的时候读取来自ALU的输入，那么如何保证此时读取的输入是正确的呢？这就涉及到了计算机时钟的设定，规定计算机时钟周期的长度要比1个比特在计算机系统中两个物理距离最长的芯片之间传输的时间稍长。这样就<br>能在时间上保证时序芯片得到了有效的输入值（在下个时钟周期的上升沿）。</p><p>通过时序芯片    ，可以将一个个独立的硬件同步为一个协调统一的系统。（第五章小结会有后续说明）</p><h3 id="4-本章架构图"><a href="#4-本章架构图" class="headerlink" title="4 本章架构图"></a>4 本章架构图</h3><p><img src="/images/jsys_03/architecture.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nand2tetris </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算的要素-第二章小结</title>
      <link href="/2018/07/31/jsys_02_summary/"/>
      <url>/2018/07/31/jsys_02_summary/</url>
      
        <content type="html"><![CDATA[<p><em>Counting is the regligion of this generation, it’s hope and salvation —- Gertrude Stein(1874-1946)</em>  </p><h3 id="1-为什么采用2-补码（2’s-complement）作为计算机的编码？"><a href="#1-为什么采用2-补码（2’s-complement）作为计算机的编码？" class="headerlink" title="1 为什么采用2-补码（2’s complement）作为计算机的编码？"></a>1 为什么采用2-补码（2’s complement）作为计算机的编码？</h3><p>稍微有一点计算机基础的同学都知道负数可以用正数的补码+1表示，事实上这是非常重要的，下面总结用补码表示n-位二进制系统具有以下属性：</p><ol><li>系统能对所有2的n次方个有符号数进行编码，最大的数和最小的数分别为2的n-1次方减1和负2的n-1次方</li><li>所有正整数的编码首位都是0</li><li>所有负整数的编码首位都是1</li><li>为了通过x的编码获得-x的编码，所有最右边的0和    从左边起的第一个1保持不变，然后将剩余的位取反。等价的捷径就是，对x的所有位取反，然后再加1，<strong>这个方案更容易在硬件中实现</strong>。<br>这种表示法使得任何两个用补码表示的有符号数的加法与正数的加法完全相同，比如（1110）+（1101）=1011（丢掉溢出位），刚好等于-5，而减法被等价为x - y = x + （-y）</li></ol><h3 id="2-ALU的原理以及实现"><a href="#2-ALU的原理以及实现" class="headerlink" title="2 ALU的原理以及实现"></a>2 ALU的原理以及实现</h3><p>通过2’s complement我们可以发现现在已经可以执行几乎任何算术（加减）和逻辑（与或非多路转换等）操作了，那么这时候就需要通过封装来使用他们，实际上这又是一种通过抽象简化设计的体现，ALU从此应运而生了。<br>事实上在《计算的要素艺术中》已经对ALU的原理与实现有充分的说明，<strong>究其本质组合逻辑是对真值表的一个物理映射。</strong></p><h3 id="3-计算机系统结构的8个伟大思想"><a href="#3-计算机系统结构的8个伟大思想" class="headerlink" title="3 计算机系统结构的8个伟大思想"></a>3 计算机系统结构的8个伟大思想</h3><p>事实上，在任何计算机中，软硬件平台的整体功能都是由ALU和运行在其上的操作系统共同决定的。因此，当设计新的系统时，ALU应该实现多少功能，本质上是个性价比的问题。一般的原则是算术和逻辑操作的硬件实现成本较高，但是性能较好。（《计算的要素》中对ALU并没有实现乘除和浮点运算是对复杂度的一个权衡，对乘除和浮点运算会在软件层面给予实现），那么让我来谈谈计算机系统结构中的8个伟大思想：</p><ul><li>面向摩尔定律的设计</li><li>使用抽象简化设计</li><li>加速大概率事件</li><li>通过并行提高性能</li><li>通过流水线提高性能</li><li>通过预测提高性能</li><li>建立存储器层次</li><li>通过冗余提高可靠性（在数据库中经常出没的冗余备份等等）</li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>《计算的要素》<br>《计算机组成与设计-软件/硬件接口》</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nand2tetris </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算的要素-第一章小结</title>
      <link href="/2018/07/30/jsys_01_summary/"/>
      <url>/2018/07/30/jsys_01_summary/</url>
      
        <content type="html"><![CDATA[<p><em>Such simple things,And we make of them something so complex it defeats us ,Almost. —-John Ashbery(1927)</em></p><h3 id="1-OverView"><a href="#1-OverView" class="headerlink" title="1 OverView"></a>1 OverView</h3><p><img src="/images/jsys_01/ClassOverview.jpg" alt=""><br>以上是课程的学习，内容，让我们bottum up搭建一个计算机吧!</p><h3 id="2-什么是逻辑门（logic-Gate）？"><a href="#2-什么是逻辑门（logic-Gate）？" class="headerlink" title="2 什么是逻辑门（logic Gate）？"></a>2 什么是逻辑门（logic Gate）？</h3><p>在谈论什么是逻辑门之前，我们得先谈谈布尔代数，因为计算机硬件基于二进制数据的表示和处理，所以布尔代数成了计算机中事实上不可或缺的理论根基。<br>学过离散数学的朋友肯定对真值表不陌生，事实上逻辑门就是由布尔函数的物理具象化，输入和输出就是真值表的变量，如果布尔函数f有n个输入变量，返回m个二进制的结果，那么用来实现这个函数f的门将会有n个输入管脚（input pins）和m个输出管脚（ouput pins） 。当我们把一些值从输入管脚输入，它的内部结构即逻辑门<br>会计算然后输出对应的结果值。<br><img src="/images/jsys_01/logicGate.jpg" alt=""></p><h3 id="3-如何使用逻辑门"><a href="#3-如何使用逻辑门" class="headerlink" title="3 如何使用逻辑门"></a>3 如何使用逻辑门</h3><p><img src="/images/jsys_01/implementOfGate.jpg" alt=""><br>对于任何给定的逻辑门，我们都能够从外部和内部两个不同方面进行观察，图1.4中右边的图给出了门的内部结构（或称为内部实现），而左边部分仅仅显示了门的外部接口（interface），也就是输入和输出管脚。内部结构仅仅与门电路的设计者相关，而外部结构则是其他设计者所关心的（也就是外部结构也就是我们常常使用的黑盒抽象，只关心输入输出），他们仅仅使用门电路的抽象而不去关心其内部结构。<br>下面总结两点关于逻辑设计的要素：</p><ol><li>虽然逻辑设计（门电路设计者）的基本功能可以通过不同的的方式实现其外部接口，但从效率的角度上来说，<strong>基本原则</strong>是用尽可能少的门来显示尽可能多的功能。</li><li>给定门的描述（外部接口），通过应用已经实现的门，找到有效的方法来实现它。<br><strong>因为本课程后续部分采用了HDL语言，所以这里简单的解释HDL语言：</strong><br>chips(芯片)的HDL定义包括header部分和parts部分。<br>Header部分描述了芯片的接口(interface)，也就是芯片的名称、输入和输出管脚。<br>Pars部分描述了所有底层电路的名称和拓扑结构，这些电路是构成该芯片的基本部分，每个部分用一个statement(语句)来表示，它描述了该部分的名称与其他部分的连接方式。<br>为了简单明了的编写这些语句，HDL程序员必须有内在模块的接口文档，体现在project中就是注释了。<br>形如part’s pin name = chip’s pin name的含义是将芯片内部的管脚与外部管教相连，如此实现了芯片的输入输出。<br>更多关于HDL程序设计的内容可以参考《计算的要素》附录部分。</li></ol><h3 id="4-为什么使用逻辑门"><a href="#4-为什么使用逻辑门" class="headerlink" title="4 为什么使用逻辑门"></a>4 为什么使用逻辑门</h3><p>之前曾谈到计算机的计算模型采用了布尔代数，从图灵机的纸带存储符号,到冯诺依曼体系结构的memory都采用了0,1作为数据的表示形式，其根本是高效和简单（当然lambda calculus不是这么做的，你可以自己定义数字如church numerals，函数等，因为是抽象模型所以理解和运算起来没有0，1在实际应用中直接，但事实上无论是TM,lambda calculus，冯诺依曼体系结构都是等价的，可以说前两者是等价的计算模型，后者是物理实现模型，本质都是对计算的建模且等价！）</p><h3 id="5-各种逻辑门（project中的图示）"><a href="#5-各种逻辑门（project中的图示）" class="headerlink" title="5 各种逻辑门（project中的图示）"></a>5 各种逻辑门（project中的图示）</h3><p>项目地址<a href="https://github.com/Belyenochi/nand2tetris" target="_blank" rel="noopener">https://github.com/Belyenochi/nand2tetris</a></p><ol><li>And<br><img src="/images/jsys_01/And.png" alt=""></li><li>And16<br><img src="/images/jsys_01/And16.png" alt=""></li><li>Dmux<br><img src="/images/jsys_01/DMux.png" alt=""></li><li>DMux4Way<br><img src="/images/jsys_01/DMux4Way.png" alt=""></li><li>DMux8Way<br><img src="/images/jsys_01/DMux8Way.png" alt=""></li><li>Mux<br><img src="/images/jsys_01/Mux.png" alt=""></li><li>Mux4Way16<br><img src="/images/jsys_01/Mux4Way16.png" alt=""></li><li>Not<br><img src="/images/jsys_01/Not.png" alt=""></li><li>Or<br><img src="/images/jsys_01/Or.png" alt=""></li><li>Xor<br><img src="/images/jsys_01/Xor.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nand2tetris </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
