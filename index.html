<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>The Tao of Jason</title>
	<link rel="stylesheet" href="/css/style.css" />
	
      <link rel="alternate" href="/atom.xml" title="The Tao of Jason" type="application/atom+xml">
    
</head>

<body>

	<header class="header">
		<nav class="header__nav">
			
				<a href="/archives" class="header__link">Archive</a>
			
				<a href="/tags" class="header__link">Tags</a>
			
				<a href="/atom.xml" class="header__link">RSS</a>
			
		</nav>
		<h1 class="header__title"><a href="/">The Tao of Jason</a></h1>
		<h2 class="header__subtitle"></h2>
	</header>

	<main>
		



	<article>
	
		<h1><a href="/2021/05/19/love/">love</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2021-05-19</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/和黑猫警长的日常/">和黑猫警长的日常</a>
			</span>
		
	</div>

	

	
		<p><em>情不知其所起，一往而情深</em></p>
<p>今天是519，我在思考我有多喜欢你，以及我可能没有告诉你的一些东西，所以我想赶在520之前让你知道我是多么的喜欢你。</p>
<p>认识你到今天已经过去了一个多月，我仍然记得刚认识你那会你让我做不靠谱网恋选择题的样子哈哈哈，但是让我再去选一次我还是会做出同样的选择，我觉得缺乏了解仅仅凭着一些标签快速在一起的感情并不是我追求的，随着后面一天天的观察，慢慢的我对你的印象在改变，无论如何是一个憨憨可爱的女孩子呢，是我可以让我鼓起勇气表白，努力克服距离，克服内心的恐惧以及自卑的女孩子，所以至少这一次，我不想错过。</p>
<p>你总是说要减肥hhh，不过在我心里无论你吃了多少麻辣香锅，或者是深夜夜宵，你始终是一个独立思考，善良随和，憨头憨脑对待这个世界的可爱女孩子（参考憨八龟），我想无论是一天把吃甜瓜吃完咳嗽不停，看到蟑螂蜘蛛直接挂机，白天不吃饭半夜暴饮暴食的你，还是在我下班后对我说お疲れ，在我演讲的时候替我加油的你，亦或者是在我工作的时候不停磨人的你，我都非常喜欢。</p>
<p>这应该是我这几年来最开心的两周，心里有了牵挂，感觉福报也不过如此哈哈哈，至少你一直在我的身边，有了你之后我明显感觉自己更加努力了（各种意义上），我想我只是想在你需要我的时候我都帮你，我能够变得更强快点结束异地。我也好想去你的城市，记录你那里的一草一木，甚至是小区里的便利店。如果我可以像熟悉我的城市一样熟悉你的城市，当你和我说你在做什么时，我就能生动地想象出来，就像你只是出门去了，晚上就会回来一般，就不会那么想你。好想带你去北海道滑雪，再带你去看一看旭川动物园，还有好多地方想和你一块去！想要一直陪着你！想要和你见面！！！！！！！</p>

	

	

</article>




	<article>
	
		<h1><a href="/2020/04/23/kubernetes/">围绕kubernetes的设计与源码探索之旅</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2020-04-23</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/kubernetes/">kubernetes</a>
			</span>
		
	</div>

	

	
		<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在kubernetes相关基础设施领域工作将近一年时间了，期间对kubernetes以及相关组件乃至整个云计算的过去，当下与未来有了一定思考，趁此离职学习期间将这一年学到的东西整理一下，这次探索因为我在实际的工业界实践过程中已经有了自顶向下的实践，所以我决定这一次自底向上的去进行探索（当然隔壁的数据库实现也会慢慢更新的：），为了区别已经让我厌烦的XXX源码讲解我决定使用结合源码片段的自问自答形式（感谢little系列…感谢Friedman）。</p>
<h3 id="适宜人群"><a href="#适宜人群" class="headerlink" title="适宜人群"></a>适宜人群</h3><ul>
<li>了解kubernetes的使用以及基本概念（CRI,CNI,CSI）</li>
<li>有一定的kernel知识（进程，内存，IO子系统）</li>
<li>可以接受我有时候对具体细节实现浅尝辄止的习惯（但是一般我都会给一个更好的说明链接，因为有一些概念我自己也只是有所了解</li>
</ul>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>（初版）</p>
<ol>
<li>kubernetes（v1.18.2）<ul>
<li>kubelet</li>
<li>kube-proxy</li>
<li>kube-apiserver</li>
<li>kube-controllermanager</li>
<li>kube-scheduler</li>
</ul>
</li>
<li>etcd（v3.4.3）</li>
<li>calico（v3.12）</li>
<li>runc（v1.0-rc10） </li>
</ol>

	

	

</article>




	<article>
	
		<h1><a href="/2020/03/02/alphaDB/">我有一个大胆的想法之单手撸数据库(I)</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2020-03-02</span><br />
		
		
	</div>

	

	
		<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>回想这两年自己为了在弱鸡学校活出个计科生样来，写过简单的OS（入门），设计过数据中心的网络架构（入门级应用），唯独在数据库领域我还没有入门，作为计科毕业的学生我真的汗颜，另外实习加毕业快两年的经过也让我明白了自己对职业生涯的发展更清晰了一些，所以这篇文章就是一个小菜鸡记录自己实现数据库的一些心得体会，也是为了能更好的理解业界的一些实现，比如看etcd的设计时我对mvcc的理解是是哦，我懂了，然后过两天又忘了，典型的掌握无能啊摔（。</p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>本着一口不能吃一个胖子的自我认知，我决定实现数据库参考知乎某位前辈的步骤：</p>
<ul>
<li><strong>阶段1: 无事务, 单线程, 仅存在于内存的数据库</strong></li>
<li><strong>阶段2: 无事务, 单线程, 不可靠的磁盘数据库</strong> </li>
<li><strong>阶段3: 单事务, 单线程, 可靠的磁盘数据库</strong></li>
<li><strong>阶段4: 多事务, 多线程, 可靠的数据库</strong></li>
</ul>
<p>争取在2021年前完成，也算是圆了我大学时候的一个梦。</p>

	

	

</article>




	<article>
	
		<h1><a href="/2019/05/16/suibi/">离职小结——2019/5/16/1:39</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2019-05-16</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/随想/">随想</a>
			</span>
		
	</div>

	

	
		<p>&emsp;在麦穗实习了8个月了，说起来还真的是很快，从对工业界一无所知到现在的略知一二一路走来同事，老大，老板都给予了很大的帮助，可以说这里拥有一个优秀的创业公司的基因，理性判断且关注下属换位思考的老板，帮助小老弟成长的老大，以及带领我从小白到初级工程师的同事，但是夜深人静的时候我时常在想自己追求的到底是什么，从刚进麦穗那会的前端，到后来的devops，我一直在问自己一个问题，我真的热爱这份工作吗？我真的可以为他奋斗3，5年乃至10年吗？</p>
<p>&emsp;在越来越繁重的需求迭代中，我感觉自己的工作状态一天不如一天，我知道是我内心开始不认同我现在做的大部分事情了，我失去了对工作的热情，那么我感兴趣的到底是什么呢？对比再三我还是认为更底层的工作更适合我，以及我需要更多技术实践的机会，所以我选择了离开麦穗，说起来与麦穗的大家伙生活了半年多没有感情是假的，因为我这个人在学校比较自闭，在麦穗的半年多让我感受到了在学校三年来不曾有过的情切感，以及同事的信任，互相帮助，可以说是麦穗的实习成就了现在我，对于我职业生涯发展也起了很大的帮助，也正是在麦穗的期间让我改掉了很多不好的习惯，这所有的一切我都会珍藏在心里，并且怀着对过去的感激继续勇往直前。</p>
<p>&emsp;未来怎么样，这个决定对我到底有什么影响说起来我真的很难预测，但我觉得这条路是我摔了很多跟头以后发现的，我不想因为觉得太难了不配等其他原因说服自己，但我不会忘记是麦穗给我这个机会让我尝试各种想法，给我摔跟头的机会，我也不会忘记luyi姐在我遭遇工作瓶颈的时候顺毛摸，理性分析，火火对我思维模式以及责任感的告诫，小灰对我代码风格习惯的指导，扬哥给我提供各种实践的机会以及指导（甚至一开始还教我怎么写scala的工程代码），老王给予我前端方面的指导以及一些职场见解，少爷以身作则的向我展现了一个优秀的程序员是不需要加班的，超哥在大局方面的见解，vv姐对我生活方面的建议，书记让我认识到了男人是如何能屈能伸的，法师向我展现了上一代程序员的职业素养以及责任感，以及月月、盛宙、敏材与我分享见解的时光，这一切的一切都是我在麦穗收获的珍宝，感谢麦穗这个大家庭的所有人，衷心祝愿麦穗能在ai招聘领域成为独角兽，发展的越来越好，也衷心祝愿公司的每一个人能够身体健康，生活幸福！大家都是最棒的！</p>

	

	

</article>




	<article>
	
		<h1><a href="/2019/04/14/biji-os-02/">趣谈Linux操作系统笔记02（对应06-08）</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2019-04-14</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/os/">os</a>
			</span>
		
	</div>

	

	
		<h3 id="0-计算机的工作模式"><a href="#0-计算机的工作模式" class="headerlink" title="0 计算机的工作模式"></a>0 计算机的工作模式</h3><h4 id="0-1-硬件图和计算机的逻辑图"><a href="#0-1-硬件图和计算机的逻辑图" class="headerlink" title="0.1 硬件图和计算机的逻辑图"></a>0.1 硬件图和计算机的逻辑图</h4><p><img src="/images/biji_os_02/1.png" alt=""></p>
<h4 id="0-2-cpu的组成"><a href="#0-2-cpu的组成" class="headerlink" title="0.2 cpu的组成"></a>0.2 cpu的组成</h4><ol>
<li>运算单元</li>
<li>数据单元</li>
<li>控制单元<br><img src="/images/biji_os_02/2.png" alt=""></li>
</ol>
<h3 id="1-x86架构"><a href="#1-x86架构" class="headerlink" title="1 x86架构"></a>1 x86架构</h3><h4 id="1-1-历史"><a href="#1-1-历史" class="headerlink" title="1.1 历史"></a>1.1 历史</h4><p>x86泛指一系列由英特尔公司开发处理器的架构，这类处理器最早为1978年面市的“Intel 8086”CPU。<br>该系列较早期的处理器名称是以数字来表示80x86。由于以“86”作为结尾，包括Intel 8086、80186、80286、80386以及80486，因此其架构被称为“x86”。由于数字并不能作为注册商标，因此Intel及其竞争者均在新一代处理器使用可注册的名称，如Pentium。现时英特尔将其称为IA-32，全名为“Intel Architecture, 32-bit”，一般情形下指代32位的架构。</p>
<h4 id="1-2-8086的原理"><a href="#1-2-8086的原理" class="headerlink" title="1.2 8086的原理"></a>1.2 8086的原理</h4><p>8086的cpu包含以下几个部分：</p>
<ul>
<li>数据单元：AX、BX、CX、DX、SP、BP、SI、DI寄存器</li>
<li>控制单元：IP（指令指针寄存器，指向代码段中下一条指令的位置 ）、CS（代码段寄存器（Code Segment Register），通过它可以找到代码在内存中的位置）、DS（数据段的寄存器，通过它可以找到数据在内存中的位置）、SS（栈寄存器）、ES<br><img src="/images/biji_os_02/3.png" alt=""><h4 id="1-3-课堂练习"><a href="#1-3-课堂练习" class="headerlink" title="1.3 课堂练习"></a>1.3 课堂练习</h4>Q: mov, call, ret, jmp, int, add, or, xor, shl, ahr, push, pop, inc, dec, sub, cmp指令含义？<br>A: </li>
<li>mov: 将第二个操作数（源操作数）复制到第一个操作数（目标操作数）。源操作数可以是立即值，通用寄存器，段寄存器或存储器位置; 目标寄存器可以是通用寄存器，段寄存器或存储器位置。两个操作数必须大小相同，可以是字节，字，双字或四字。<font color="red">MOV指令不能用于加载CS寄存器。尝试这样做会导致无效的操作码异常（#UD）。要加载CS寄存器，请使用far JMP，CALL或RET指令。</font></li>
<li>call : 保存将堆栈和分支上的信息链接到使用目标操作数指定的调用过程的过程。目标操作数指定被调用过程中第一条指令的地址。操作数可以是立即值，通用寄存器或存储器位置。</li>
<li>ret : 将程序控制流转移到位于堆栈顶部的返回地址。地址通常由CALL指令放在堆栈上，并返回到CALL指令后面的指令。</li>
<li>jmp : 将程序控制流转移到指令流中的不同点而不记录返回信息。<br>int : 调用中断</li>
<li>add : 添加目标操作数（第一个操作数）和源操作数（第二个操作数），然后将结果存储在目标操作数中。目标操作数可以是寄存器或存储器位置; 源操作数可以是立即数，寄存器或存储器位置。（但是，在一条指令中不能使用两个存储器操作数。）当立即值用作操作数时，它将符号扩展为目标操作数格式的长度。ADD指令执行整数加法。它评估有符号和无符号整数操作数的结果，并设置CF和OF标志，分别表示有符号或无符号结果中的进位（溢出）。SF标志指示签名结果的符号</li>
<li>or : 在目标（第一个）和源（第二个）操作数之间执行按位包含OR运算，并将结果存储在目标操作数位置。源操作数可以是立即数，寄存器或存储器位置; 目标操作数可以是寄存器或存储器位置。（但是，在一条指令中不能使用两个存储器操作数。）如果第一和第二操作数的相应位都为0，则OR指令结果的每一位都设置为0; 否则，每个位都设置为1。</li>
<li>xor : 对目标（第一个）和源（第二个）操作数执行按位异或（XOR）运算，并将结果存储在目标操作数位置。源操作数可以是立即数，寄存器或存储器位置; 目标操作数可以是寄存器或存储器位置。（但是，一条指令不能使用两个存储器操作数。）如果操作数的相应位不同，则结果的每一位都为1; 如果相应的位相同，则每个位为0。</li>
<li>shl : 逻辑左移</li>
<li>shr :逻辑右移</li>
<li>push : 堆栈指针寄存器的值递减，然后将源操作数存储在堆栈顶部</li>
<li>pop:  将值从堆栈顶部加载到使用目标操作数（或显式操作码）指定的位置，然后递增堆栈指针。目标操作数可以是通用寄存器，存储器位置或段寄存器。</li>
<li>inc: 将1添加到目标操作数，同时保留CF标志的状态。目标操作数可以是寄存器或存储器位置。该指令允许更新循环计数器而不会干扰CF标志。（使用立即操作数为1的ADD指令执行更新CF标志的增量操作。）</li>
<li>dec: 从目标操作数中减去1，同时保留CF标志的状态。目标操作数可以是寄存器或存储器位置。该指令允许更新循环计数器而不会干扰CF标志。（要执行更新CF标志的减量操作，请使用立即操作数为1的SUB指令。）</li>
<li>sub : 从第一个操作数（目标操作数）中减去第二个操作数（源操作数），并将结果存储在目标操作数中。目标操作数可以是寄存器或存储器位置; 源操作数可以是立即数，寄存器或内存位置。（但是，在一条指令中不能使用两个存储器操作数。）当立即值用作操作数时，它将符号扩展为目标操作数格式的长度。SUB指令执行整数减法。它评估有符号和无符号整数操作数的结果，并设置OF和CF标志，分别表示有符号或无符号结果中的溢出。SF标志指示签名结果的符号。</li>
<li>cmp: 比较第一个源操作数和第二个源操作数，并根据结果设置EFLAGS寄存器中的状态标志。通过从第一个操作数中减去第二个操作数，然后以与SUB指令相同的方式设置状态标志来执行比较。当立即值用作操作数时，它将符号扩展为第一个操作数的长度。</li>
</ul>
<h3 id="2-Linux内核启动过程（bootloader）"><a href="#2-Linux内核启动过程（bootloader）" class="headerlink" title="2 Linux内核启动过程（bootloader）"></a>2 Linux内核启动过程（bootloader）</h3><h4 id="2-1-启动过程描述"><a href="#2-1-启动过程描述" class="headerlink" title="2.1 启动过程描述"></a>2.1 启动过程描述</h4><p><img src="/images/biji_os_02/4.png" alt=""></p>
<ol>
<li>主板加电，cpu从rom中读取BIOS执行（通过将CS 设置为 0xFFFF，将 IP 设置为 0x0000，跳转到ROM中进行初始化）</li>
<li>BIOS做完计算机硬件自检和初始化后，会选择一个启动设备（例如软盘、硬盘、光盘等）</li>
<li>将 boot.img 从启动设备的主引导扇区(MBR)加载到内存中的 0x7c00（从现在开始进入bootloader，grub2为例）</li>
<li>boot.img加载core.img的第一个扇区diskboot.img（diskboot.img复杂加载core.img的其余模块）</li>
<li>diskboot.img通过启用分段和分页将系统从实模式切换到保护模式增大以寻址空间（为了解压缩lzma_decompress.img）<br><img src="/images/biji_os_02/5.png" alt=""></li>
<li>解压缩kernel.img,跳转到kernel.img开始执行</li>
<li>grub load config解析操作系统配置文件（grub.conf），经过一系列的系统配置初始化函数，最后调用grub_command_execute启动内核</li>
</ol>
<h4 id="2-2-启动过程小结图"><a href="#2-2-启动过程小结图" class="headerlink" title="2.2 启动过程小结图"></a>2.2 <font color="red">启动过程小结图</font></h4><p><img src="/images/biji_os_02/6.png" alt=""><br><img src="/images/biji_os_02/7.png" alt=""><br><img src="/images/biji_os_02/8.png" alt=""></p>
<h3 id="3-内核初始化"><a href="#3-内核初始化" class="headerlink" title="3 内核初始化"></a>3 内核初始化</h3><h4 id="3-1-内核初始化流程"><a href="#3-1-内核初始化流程" class="headerlink" title="3.1 内核初始化流程"></a>3.1 内核初始化流程</h4><p><img src="/images/biji_os_02/9.png" alt=""></p>
<ol>
<li>调用内核初始化函数start_kernel()</li>
<li>初始化进程列表，创建0号进程，这是唯一一个没有通过 fork 或者 kernel_thread 产生的进程，是进程列表的第一个</li>
<li>调用trap_init()初始化中断门</li>
<li>调用mm_init()初始化内存管理模块</li>
<li>调用sched_init()初始化调度模块</li>
<li>调用vfs_caches_init()初始化基于内存的文件系统rootfs</li>
<li>调用rest_init()来做其他方面的初始化<h4 id="3-2-系统调用流程"><a href="#3-2-系统调用流程" class="headerlink" title="3.2 系统调用流程"></a>3.2 系统调用流程</h4><img src="/images/biji_os_02/10.png" alt=""></li>
</ol>
<h4 id="3-3-rest-init"><a href="#3-3-rest-init" class="headerlink" title="3.3 rest_init()"></a>3.3 rest_init()</h4><ul>
<li>调用kernel_thread(kernel_init, NULL, CLONE_FS)创建第1号进程（用户态所有进程的祖先）</li>
<li>调用kernel_thread(kernel_init, NULL, CLONE_FS|CLONE_FILES)创建2号进程（用户态所有进程的祖先）</li>
</ul>
<font color="red">这里的函数 kthreadd，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。</font>

<h4 id="3-4-小结流程"><a href="#3-4-小结流程" class="headerlink" title="3.4 小结流程"></a>3.4 小结流程</h4><p><img src="/images/biji_os_02/11.png" alt=""></p>
<h3 id="4-引用链接"><a href="#4-引用链接" class="headerlink" title="4 引用链接"></a>4 引用链接</h3><p><a href="https://zh.wikipedia.org/wiki/X86" title="x86" target="_blank" rel="noopener">x86</a><br><a href="https://www.felixcloutier.com/x86/" title="x86 and amd64 instruction reference" target="_blank" rel="noopener">x86 and amd64 instruction reference</a></p>

	

	

</article>




	<article>
	
		<h1><a href="/2019/04/06/biji-os-01/">趣谈Linux操作系统笔记01（对应03-06）</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2019-04-06</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/os/">os</a>
			</span>
		
	</div>

	

	
		<h3 id="1-操作系统简介"><a href="#1-操作系统简介" class="headerlink" title="1 操作系统简介"></a>1 操作系统简介</h3><h4 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h4><p><img src="/images/biji_os_01/WX20190406-221620@2x.png" alt=""><br>在谈论什么是操作系统前我们可以回忆一下十几年前买电脑的过程，引用文章的栗子就是”那时候买电脑，经常是这样一个情景：三五个哥们儿一起来到电脑城，呼啦呼啦采购了一大堆硬件，有密密麻麻都是针脚的<strong>CPU</strong>；有铺满各种复杂电路的一块板子，也就是<strong>主板</strong>；还需要买块<strong>显卡</strong>，用来连接显示器；还需要买个<strong>网卡</strong>，里面可以插网线；还要买块<strong>硬盘</strong>，将来用来存放文件；然后还需要一大堆<strong>线</strong>，将这些设备和主板连接起来；最终再来一个<strong>鼠标</strong>，一个<strong>键盘</strong>，还有一个<strong>显示器</strong>。设备差不多啦，准备开整！”,那么此时如何将这些硬件连接起来并使用户能够在不知道硬件的情况下进行操作呢（比如总不能让用户手动操作强行写入显示器所在内存使显示器显示字符），<strong>没错这层硬件细节与用户使用普通软件的抽象就是操作系统</strong>，</p>
<h4 id="1-2-为什么需要操作系统"><a href="#1-2-为什么需要操作系统" class="headerlink" title="1.2 为什么需要操作系统"></a>1.2 为什么需要操作系统</h4><p>其实回答这个问题只需要看一看没有操作系统的时候，实际上，最早的计算机没有操作系统（这里我们假设最早的计算机是ENIAC,实际上这个定义一直有争议这里只是举例）; 他们是一次负责一个程序的大型机器。出于这个原因，他们并不真正需要操作系统。事实上，最早的计算机要求用户物理连接和断开插头板上的电线以检索计算。但是如果你没有操作系统，你可以让你的电脑做任何事吗？（那时候说的程序员都还是指拔插连接线用以实现运算的女性呢～）</p>
<p>是。但是你还有很多工作要做。如果没有操作系统使用和执行标准的系统方法来运行计算机，那么您就会处于编写必须告诉计算机确切操作的代码（或程序）的位置。因此，如果要在文字处理程序中键入文档，则必须从头创建代码，告诉计算机响应键盘上按下的每个字符。然后，您必须编写一个代码，告诉计算机这些响应必须如何转换为屏幕。您必须告诉您的计算机如何绘制您想要的角色！想想你的文字处理程序有的每一个选项或可能性。您必须直接在硬盘上为每一个代码编写代码。</p>
<p>文中说<strong>操作系统其实就像一个软件外包公司，其内核就相当于这家外包公司的老板。所以接下来的整个课程中，请你将自己的角色切换成这家软件外包公司的老板，设身处地地去理解操作系统是如何协调各种资源，帮客户做成事情的。</strong>，那么其实这个类比隐含了默认场景，完整的类比应该是，客户尽是一些不具备软件开发能力的公司，此时客户看到了某款爆款软件”拼西西”的成功，心急如焚的想要构建一个高并发、高可用的”拼东东”东东，那么问题来了，公司内部没有现成的基础设施（消息队列、缓存等），更重要的是连个懂业务开发的技术人员都没有，我作为客户好急啊～从0-1完成传统企业转型臣妾做不到啊，然而我转念一想我其实不需要会开发我只需要一个中间层懂开发就行了，我输入业务输出的是计算机相应的程序就行，好了这不隔壁老张开了家软件外包公司帮我屏蔽了软件开发的抽象（对应到os就是输入输出设备，进程，存储等抽象），那么我就能安心的进行业务拓展了呢。（可以说广大应用软件正是站在巨人（操作系统）的肩膀上）</p>
<p><font color="red"><em>脑洞一下，如果说图灵机是没有os的计算机（其实是一种计算模型，当然也可以称为计算机），那么我们来思考一下图灵机适合现代使用吗？</em></font><br>&nbsp;</p>
<p><font color="blue">&nbsp;&nbsp;小王想要看漫画，请问您从图灵机抽象能给我显示一个小姐姐图片吗，这当然不行，虽然图灵机的实现可以支持各种逻辑运算结构但是图灵机并没有规定如何将纸带连接到显示屏（缺少了硬件驱动管理等），实际上之前说的早期的计算机确实是图灵机的一种实现，现在他有了一个响当当的名号<strong>冯诺伊曼体系结构</strong>，但是这种体系结构只是为os打好了硬件基础，在这个体系结构之上的抽象才是操作系统。那么现在我们知道图灵机距离适合现在使用差了两个层次，第一层是现代的体系结构作为图灵机的实现，第二层是操作系统的介入屏蔽硬件体系结构并提供一些好用的基础工具（比如进程抽象)</font></p>
<p><font color="red"><em>继续脑洞等价于图灵机的理论模型最知名的应该属于图灵师父在图灵机理论发表之前发布的lambda calculus，这是一种纯数学的模型（理解起来需要花费一点时间但是很有意思，推荐可以去看看计算语义学方面的书），上面我的脑洞在这里可以翻译为我能用数学函数运算看动漫吗？</em></font><br>&nbsp;</p>
<p><font color="blue">&nbsp;&nbsp;这次我觉得这次应该没人质疑了吧，当然你可能会想到，从看动漫降维抽象到计算理论这一层（对应到体系结构的实现）那么好像看起来我看动漫的基础就是lambda calculus呢（当然实际上并不是的，这里我指的是计算能力上的等价，ladmda calculus的计算能力是等价于图灵机的所以这里看动漫的基础归结到体系结构的抽象可以是图灵机并等价于lambda calculus）</font></p>
<h4 id="1-3-“双击-QQ”这个过程，都需要用到哪些硬件？"><a href="#1-3-“双击-QQ”这个过程，都需要用到哪些硬件？" class="headerlink" title="1.3 “双击 QQ”这个过程，都需要用到哪些硬件？"></a>1.3 “双击 QQ”这个过程，都需要用到哪些硬件？</h4><p>用户开始对着屏幕上的 QQ 图标双击鼠标了。</p>
<ol>
<li>鼠标就会通过鼠标线给电脑发消息，告知电脑，鼠标向某个方向移动了多少距离</li>
<li>屏幕，也就是显示器，是计算机的输出设备，将计算机处理用户请求展示给用户看</li>
<li>显卡，由显卡控制在显示器的哪个坐标上再绘制一个鼠标箭头</li>
<li>RAM, 坐标值经过鼠标输入中断写入ram对应的屏幕内存对应区域</li>
</ol>
<h4 id="1-4-从点击-QQ-图标，看操作系统全貌"><a href="#1-4-从点击-QQ-图标，看操作系统全貌" class="headerlink" title="1.4 从点击 QQ 图标，看操作系统全貌"></a>1.4 从点击 QQ 图标，看操作系统全貌</h4><ul>
<li>硬盘是个物理设备，要按照规定格式化成为文件系统，才能存放这些程序。文件系统需要一个系统进行统一管理，称为文件管理子系统（File Management Subsystem）。</li>
<li>当操作系统拿到 QQ 的二进制执行文件的时候，就可以运行这个文件了。QQ 的二进制文件是静态的，称为程序（Program），而运行起来的 QQ，是不断进行的，称为进程（Process）。</li>
<li>在操作系统中，也有同样的问题，例如多个进程都要往打印机上打印文件，如果随便乱打印进程，就会出现同样一张纸，第一行是 A 进程输出的文字，第二行是 B 进程输出的文字，全乱套了。所以，打印机的直接操作是放在操作系统内核里面的，进程不能随便操作。但是操作系统也提供一个办事大厅，也就是系统调用（System Call）。</li>
<li>在操作系统中，进程的执行也需要分配 CPU 进行执行，也就是按照程序里面的二进制代码一行一行地执行。于是，为了管理进程，我们还需要一个进程管理子系统（Process Management Subsystem）。如果运行的进程很多，则一个 CPU 会并发运行多个进程，也就需要 CPU 的调度能力了。</li>
<li>在操作系统中，不同的进程有不同的内存空间，但是整个电脑内存就这么点儿，所以需要统一的管理和分配，这就需要内存管理子系统（Memory Management Subsystem）。</li>
</ul>
<p>也可以使用软件外包公司的组织架构模拟以上的os组成模块<br><img src="/images/biji_os_01/WX20190406-234401@2x.png" alt=""></p>
<h4 id="1-5-os组成总览"><a href="#1-5-os组成总览" class="headerlink" title="1.5 os组成总览"></a>1.5 os组成总览</h4><p><img src="/images/biji_os_01/WX20190406-234419@2x.png" alt=""></p>
<h4 id="1-6-课堂练习"><a href="#1-6-课堂练习" class="headerlink" title="1.6 课堂练习"></a>1.6 课堂练习</h4><p>系统调用 kernel/<br>进程管理 kernel/, arch/<arch>/kernel<br>内存管理 mm/, arch/<arch>/mm<br>文件 fs/<br>设备 drivers/char, drivers/block<br>网络 net/</arch></arch></p>
<p><font color="red"><strong>arch</strong></font>代表某种架构</p>
<h3 id="2-常用的Linux命令"><a href="#2-常用的Linux命令" class="headerlink" title="2 常用的Linux命令"></a>2 常用的Linux命令</h3><h4 id="2-1-常用Linux命令图示"><a href="#2-1-常用Linux命令图示" class="headerlink" title="2.1 常用Linux命令图示"></a>2.1 常用Linux命令图示</h4><p><img src="/images/biji_os_01/4.jpg" alt=""></p>
<h4 id="2-2-部分命令在centos体系和ubnutu体系下的差别"><a href="#2-2-部分命令在centos体系和ubnutu体系下的差别" class="headerlink" title="2.2 部分命令在centos体系和ubnutu体系下的差别"></a>2.2 部分命令在centos体系和ubnutu体系下的差别</h4><p><strong>安装软件命令(以安装jdk为例)</strong><br>centos体系：<br>rpm -i jdk-XXX_linux-x64_bin.rpm<br>ubnutu体系:<br>dpkg -i jdk-XXX_linux-x64_bin.deb</p>
<p><strong>服务相关命令（以启动服务为例）</strong><br>centos体系：<br>systemctl start mariadb<br>ubnutu体系:<br>systemctl start mysql</p>
<h4 id="2-3-思路如下"><a href="#2-3-思路如下" class="headerlink" title="2.3 思路如下"></a>2.3 思路如下</h4><ol>
<li>安装jdk，mysql</li>
<li>配置jdbc驱动配置文件</li>
<li>通过jdbc在java app里连接msql并执行相应的数据库操作</li>
</ol>
<h3 id="3-几个常用的系统调用"><a href="#3-几个常用的系统调用" class="headerlink" title="3 几个常用的系统调用"></a>3 几个常用的系统调用</h3><h4 id="3-1-进程管理"><a href="#3-1-进程管理" class="headerlink" title="3.1 进程管理"></a>3.1 进程管理</h4><h5 id="3-1-1-fork"><a href="#3-1-1-fork" class="headerlink" title="3.1.1 fork"></a>3.1.1 fork</h5><p>linux里进程的创建是通过fork父进程完成的，关于fork的详细用法可以参考<a href="https://linux.die.net/man/2/fork" title="这里" target="_blank" rel="noopener">这里</a><br>关于fork可以引申出<font color="red">孤儿进程和僵尸进程</font></p>
<ul>
<li><font color="red">孤儿进程</font>：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li>
<li><font color="red">僵尸进程</font>：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。<h5 id="3-1-2-execve"><a href="#3-1-2-execve" class="headerlink" title="3.1.2 execve"></a>3.1.2 execve</h5>execve用来执行一个二进制可执行文件或者以#! interpreter [optional-arg]为开头的脚本，关于execve的详细用法可以参考<a href="https://linux.die.net/man/2/execve" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-1-3-waitpid"><a href="#3-1-3-waitpid" class="headerlink" title="3.1.3 waitpid"></a>3.1.3 waitpid</h5>waitpid用来等待进程改变状态，常用于父进程等待子进程结束，关于waitpid的详细用法可以参考<a href="https://linux.die.net/man/2/waitpid" title="这里" target="_blank" rel="noopener">这里</a><h4 id="3-2-内存管理"><a href="#3-2-内存管理" class="headerlink" title="3.2 内存管理"></a>3.2 内存管理</h4><em>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。</em><h5 id="3-2-1-brk"><a href="#3-2-1-brk" class="headerlink" title="3.2.1 brk"></a>3.2.1 brk</h5>brk是将数据段(.data)的最高地址指针_edata往高地址推，关于execve的详细用法可以参考<a href="https://linux.die.net/man/2/brk" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-2-2-mmap"><a href="#3-2-2-mmap" class="headerlink" title="3.2.2 mmap"></a>3.2.2 mmap</h5>mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存，关于mmap更详细的用法可以参考<a href="https://linux.die.net/man/3/mmap" title="这里" target="_blank" rel="noopener">这里</a><h4 id="3-3-文件管理"><a href="#3-3-文件管理" class="headerlink" title="3.3 文件管理"></a>3.3 文件管理</h4><em>Linux里一切皆文件</em><h5 id="3-3-1-open"><a href="#3-3-1-open" class="headerlink" title="3.3.1 open"></a>3.3.1 open</h5>open用于打开一个文件，关于open更详细的用法可以参考<a href="https://linux.die.net/man/3/open" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-3-2-close"><a href="#3-3-2-close" class="headerlink" title="3.3.2 close"></a>3.3.2 close</h5>close用于关闭一个文件，关于close更详细的用法可以参考<a href="https://linux.die.net/man/3/close" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-3-3-creat"><a href="#3-3-3-creat" class="headerlink" title="3.3.3 creat"></a>3.3.3 creat</h5>creat用于创建一个文件，关于creat更详细的用法可以参考<a href="https://linux.die.net/man/3/creat" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-3-4-lseek"><a href="#3-3-4-lseek" class="headerlink" title="3.3.4 lseek"></a>3.3.4 lseek</h5>lseek用于跳到文件的某个位置，关于lseek更详细的用法可以参考<a href="https://linux.die.net/man/3/lseek" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-3-5-read"><a href="#3-3-5-read" class="headerlink" title="3.3.5 read"></a>3.3.5 read</h5>read用于读取某个文件，关于read更详细的用法可以参考<a href="https://linux.die.net/man/3/read" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-3-6-write"><a href="#3-3-6-write" class="headerlink" title="3.3.6 write"></a>3.3.6 write</h5>write用于读取某个文件，关于write更详细的用法可以参考<a href="https://linux.die.net/man/3/write" title="这里" target="_blank" rel="noopener">这里</a><h4 id="3-4-信号处理"><a href="#3-4-信号处理" class="headerlink" title="3.4 信号处理"></a>3.4 信号处理</h4><h5 id="3-4-1-kill"><a href="#3-4-1-kill" class="headerlink" title="3.4.1 kill"></a>3.4.1 kill</h5>用户进程通过kill函数，将一个用户信号发送给另一个进程,<strong> 注意这里的kill是指代发送信号而不是杀死进程之类的…</strong>，关于sigaction更详细的用法可以参考<a href="https://linux.die.net/man/3/kill" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-4-2-sigaction"><a href="#3-4-2-sigaction" class="headerlink" title="3.4.2 sigaction"></a>3.4.2 sigaction</h5>sigaction用于注册信号处理函数，用kill发送的信号可以在sigaction中注册相应的信号处理函数用以处理，关于sigaction更详细的用法可以参考<a href="https://linux.die.net/man/3/sigaction" title="这里" target="_blank" rel="noopener">这里</a><h4 id="3-5-进程间通信"><a href="#3-5-进程间通信" class="headerlink" title="3.5 进程间通信"></a>3.5 进程间通信</h4><em>内核可以通过消息队列来实现进程间通信</em><h5 id="3-5-1-msgget"><a href="#3-5-1-msgget" class="headerlink" title="3.5.1 msgget"></a>3.5.1 msgget</h5>创建一个新的消息队列，关于msgget更详细的用法可以参考<a href="https://linux.die.net/man/3/msgget" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-5-2-msgget"><a href="#3-5-2-msgget" class="headerlink" title="3.5.2 msgget"></a>3.5.2 msgget</h5>将消息发送到消息队列，关于msgget更详细的用法可以参考<a href="https://linux.die.net/man/3/msgget" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-5-3-msgrcv"><a href="#3-5-3-msgrcv" class="headerlink" title="3.5.3 msgrcv"></a>3.5.3 msgrcv</h5>从消息队列中取出消息，关于msgget更详细的用法可以参考<a href="https://linux.die.net/man/3/msgget" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-5-4-shmget"><a href="#3-5-4-shmget" class="headerlink" title="3.5.4 shmget"></a>3.5.4 shmget</h5>创建一个共享内存块，关于shmget更详细的用法可以参考<a href="https://linux.die.net/man/3/shmget" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-5-5-shmmat"><a href="#3-5-5-shmmat" class="headerlink" title="3.5.5 shmmat"></a>3.5.5 shmmat</h5>将共享内存块映射到自己的内存空间（比如说自己的进程地址空间，关于shmmat更详细的用法可以参考<a href="https://linux.die.net/man/3/shmmat" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-5-6-sem-wait"><a href="#3-5-6-sem-wait" class="headerlink" title="3.5.6 sem_wait"></a>3.5.6 sem_wait</h5>持有信号量，信号量-1，关于sem_wait更详细的用法可以参考<a href="https://linux.die.net/man/3/sem_wait" title="这里" target="_blank" rel="noopener">这里</a><h5 id="3-5-7-sem-post"><a href="#3-5-7-sem-post" class="headerlink" title="3.5.7 sem_post"></a>3.5.7 sem_post</h5>释放信号量，信号量+1，关于sem_post更详细的用法可以参考<a href="https://linux.die.net/man/3/sem_post" title="这里" target="_blank" rel="noopener">这里</a><h4 id="3-6-网络通信"><a href="#3-6-网络通信" class="headerlink" title="3.6 网络通信"></a>3.6 网络通信</h4><h5 id="3-6-1-socket"><a href="#3-6-1-socket" class="headerlink" title="3.6.1 socket"></a>3.6.1 socket</h5>从tcp/ip 的解度看 socket ，它更多地体现了用户 API 与协议栈的一个中间层接口层。用户通过调用socket API 将报文递交给协议栈，或者从协议栈中接收报文件。关于socket更详细的用法可以参考<a href="https://linux.die.net/man/3/socket" title="这里" target="_blank" rel="noopener">这里</a></li>
</ul>
<h4 id="3-7-小结"><a href="#3-7-小结" class="headerlink" title="3.7 小结"></a>3.7 小结</h4><p><img src="/images/biji_os_01/WX20190407-101258@2x.png" alt=""></p>
<h4 id="3-8-课堂练习"><a href="#3-8-课堂练习" class="headerlink" title="3.8 课堂练习"></a>3.8 课堂练习</h4><p>以执行strace cat /dev/null 为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;/usr/bin/cat&quot;, [&quot;cat&quot;, &quot;/dev/null&quot;, &quot;-o&quot;, &quot;/root/straceout.txt&quot;], [/* 23 vars */]) = 0</span><br><span class="line">brk(NULL)                               = 0x1cda000</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe3f1515000</span><br><span class="line">access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=36309, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 36309, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fe3f150c000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/lib64/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P%\2\0\0\0\0\0&quot;..., 832) = 832</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=2173512, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 3981792, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fe3f0f28000</span><br><span class="line">mprotect(0x7fe3f10eb000, 2093056, PROT_NONE) = 0</span><br><span class="line">mmap(0x7fe3f12ea000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c2000) = 0x7fe3f12ea000</span><br><span class="line">mmap(0x7fe3f12f0000, 16864, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fe3f12f0000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe3f150b000</span><br><span class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe3f1509000</span><br><span class="line">arch_prctl(ARCH_SET_FS, 0x7fe3f1509740) = 0</span><br><span class="line">mprotect(0x7fe3f12ea000, 16384, PROT_READ) = 0</span><br><span class="line">mprotect(0x60b000, 4096, PROT_READ)     = 0</span><br><span class="line">mprotect(0x7fe3f1516000, 4096, PROT_READ) = 0</span><br><span class="line">munmap(0x7fe3f150c000, 36309)           = 0</span><br><span class="line">brk(NULL)                               = 0x1cda000</span><br><span class="line">brk(0x1cfb000)                          = 0x1cfb000</span><br><span class="line">brk(NULL)                               = 0x1cfb000</span><br><span class="line">open(&quot;/usr/lib/locale/locale-archive&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=106070960, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 106070960, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fe3ea9ff000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/usr/share/locale/locale.alias&quot;, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=2502, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe3f1514000</span><br><span class="line">read(3, &quot;# Locale name alias data base.\n#&quot;..., 4096) = 2502</span><br><span class="line">read(3, &quot;&quot;, 4096)                       = 0</span><br><span class="line">close(3)                                = 0</span><br><span class="line">munmap(0x7fe3f1514000, 4096)            = 0</span><br><span class="line">open(&quot;/usr/share/locale/zh_CN.UTF-8/LC_MESSAGES/libc.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/usr/share/locale/zh_CN.utf8/LC_MESSAGES/libc.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/usr/share/locale/zh_CN/LC_MESSAGES/libc.mo&quot;, O_RDONLY) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=81139, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 81139, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fe3f14f5000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/usr/lib64/gconv/gconv-modules.cache&quot;, O_RDONLY) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=26254, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 26254, PROT_READ, MAP_SHARED, 3, 0) = 0x7fe3f150e000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">write(2, &quot;cat\357\274\232\346\227\240\346\225\210\351\200\211\351\241\271 -- o\n&quot;, 24cat：无效选项 -- o</span><br><span class="line">) = 24</span><br><span class="line">open(&quot;/usr/share/locale/zh_CN.UTF-8/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/usr/share/locale/zh_CN.utf8/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/usr/share/locale/zh_CN/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=190751, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 190751, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fe3f14c6000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">open(&quot;/usr/share/locale/zh.UTF-8/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/usr/share/locale/zh.utf8/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/usr/share/locale/zh/LC_MESSAGES/coreutils.mo&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">write(2, &quot;Try &apos;cat --help&apos; for more inform&quot;..., 39Try &apos;cat --help&apos; for more information.</span><br><span class="line">) = 39</span><br><span class="line">close(1)                                = 0</span><br><span class="line">close(2)                                = 0</span><br><span class="line">exit_group(1)                           = ?</span><br><span class="line">+++ exited with 1 +++</span><br></pre></td></tr></table></figure></p>
<h3 id="4-引用链接"><a href="#4-引用链接" class="headerlink" title="4 引用链接"></a>4 引用链接</h3><p><a href="https://computer.howstuffworks.com/computer-run-without-operating-system1.htm" title="computer-run-without-operating-system" target="_blank" rel="noopener">computer-run-without-operating-system</a><br><a href="https://time.geekbang.org/column/article/88060" title="极客时间" target="_blank" rel="noopener">极客时间</a><br><a href="https://www.kernel.org/" title="kernel" target="_blank" rel="noopener">kernel</a><br><a href="https://courses.linuxchix.org/kernel-hacking-2002/08-overview-kernel-source.html" title="overview-kernel-source" target="_blank" rel="noopener">overview-kernel-source</a><br><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html" title="strace" target="_blank" rel="noopener">strace</a><br><a href="https://linux.die.net/man/2/fork" title="linux man" target="_blank" rel="noopener">linux man</a><br><a href="https://www.cnblogs.com/sky-heaven/p/10005642.html" title="Linux内存分配小结--malloc、brk、mmap" target="_blank" rel="noopener">Linux内存分配小结–malloc、brk、mmap</a></p>

	

	

</article>




	<article>
	
		<h1><a href="/2019/01/19/suibi-01/">实习小结</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2019-01-19</span><br />
		
		
	</div>

	

	
		<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p>仔细算一算实习也已经3个多月了，期间犯过一些很严重的错误，导致了同事们的不愉快，我深感抱歉和自责，在此我会分析自己行为的各个方面，希望以后引以为戒。</p>
<h3 id="1-缺陷"><a href="#1-缺陷" class="headerlink" title="1. 缺陷"></a>1. 缺陷</h3><ul>
<li>对代码的理解太过自信，但是局限于个人的能力，我还是会犯一些低级错误，在对代码的语义和上下文不够了解的情况下进行了更改，解决方案：就像我的一位学长兼同事所言，遇事不决先商讨，具体到这个场景就是不确定的时候，整理出解决方案找同事确认，商讨得出结论。</li>
<li>deadline前自乱阵脚，这事的具体体现就是项目进度太过紧凑，一些代码没有经过深思熟虑就提交了，短期看起来似乎是想要为同事分忧，但是其实是给同事增加了很大的review负担以及坏了好心情（说实在的我觉得我非常的内疚），解决方案：首先认清自己的能力和经验，并且短时间不可能存在跨越式发展，虽然想获得同事的认可，但是必须慢下来保证质量，在质量的前提下提高速度，而不是作死猛肝。</li>
<li>抗压能力过强，虽然我其实是一个自己能做的事情不喜欢麻烦别人的人，毕竟大家的时间都很宝贵，但是在工作中该沟通的地方还是必须沟通不能怕麻烦，其实这也是变相的懒惰，长远的看不利于团队协作，解决方案：该定期交流的必须定期交流，另外必须给同事和leader及时反馈，以保证不会出现过多偏误。</li>
<li>部分能力尚且不足，比如说数据结构应用方面的不足，这里没什么好说的，该补的，该review优秀代码的肯定不能少，对数据结构合理应用以及系统设计能力是优先提高的。</li>
<li>三思而后行，这点和2有部分重叠，体现在了我在面对危机问题和压力面前选择盲目的行动其实这是一种战略上的懒惰，解决方案：思考并做出demo（编程方面），在对问题有多个纬度（编程方面，数据结构的选择，算法的选择，设计的选择，网络环境，库的使用，可读性，健壮性，正确性等的考虑）的思考以后再下决断，并且和同事和leader商讨得出的解决方案。</li>
<li>不够努力，对自身的精力管理做的不够好导致下班以后有时没有能够及时调整状态投入学习，解决方案：睡觉or慢跑or冥想，这三种途径可以恢复精力继续学习</li>
</ul>
<h3 id="2-需要坚持的地方"><a href="#2-需要坚持的地方" class="headerlink" title="2. 需要坚持的地方"></a>2. 需要坚持的地方</h3><ul>
<li>以周为区间划分任务，以天为单位去落实todo list，分治任务并留下部分时间应对其他情况</li>
<li>早睡早起（虽然在加班那段时间做的不够好），认识到自身的睡眠是保证精力来源的重要途径，将作息调整在23～7.30有意义身体机能的balance</li>
<li>针对性的学习，在刚接触scala以及类库的那会先看理论然后找exercise去实践是一种有效的途径，当然这不适用于系统的学习，但对于工程实践性价比颇高</li>
<li>在自身能力和时间允许的条件下帮助同事，这也可以提高团队的凝聚力以后为以后的有效沟通做铺垫</li>
<li>理性的看待失败并总结，找出失败的本质并且避免这一类问题，多学习多实践，保持一颗纯粹的心</li>
</ul>
<h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><p>白驹过隙，三个月就这么过去了，在mesoor的日子里收获了很多经验和教训，也认识了很多很棒的同事，感谢扬哥，火火，小晖，法师等同事一直以来以各种形式帮助我成长，我犯下过一些愚蠢的错误，但是我会不断努力成为更优秀的工程师和团队一起奋斗！</p>

	

	

</article>




	<article>
	
		<h1><a href="/2018/12/08/suibi-00/">随想——2018/12/8/22:13</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2018-12-08</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/闲话二三/">闲话二三</a>
			</span>
		
	</div>

	

	
		<h3 id="1-内省（序言）"><a href="#1-内省（序言）" class="headerlink" title="1. 内省（序言）"></a>1. 内省（序言）</h3><p>我之前一直觉得自己是个自制力较好的人，事实证明我自制力只在精神上勉强合格，除此之外自制力还受精力管理，时间管理的影响，但在后两者我做的一塌糊涂，一直单纯的相信自己能hold住的我还是too young too somple，实习2个月了，一直感觉自己做的不够好，安排了路线却发现执行力不行，让我很是难过，经过一段时间的反省我总结出了作为学生的我初入职场在学习与工作之间balance的心得，下面从三个维度精神，精力，时间管理来叙述</p>
<h3 id="2-精神"><a href="#2-精神" class="headerlink" title="2.精神"></a>2.精神</h3><p>我认为人类发展的核心在于探索，而探索来自于好奇心，如果丧失了好奇心人类文明将会停泄不前，无论是在工作中还是学习中，保持一颗好奇的心很重要，你可能会问好奇为什么会这么重要，好奇心可以让你从以下几个维度来思考一个问题，我相信在大多数领域都是通用的：</p>
<ol>
<li>xxx到底是什么,如何产生的（过去）</li>
<li>xxx所引起的后果（现在）</li>
<li>如何解决xxx，是否可以借鉴其他领域（未来）</li>
</ol>
<p>在工业界可能没有很多时间给你思考问题背后的脉络，这就得靠你平常花更多的时间反思梳理和总结了（说起来实习项目组老大给我起了个绰号好奇宝宝= =，也在这里非常感谢我的同事们给我这个萌新解答各种问题），技术的更迭比摩尔定律还快得多，但是看清历史的脉络，以及发展的本质，结合计算机的本质足以成为一个优秀的程序员，但不仅限与此。<br>除了好奇心，自信也很重要，或许今后将会面对各种各样的未知困难，至少在计算机领域一个好的基础就是你思考的基础点，没有什么天马行空的猜测，一切都是按着逻辑行事，所以要相信自己可以在面对未知苦难时利用过去掌握的领域知识逐步求解新问题。<br>最后就是责任心了，程序员作为工程师的一种必然应该具备责任心，体现在工作中就是对自己写的每一行代码负责，力求简洁清晰，我之前天真的想在工程代码中用Y combinator等PL偏向数学的技术在代码里应该没什么问题，但是这个想法在我review各种历史代码的途中被废除了。工程代码的核心是 <font color="red"><em>简洁 健壮 高效 （而不是魔法，魔法可以用在必要的场景比如某些库里封装好）</em></font>，追求cool的编码在工程项目中其实是不负责任的，当然在极客社区不是 ：），最重要的是自己写的代码有时间最好自己维护，不到万不得已不要让别人擦屁股，就算离职至少写好注释（这一点我同事做的挺好，能自己维护自己的代码就自己维护，但有一些N手代码看起来还是很费劲）</p>
<p>简而言之，我认为工程中最重要的精神是：</p>
<ol>
<li>好奇心</li>
<li>自信心</li>
<li>责任心</li>
</ol>
<h3 id="3-精力管理"><a href="#3-精力管理" class="headerlink" title="3.精力管理"></a>3.精力管理</h3><p>说句实话这个问题在我实习之前是完全没有考虑过的（毕竟在学校可以心无旁骛的学习），但是事实证明传统的前后端都比较拼体力，不做好精力管理的话下班就累成猪头了。<br>以下几点是我认为精力管理分四个阶段：</p>
<ol>
<li>体能<br>1.1 规律的作息，没有规律的作息=没有规律的生活，对于程序员来说保护自己的身体=保护了自己的未来<br>1.2 饮食，不能过多的摄入碳水化合物以及糖分，前者会让你血糖身高，胰岛素分泌上升产生困乏，后者还能让你肥胖找不到对象QAQ，我推荐少吃多餐，早上10点和下午4点加餐坚果，水果，平常吃NQI指数高的食物（不懂NQI就吃绿色的蔬菜！）<br>1.3 运动 平常抽20-30min运动，慢跑等</li>
<li>情绪<br>我认为比较好的方法是回忆回忆你生命中遇到的那些贵人，怀着一颗感恩的心会让使得内心宁静</li>
<li>注意力<br>慢慢培养自己对于一件事的注意力，人脑在我的不科学理解下（我没有意思的挖掘我人脑的可能性）是一个单核CPU，当然他有异步模式，但只支持并发不支持并行，这样一次只做好一件事就是必然的，不要幻想着自己能同时做两件烧脑的事情，培养注意力的关键就在于一次做好一件事然后下一件<br>event sort map _.do()</li>
<li>意义感<br>想象一下现在正在做的事对未来的影响！荣耀到最后！</li>
</ol>
<h3 id="4-时间管理"><a href="#4-时间管理" class="headerlink" title="4. 时间管理"></a>4. 时间管理</h3><p>时间管理其实和精力管理密不可分，没有精力的时间管理就是没有汽油的汽车，你想开也发动不了。<br>那么如何做好时间管理呢，我认为最重要的首先是了解自己，认识自己不是个机器人，不可能２４小时都按一个模式执行，并且天天如此，在这里我想强调的是，认识并接纳自己作为人的一面，认识到人性的弱点，做好风险预案，然后将过程拆解的足够仔细，这样成功就不会是一个结果而是process。对于时间的管理我认为以下几点很重要：</p>
<ol>
<li>安排切实可行的计划</li>
<li>拆解计划到每个周（当然也可以每一天）</li>
<li>将每天要做的todo list sort by 优先级</li>
<li>做好风险管理，留出时间给偶发事件</li>
<li>假如上一天未完成，或者遇上偶发事件，将目前的event sort by 优先级继续做事</li>
</ol>
<p>以上就是我对时间管理的心得，原谅我曾经把自己当个机器人，每天15小时坚持一礼拜学习效率大打折扣…</p>
<h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h3><p>以前欠下的技术债从今天开始还，Brain fuck也好，JIT也好，我一定会用心写好每一篇文章，绝不滥竽充数。</p>
<h3 id="6-结语"><a href="#6-结语" class="headerlink" title="6.结语"></a>6.结语</h3><p>感谢学习赋予了我不断探索的乐趣，也感谢一路上的良师益友以及同道之人的指点，书山有路勤为径，学海无涯苦作舟，愿与诸君共勉。</p>
<p><font color="blue">PS: 有在魔都的同学可以联系我呀~周末有空可以一起交流学习（目前主要兴趣在k8s和PL,职业是full stack）</font><br>qq：754572491  wechat: ztq491537461q (加我备注blog~)</p>

	

	

</article>




	<article>
	
		<h1><a href="/2018/09/16/ucore-lab1/">ucore lab1实验小结</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2018-09-16</span><br />
		
			<span class="article__category">
				<a class="article-category-link" href="/categories/操作系统/">操作系统</a>
			</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/uCore/">uCore</a>
			</span>
		
	</div>

	

	
		<h3 id="0-序言"><a href="#0-序言" class="headerlink" title="0 序言"></a>0 序言</h3><p>一直感觉自己这操作系统学的一点也不扎实：（，果然之前秋招提前批被教育了，所以痛定思痛有了本系列文章，CS之路漫漫兮，吾将上下而求索~</p>
<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h3><h4 id="1-1-BIOS"><a href="#1-1-BIOS" class="headerlink" title="1.1 BIOS"></a>1.1 BIOS</h4><p>BIOS实际上是被固化在计算机ROM（只读存储器）芯片上的一个特殊的软件，为上层软件提供最底层的、最直接的硬件控制与支持。更形象地说，BIOS就是PC计算机硬件与上层软件程序之间的一个”桥梁”，负责访问和控制硬件。（BIOS以系统调用trap的形式提供IO 且 只能存在于系统的实模式下）</p>
<h4 id="1-2-BIOS是如何启动的"><a href="#1-2-BIOS是如何启动的" class="headerlink" title="1.2 BIOS是如何启动的"></a>1.2 BIOS是如何启动的</h4><p><img src="/images/ucore_01/bios.jpg" alt=""><br>首先我们必须明白计算机加电的时候是从哪读出第一条指令的，以x86为例，CPU根据CS（代码段寄存器）,IP（指令指针寄存器）的值计算得出<font color="red">PC=16*CS + IP</font>,此时PC为20位的二进制值（因为在实模式下只有20根地址总线，所以只能寻址1MB），在X86架构中 CS:IP 用来表示寻址（这里的PC就是一个概念上的寻址寄存器，实际递增的是IP寄存器），在ARM架构中PC寄存器是存在的（R15），得到地址取出地址中的执行，这条指令是个跳转指令，通过跳转指令跳到BIOS例行程序起始点。BIOS做完计算机硬件自检和初始化后，会选择一个启动设备（例如软盘、硬盘、光盘等），并且读取该设备的第一扇区(即主引导扇区或启动扇区)到内存一个特定的地址0x7c00处，然后CPU控制权会转移到那个地址继续执行。至此BIOS的初始化工作做完了，进一步的工作交给了ucore的bootloader。</p>
<h4 id="1-3-BIOS是如何启动系统的"><a href="#1-3-BIOS是如何启动系统的" class="headerlink" title="1.3 BIOS是如何启动系统的"></a>1.3 BIOS是如何启动系统的</h4><p><img src="/images/ucore_01/bios start.jpg" alt=""></p>
<ol>
<li>BIOS将bootloader（加载程序）从磁盘的主引导扇区(MBR)加载到内存0x7c00</li>
<li>跳转到0000（CS）:7c00（IP）</li>
<li>执行2中地址的bootloader</li>
<li>初始化各种寄存器，禁用中断，使能A20（拓宽地址总线宽度），加载GDT，使能cr0进入保护模式，修改保护模式下的各寄存器值，设置堆栈调用bootmain.c</li>
<li>加载elf格式的OS</li>
</ol>
<h3 id="2-分析make生成执行文件的过程"><a href="#2-分析make生成执行文件的过程" class="headerlink" title="2 分析make生成执行文件的过程"></a>2 分析make生成执行文件的过程</h3><h4 id="2-1-分析操作系统镜像文件ucore-img是如何一步一步生成的？"><a href="#2-1-分析操作系统镜像文件ucore-img是如何一步一步生成的？" class="headerlink" title="2.1 分析操作系统镜像文件ucore.img是如何一步一步生成的？"></a>2.1 分析操作系统镜像文件ucore.img是如何一步一步生成的？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">   // 生成系统镜像</span><br><span class="line">UCOREIMG    := $(call totarget,ucore.img)</span><br><span class="line"></span><br><span class="line">$(UCOREIMG): $(kernel) $(bootblock)</span><br><span class="line">$(V)dd if=/dev/zero of=$@ count=10000 // 创建一个大小为10000字节的串</span><br><span class="line">$(V)dd if=$(bootblock) of=$@ conv=notrunc // 将bootblock默认写入第一个块</span><br><span class="line">$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc  // 将kernel默认写入第二个块</span><br><span class="line"></span><br><span class="line">$(call create_target,ucore.img)</span><br><span class="line"></span><br><span class="line"> // 生成kernel</span><br><span class="line">kernel = $(call totarget,kernel)</span><br><span class="line"></span><br><span class="line">$(kernel): tools/kernel.ld</span><br><span class="line"></span><br><span class="line">$(kernel): $(KOBJS)</span><br><span class="line">	@echo + ld $@</span><br><span class="line">	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)</span><br><span class="line">	@$(OBJDUMP) -S $@ &gt; $(call asmfile,kernel)</span><br><span class="line">	@$(OBJDUMP) -t $@ | $(SED) &apos;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&apos; &gt; $(call symfile,kernel)</span><br><span class="line"></span><br><span class="line">$(call create_target,kernel)</span><br><span class="line"></span><br><span class="line">// 创建启动块</span><br><span class="line">bootfiles = $(call listf_cc,boot)</span><br><span class="line">$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))</span><br><span class="line"></span><br><span class="line">bootblock = $(call totarget,bootblock)</span><br><span class="line"></span><br><span class="line">$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)</span><br><span class="line">@echo + ld $@</span><br><span class="line">$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)</span><br><span class="line">@$(OBJDUMP) -S $(call objfile,bootblock) &gt; $(call asmfile,bootblock)</span><br><span class="line">@$(OBJDUMP) -t $(call objfile,bootblock) | $(SED) &apos;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&apos; &gt; $(call symfile,bootblock)</span><br><span class="line">@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)</span><br><span class="line">@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)</span><br><span class="line"></span><br><span class="line">$(call create_target,bootblock)</span><br></pre></td></tr></table></figure>
<h4 id="2-2-一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><a href="#2-2-一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？" class="headerlink" title="2.2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"></a>2.2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</h4><ol>
<li>主引导记录MBR的大小为512字节</li>
<li>MBR结束字为[0x55 0xAA]<br>在tool/sign.c中可以很清晰的看到MBR的结束标志字（55AA）2字节以及主引导记录大小512字节<br><img src="/images/ucore_01/MBR.jpg" alt=""><h3 id="3-调试BIOS的加载"><a href="#3-调试BIOS的加载" class="headerlink" title="3 调试BIOS的加载"></a>3 调试BIOS的加载</h3></li>
</ol>
<p>实验步骤如下：</p>
<ol>
<li>qemu -hda ucore.img -s -S  # 打开qemu并附加参数-s设置连接端口1234</li>
<li>gdb </li>
<li>target remote localhost:1234 # gdb连接qemu（也可忽略前三步直接make debug）</li>
<li>输入 b  *0x7c00设置断点</li>
<li>continue</li>
<li>x/i $pc # 查看一条当前的指令<br>可以看到0x7c00处的代码和bootasm.S处的代码一致<br><img src="/images/ucore_01/init.jpg" alt=""><br><img src="/images/ucore_01/bootasm.jpg" alt=""></li>
</ol>
<h3 id="4-分析bootloader进入保护模式的过程"><a href="#4-分析bootloader进入保护模式的过程" class="headerlink" title="4 分析bootloader进入保护模式的过程"></a>4 分析bootloader进入保护模式的过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># start address should be 0:7c00, in real mode, the beginning address of the running bootloader</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">.code16                                             # Assemble for 16-bit mode</span><br><span class="line">    cli                                             # Disable interrupts</span><br><span class="line">    cld                                             # String operations increment</span><br><span class="line"></span><br><span class="line">    # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">    xorw %ax, %ax                                   # Segment number zero</span><br><span class="line">    movw %ax, %ds                                   # -&gt; Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; Extra Segment</span><br><span class="line">    movw %ax, %ss                                   # -&gt; Stack Segment</span><br><span class="line"></span><br><span class="line">    # Enable A20:</span><br><span class="line">    #  For backwards compatibility with the earliest PCs, physical</span><br><span class="line">    #  address line 20 is tied low, so that addresses higher than</span><br><span class="line">    #  1MB wrap around to zero by default. This code undoes this.</span><br><span class="line">seta20.1:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    outb %al, $0x64                                 # 0xd1 means: write data to 8042&apos;s P2 port</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">    outb %al, $0x60                                 # 0xdf = 11011111, means set P2&apos;s A20 bit(the 1 bit) to 1</span><br><span class="line"></span><br><span class="line">    # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">    # and segment translation that makes virtual addresses</span><br><span class="line">    # identical to physical addresses, so that the</span><br><span class="line">    # effective memory map does not change during the switch.</span><br><span class="line">    lgdt gdtdesc</span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $CR0_PE_ON, %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line"></span><br><span class="line">    # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">    # Switches processor into 32-bit mode.</span><br><span class="line">    ljmp $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure>
<p>根据代码注释可以总结得bootloaer进入保护模式的流程为：</p>
<ol>
<li>禁用中断</li>
<li>复位标志寄存器</li>
<li>初始化ds，es，ss三个段（设置为0）</li>
<li>使能A20（扩大寻址空间）</li>
<li>跳转到gdtdes中，加载GDT（全局描述符表）</li>
<li>使能cr0，切换到保护模式</li>
</ol>
<h3 id="5-分析bootloader加载ELF格式的OS的过程"><a href="#5-分析bootloader加载ELF格式的OS的过程" class="headerlink" title="5 分析bootloader加载ELF格式的OS的过程"></a>5 分析bootloader加载ELF格式的OS的过程</h3><h4 id="5-2-elf文件格式"><a href="#5-2-elf文件格式" class="headerlink" title="5.2 elf文件格式"></a>5.2 elf文件格式</h4><p><img src="/images/ucore_01/elf.png" alt=""><br><img src="/images/ucore_01/elf_seek.png" alt=""></p>
<h4 id="5-1-bootloader如何读取硬盘扇区的？"><a href="#5-1-bootloader如何读取硬盘扇区的？" class="headerlink" title="5.1 bootloader如何读取硬盘扇区的？"></a>5.1 bootloader如何读取硬盘扇区的？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">* waitdisk - wait for disk ready */</span><br><span class="line">static void</span><br><span class="line">waitdisk(void) &#123;</span><br><span class="line">    while ((inb(0x1F7) &amp; 0xC0) != 0x40)</span><br><span class="line">        /* do nothing */;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* readsect - read a single sector at @secno into @dst */</span><br><span class="line">static void</span><br><span class="line">readsect(void *dst, uint32_t secno) &#123;</span><br><span class="line">    // wait for disk to be ready</span><br><span class="line">    waitdisk(); // 等待磁盘就绪</span><br><span class="line"></span><br><span class="line">    outb(0x1F2, 1);    // 将要存取的扇区数（此处为1）存到0x1F2</span><br><span class="line">    outb(0x1F3, secno &amp; 0xFF);</span><br><span class="line">    outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);</span><br><span class="line">    outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF); </span><br><span class="line">    outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);// 0x1F3-0x1F6被用来设置扇区偏移</span><br><span class="line">    outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors，将READ命令存储到0x1F7（用来发起命令读取扇区）</span><br><span class="line"></span><br><span class="line">    // wait for disk to be ready</span><br><span class="line">    waitdisk(); // 等待磁盘就绪</span><br><span class="line"></span><br><span class="line">    // read a sector</span><br><span class="line">    insl(0x1F0, dst, SECTSIZE / 4);  // 通过CPU将数据从磁盘读到RAM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读扇区的流程总结为：</p>
<ol>
<li>等待磁盘准备好</li>
<li>写地址0x1f2~0x1f5,0x1f7,发出读取磁盘的命令</li>
<li>等待磁盘准备好</li>
<li>调用函数insl把扇区数据读到内存</li>
</ol>
<h4 id="5-2-bootloader是如何加载ELF格式的OS？"><a href="#5-2-bootloader是如何加载ELF格式的OS？" class="headerlink" title="5.2 bootloader是如何加载ELF格式的OS？"></a>5.2 bootloader是如何加载ELF格式的OS？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/* *</span><br><span class="line"> * readseg - read @count bytes at @offset from kernel into virtual address @va,</span><br><span class="line"> * might copy more than asked.</span><br><span class="line"> * */</span><br><span class="line">static void</span><br><span class="line">readseg(uintptr_t va, uint32_t count, uint32_t offset) &#123;</span><br><span class="line">    uintptr_t end_va = va + count;</span><br><span class="line"></span><br><span class="line">    // round down to sector boundary</span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    // translate from bytes to sectors; kernel starts at sector 1</span><br><span class="line">    uint32_t secno = (offset / SECTSIZE) + 1;</span><br><span class="line"></span><br><span class="line">    // If this is too slow, we could read lots of sectors at a time.</span><br><span class="line">    // We&apos;d write more to memory than asked, but it doesn&apos;t matter --</span><br><span class="line">    // we load in increasing order.</span><br><span class="line">    for (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">        readsect((void *)va, secno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* bootmain - the entry of bootloader */</span><br><span class="line">void</span><br><span class="line">bootmain(void) &#123;</span><br><span class="line">    // 读取磁盘的第一页(大小为4K),这里一个sectsize为512字节</span><br><span class="line">    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);</span><br><span class="line"></span><br><span class="line">    // 判断是否是合法的elf文件格式</span><br><span class="line">    if (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        goto bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct proghdr *ph, *eph;</span><br><span class="line"></span><br><span class="line">    // ELF头部有描述ELF文件应加载到内存什么位置的描述表，这里读取出来将之存入ph</span><br><span class="line">    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">	// 读出elf文件的段个数作为索引值</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    for (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">	// 读取每个elf文件段的内容</span><br><span class="line">        readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // call the entry point from the ELF header</span><br><span class="line">    // note: does not return</span><br><span class="line">    ((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    outw(0x8A00, 0x8A00);</span><br><span class="line">    outw(0x8A00, 0x8E00);</span><br><span class="line"></span><br><span class="line">    /* do nothing */</span><br><span class="line">    while (1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中可以看出程序控制流：</p>
<ol>
<li>运行bootmain，调用readseg读取多个扇区</li>
<li>readseg循环执行readsect读取每个扇区</li>
<li>返回bootmain，判断elf格式</li>
<li>将ELFheader读入ph（pragram header,程序头表）</li>
<li>将ph中各个section读入内存</li>
<li>通过内核入口函数加载内核</li>
</ol>
<h3 id="6-实现函数调用堆栈跟踪函数"><a href="#6-实现函数调用堆栈跟踪函数" class="headerlink" title="6 实现函数调用堆栈跟踪函数"></a>6 实现函数调用堆栈跟踪函数</h3><p>这里的代码根据注释不难写出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    void print_stackframe(void) &#123;</span><br><span class="line">        uint32_t ebp=read_ebp();        //(1) call read_ebp() to get the value of ebp. the type is (uint32_t)</span><br><span class="line">        uint32_t eip=read_eip();        //(2) call read_eip() to get the value of eip. the type is (uint32_t)</span><br><span class="line">        for(int i=0;i&lt;STACKFRAME_DEPTH&amp;&amp;ebp!=0;i++)&#123;    //(3) from 0 .. STACKFRAME_DEPTH</span><br><span class="line">              cprintf(&quot;ebp:0x%08x   eip:0x%08x &quot;,ebp,eip);    //(3.1)printf value of ebp, eip</span><br><span class="line">              uint32_t *tmp=(uint32_t *)ebp+2;</span><br><span class="line">              cprintf(&quot;arg :0x%08x 0x%08x 0x%08x 0x%08x&quot;,*(tmp+0),*(tmp+1),*(tmp+2),*(tmp+3));    //(3.2)(uint32_t)calling </span><br><span class="line"></span><br><span class="line">arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4]</span><br><span class="line">              cprintf(&quot;\n&quot;);            //(3.3) cprintf(&quot;\n&quot;);</span><br><span class="line">              print_debuginfo(eip-1);    //(3.4) call print_debuginfo(eip-1) to print the C calling function name and line </span><br><span class="line"></span><br><span class="line">number, etc.</span><br><span class="line">              eip=((uint32_t *)ebp)[1];</span><br><span class="line">              ebp=((uint32_t *)ebp)[0];    //(3.5) popup a calling stackframe</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如图所示：<br><img src="/images/ucore_01/5lab.jpg" alt=""></p>
<p>ebp是栈底指针，从该地址为基准，向上（栈底方向）能获取返回地址、参数值，向下（栈顶方向）能获取函数局部变量值，而该地址处又存储着上一层函数调用时的ebp值，eip则是指令指针寄存器保存着下一条指令的地址,最后一行输出的信息是debug_info，查看该函数定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void print_debuginfo(uintptr_t eip) &#123;</span><br><span class="line">    struct eipdebuginfo info;</span><br><span class="line">    if (debuginfo_eip(eip, &amp;info) != 0) &#123;</span><br><span class="line">        cprintf(&quot;    &lt;unknow&gt;: -- 0x%08x --\n&quot;, eip);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        char fnname[256];</span><br><span class="line">        int j;</span><br><span class="line">        for (j = 0; j &lt; info.eip_fn_namelen; j ++) &#123;</span><br><span class="line">            fnname[j] = info.eip_fn_name[j];</span><br><span class="line">        &#125;</span><br><span class="line">        fnname[j] = &apos;\0&apos;;</span><br><span class="line">        cprintf(&quot;    %s:%d: %s+%d\n&quot;, info.eip_file, info.eip_line,</span><br><span class="line">                fnname, eip - info.eip_fn_addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出最行一行输出的信息是源码所在文件名，源码所在行数（eip指向的指令对应），函数名，源码的长度（当前指令执行位置-函数起始位置）或者是不合法的eip（没找到eip对应的info，这里的info就是eipdebuginfo数据结构）<br>最后一个0x00007d63不合法的原因是我们还没有写内存管理模块（没有引入虚拟地址的抽象）…这里程序的堆栈空间范围在0~0x7c00(在bootasm.S中,感谢TsushimaAlice同学告知)所以超出堆栈的行为是未定义的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">kern_init(void)&#123;</span><br><span class="line">    extern char edata[], end[];</span><br><span class="line">    memset(edata, 0, end - edata);</span><br><span class="line"></span><br><span class="line">    cons_init();                // init the console</span><br><span class="line"></span><br><span class="line">    const char *message = &quot;(THU.CST) os is loading ...&quot;;</span><br><span class="line">    cprintf(&quot;%s\n\n&quot;, message);</span><br><span class="line"></span><br><span class="line">    print_kerninfo();</span><br><span class="line"></span><br><span class="line">    grade_backtrace();</span><br><span class="line"></span><br><span class="line">    pmm_init();                 // init physical memory management</span><br><span class="line"></span><br><span class="line">    pic_init();                 // init interrupt controller</span><br><span class="line">    idt_init();                 // init interrupt descriptor table</span><br><span class="line"></span><br><span class="line">    clock_init();               // init clock interrupt</span><br><span class="line">    intr_enable();              // enable irq interrupt</span><br><span class="line"></span><br><span class="line">    //LAB1: CAHLLENGE 1 If you try to do it, uncomment lab1_switch_test()</span><br><span class="line">    // user/kernel mode switch test</span><br><span class="line">    lab1_switch_test();</span><br><span class="line"></span><br><span class="line">    /* do nothing */</span><br><span class="line">    while (1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="7-完善中断初始化和处理"><a href="#7-完善中断初始化和处理" class="headerlink" title="7 完善中断初始化和处理"></a>7 完善中断初始化和处理</h3><p>在X86架构中，中断可以分为3种：</p>
<ol>
<li>和CPU无关的，比如外设的请求等，这些属于Interrupt。</li>
<li>和CPU有关的，比如除0，page fault等，这些属于Exception。</li>
<li>系统调用，这些属于Trap</li>
</ol>
<h4 id="7-1-中断描述符表项及字段含义"><a href="#7-1-中断描述符表项及字段含义" class="headerlink" title="7.1 中断描述符表项及字段含义"></a>7.1 中断描述符表项及字段含义</h4><p><img src="/images/ucore_01/IDT.png" alt=""><br>可以看出，一个表项占32*2位，8个字节。0到15位和48到63位为偏移量的低位和高位。16到31位是段选择子。 通过这几个数据来找到中断处理代码的入口。</p>
<h4 id="7-2-初始化idt"><a href="#7-2-初始化idt" class="headerlink" title="7.2 初始化idt"></a>7.2 初始化idt</h4><p>中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void idt_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* LAB1 YOUR CODE : STEP 2 */</span><br><span class="line">    /* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?</span><br><span class="line">      *     All ISR&apos;s entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?</span><br><span class="line">      *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c</span><br><span class="line">      *     (try &quot;make&quot; command in lab1, then you will find vector.S in kern/trap DIR)</span><br><span class="line">      *     You can use  &quot;extern uintptr_t __vectors[];&quot; to define this extern variable which will be used later.</span><br><span class="line">      * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT).</span><br><span class="line">      *     Can you see idt[256] in this file? Yes, it&apos;s IDT! you can use SETGATE macro to setup each item of IDT</span><br><span class="line">      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using &apos;lidt&apos; instruction.</span><br><span class="line">      *     You don&apos;t know the meaning of this instruction? just google it! and check the libs/x86.h to know more.</span><br><span class="line">      *     Notice: the argument of lidt is idt_pd. try to find it!</span><br><span class="line">      */</span><br><span class="line">    int i = 0;</span><br><span class="line">    extern uintptr_t __vectors[];</span><br><span class="line">    for(i = 0; i &lt; 255; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">		//  vectors 中存储了中断处理程序的入口地址。vectors 定义在 vector.S 文件中，通过一个工具程序 vector.c 生成</span><br><span class="line">        SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], 0); </span><br><span class="line">    &#125;</span><br><span class="line">	// 切换用户模式到内核模式</span><br><span class="line">    SETGATE(idt[T_SWITCH_TOK], 1, GD_KTEXT, __vectors[T_SWITCH_TOK], 3);// </span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>思路是：</p>
<ol>
<li>通过SETGATE宏初始化idt表（这里体现为一维数组）</li>
<li>准备执行lidt指令，因为trap是系统调用，所以执行idt_init的时候是在DPL_USER（3）的模式，而根据实验指导书，lidt需要在DPL_KERNEL（0）模式执行，所以需要切换用户模式到内核模式</li>
<li>执行lidt，使用一个包含线性地址基址和界限的内存操作数来加载IDT</li>
</ol>
<h4 id="7-3-时钟中断"><a href="#7-3-时钟中断" class="headerlink" title="7.3 时钟中断"></a>7.3 时钟中断</h4><p>中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">	/* LAB1 YOUR CODE : STEP 3 */</span><br><span class="line">	/* handle the timer interrupt */</span><br><span class="line">	/* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in </span><br><span class="line"></span><br><span class="line">kern/driver/clock.c</span><br><span class="line">	* (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().</span><br><span class="line">	* (3) Too Simple? Yes, I think so!</span><br><span class="line">	*/</span><br><span class="line">	ticks ++;</span><br><span class="line">	if (ticks % TICK_NUM == 0) &#123;</span><br><span class="line">	print_ticks();</span><br><span class="line">	&#125;</span><br><span class="line">break;</span><br></pre></td></tr></table></figure>
<p>思路是：每次 handles or dispatches an exception/interrupt都会调用trap，trap中通过累加tick这个时钟周期的全局变量（定义在clock.c）到100来触发时钟中断</p>
<h3 id="8-小结"><a href="#8-小结" class="headerlink" title="8 小结"></a>8 小结</h3><p>bootloader的启动到OS的加载流程为：</p>
<ol>
<li>禁用中断</li>
<li>复位标志寄存器</li>
<li>初始化ds，es，ss三个段（设置为0）</li>
<li>使能A20（扩大寻址空间）</li>
<li>跳转到gdtdes中，加载GDT（全局描述符表）</li>
<li>使能cr0，切换到保护模式</li>
<li>切换到32位模式</li>
<li>修改保护模式下各个寄存器的值</li>
<li>设置堆栈以调用C,初始化栈区（0x0~0x7c00）</li>
<li>调用bootmain.c</li>
<li>运行bootmain，调用readseg读取多个扇区</li>
<li>readseg循环执行readsect读取每个扇区</li>
<li>返回bootmain，判断elf格式</li>
<li>将ELFheader读入ph（pragram header,程序头表）</li>
<li>将ph中各个section读入内存</li>
<li>通过内核入口函数加载内核</li>
</ol>
<p>总的来说实验量还是很好的，实验指导书也很到位，看项目级代码果然需要一个静态分析利器啊，感谢清华！</p>
<h3 id="9-Reference"><a href="#9-Reference" class="headerlink" title="9 Reference"></a>9 Reference</h3><p><a href="https://www.jianshu.com/p/47dd6d3f551e" title="TsushimaAlice同学 简书 lab1" target="_blank" rel="noopener">TsushimaAlice同学 简书 lab1</a></p>

	

	

</article>




	<article>
	
		<h1><a href="/2018/09/07/design-pattern_00/">西天取经之设计模式之道（序言）</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2018-09-07</span><br />
		
			<span class="article__category">
				<a class="article-category-link" href="/categories/设计模式/">设计模式</a>
			</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/设计之道/">设计之道</a>
			</span>
		
	</div>

	

	
		<p>本系列文章用于学习设计模式之道</p>
<h3 id="0-序言"><a href="#0-序言" class="headerlink" title="0 序言"></a>0 序言</h3><p>随着写了各种各样范型的语言（OOP，过程式，声明式，一点点逻辑Coq），我觉得是时候总结该怎么有效的组织代码了，毕竟再过不久就要面向业务需求编程，本系列对于每个模式分为三个部分</p>
<ol>
<li>模式的讲解（what and why ，how）</li>
<li>模式实战</li>
<li>模式之融汇贯通</li>
</ol>
<p>考虑到本人目前为一个尚未从业的计算机本科生（马上大四了…），工程方面只能说勉强入了个门，所以总结暂时集中在1和2部分，以后在源码分析系列会与剖析各类源码的设计思想穿插讲解第3部分，在这里非常希望各位前辈和同学能给我留言交流，十分感谢！</p>
<h3 id="1-目录"><a href="#1-目录" class="headerlink" title="1 目录"></a>1 目录</h3>
	

	

</article>





	<span class="different-posts">📖 <a href="/page/2">more posts</a> 📖</span>



	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<p>Hi there, <br />welcome to my Blog glad you found it. Have a look around, will you?</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		  <li class="footer-links__link"><a href="/atom.xml">RSS</a></li>
	    
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2021 Jason | Powered by <a href="https://hexo.io/">Hexo</a> | Theme <a href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>
