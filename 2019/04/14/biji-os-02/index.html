<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>趣谈Linux操作系统笔记02（对应06-08） | The Tao of Jason</title>
	<link rel="stylesheet" href="/css/style.css" />
	
      <link rel="alternate" href="/atom.xml" title="The Tao of Jason" type="application/atom+xml">
    
</head>

<body>

	<header class="header">
		<nav class="header__nav">
			
				<a href="/archives" class="header__link">Archive</a>
			
				<a href="/tags" class="header__link">Tags</a>
			
				<a href="/atom.xml" class="header__link">RSS</a>
			
		</nav>
		<h1 class="header__title"><a href="/">The Tao of Jason</a></h1>
		<h2 class="header__subtitle"></h2>
	</header>

	<main>
		<article>
	
		<h1>趣谈Linux操作系统笔记02（对应06-08）</h1>
	
	<div class="article__infos">
		<span class="article__date">2019-04-14</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-link" href="/tags/os/">os</a>
			</span>
		
	</div>

	

	
		<h3 id="0-计算机的工作模式"><a href="#0-计算机的工作模式" class="headerlink" title="0 计算机的工作模式"></a>0 计算机的工作模式</h3><h4 id="0-1-硬件图和计算机的逻辑图"><a href="#0-1-硬件图和计算机的逻辑图" class="headerlink" title="0.1 硬件图和计算机的逻辑图"></a>0.1 硬件图和计算机的逻辑图</h4><p><img src="/images/biji_os_02/1.png" alt=""></p>
<h4 id="0-2-cpu的组成"><a href="#0-2-cpu的组成" class="headerlink" title="0.2 cpu的组成"></a>0.2 cpu的组成</h4><ol>
<li>运算单元</li>
<li>数据单元</li>
<li>控制单元<br><img src="/images/biji_os_02/2.png" alt=""></li>
</ol>
<h3 id="1-x86架构"><a href="#1-x86架构" class="headerlink" title="1 x86架构"></a>1 x86架构</h3><h4 id="1-1-历史"><a href="#1-1-历史" class="headerlink" title="1.1 历史"></a>1.1 历史</h4><p>x86泛指一系列由英特尔公司开发处理器的架构，这类处理器最早为1978年面市的“Intel 8086”CPU。<br>该系列较早期的处理器名称是以数字来表示80x86。由于以“86”作为结尾，包括Intel 8086、80186、80286、80386以及80486，因此其架构被称为“x86”。由于数字并不能作为注册商标，因此Intel及其竞争者均在新一代处理器使用可注册的名称，如Pentium。现时英特尔将其称为IA-32，全名为“Intel Architecture, 32-bit”，一般情形下指代32位的架构。</p>
<h4 id="1-2-8086的原理"><a href="#1-2-8086的原理" class="headerlink" title="1.2 8086的原理"></a>1.2 8086的原理</h4><p>8086的cpu包含以下几个部分：</p>
<ul>
<li>数据单元：AX、BX、CX、DX、SP、BP、SI、DI寄存器</li>
<li>控制单元：IP（指令指针寄存器，指向代码段中下一条指令的位置 ）、CS（代码段寄存器（Code Segment Register），通过它可以找到代码在内存中的位置）、DS（数据段的寄存器，通过它可以找到数据在内存中的位置）、SS（栈寄存器）、ES<br><img src="/images/biji_os_02/3.png" alt=""><h4 id="1-3-课堂练习"><a href="#1-3-课堂练习" class="headerlink" title="1.3 课堂练习"></a>1.3 课堂练习</h4>Q: mov, call, ret, jmp, int, add, or, xor, shl, ahr, push, pop, inc, dec, sub, cmp指令含义？<br>A: </li>
<li>mov: 将第二个操作数（源操作数）复制到第一个操作数（目标操作数）。源操作数可以是立即值，通用寄存器，段寄存器或存储器位置; 目标寄存器可以是通用寄存器，段寄存器或存储器位置。两个操作数必须大小相同，可以是字节，字，双字或四字。<font color="red">MOV指令不能用于加载CS寄存器。尝试这样做会导致无效的操作码异常（#UD）。要加载CS寄存器，请使用far JMP，CALL或RET指令。</font></li>
<li>call : 保存将堆栈和分支上的信息链接到使用目标操作数指定的调用过程的过程。目标操作数指定被调用过程中第一条指令的地址。操作数可以是立即值，通用寄存器或存储器位置。</li>
<li>ret : 将程序控制流转移到位于堆栈顶部的返回地址。地址通常由CALL指令放在堆栈上，并返回到CALL指令后面的指令。</li>
<li>jmp : 将程序控制流转移到指令流中的不同点而不记录返回信息。<br>int : 调用中断</li>
<li>add : 添加目标操作数（第一个操作数）和源操作数（第二个操作数），然后将结果存储在目标操作数中。目标操作数可以是寄存器或存储器位置; 源操作数可以是立即数，寄存器或存储器位置。（但是，在一条指令中不能使用两个存储器操作数。）当立即值用作操作数时，它将符号扩展为目标操作数格式的长度。ADD指令执行整数加法。它评估有符号和无符号整数操作数的结果，并设置CF和OF标志，分别表示有符号或无符号结果中的进位（溢出）。SF标志指示签名结果的符号</li>
<li>or : 在目标（第一个）和源（第二个）操作数之间执行按位包含OR运算，并将结果存储在目标操作数位置。源操作数可以是立即数，寄存器或存储器位置; 目标操作数可以是寄存器或存储器位置。（但是，在一条指令中不能使用两个存储器操作数。）如果第一和第二操作数的相应位都为0，则OR指令结果的每一位都设置为0; 否则，每个位都设置为1。</li>
<li>xor : 对目标（第一个）和源（第二个）操作数执行按位异或（XOR）运算，并将结果存储在目标操作数位置。源操作数可以是立即数，寄存器或存储器位置; 目标操作数可以是寄存器或存储器位置。（但是，一条指令不能使用两个存储器操作数。）如果操作数的相应位不同，则结果的每一位都为1; 如果相应的位相同，则每个位为0。</li>
<li>shl : 逻辑左移</li>
<li>shr :逻辑右移</li>
<li>push : 堆栈指针寄存器的值递减，然后将源操作数存储在堆栈顶部</li>
<li>pop:  将值从堆栈顶部加载到使用目标操作数（或显式操作码）指定的位置，然后递增堆栈指针。目标操作数可以是通用寄存器，存储器位置或段寄存器。</li>
<li>inc: 将1添加到目标操作数，同时保留CF标志的状态。目标操作数可以是寄存器或存储器位置。该指令允许更新循环计数器而不会干扰CF标志。（使用立即操作数为1的ADD指令执行更新CF标志的增量操作。）</li>
<li>dec: 从目标操作数中减去1，同时保留CF标志的状态。目标操作数可以是寄存器或存储器位置。该指令允许更新循环计数器而不会干扰CF标志。（要执行更新CF标志的减量操作，请使用立即操作数为1的SUB指令。）</li>
<li>sub : 从第一个操作数（目标操作数）中减去第二个操作数（源操作数），并将结果存储在目标操作数中。目标操作数可以是寄存器或存储器位置; 源操作数可以是立即数，寄存器或内存位置。（但是，在一条指令中不能使用两个存储器操作数。）当立即值用作操作数时，它将符号扩展为目标操作数格式的长度。SUB指令执行整数减法。它评估有符号和无符号整数操作数的结果，并设置OF和CF标志，分别表示有符号或无符号结果中的溢出。SF标志指示签名结果的符号。</li>
<li>cmp: 比较第一个源操作数和第二个源操作数，并根据结果设置EFLAGS寄存器中的状态标志。通过从第一个操作数中减去第二个操作数，然后以与SUB指令相同的方式设置状态标志来执行比较。当立即值用作操作数时，它将符号扩展为第一个操作数的长度。</li>
</ul>
<h3 id="2-Linux内核启动过程（bootloader）"><a href="#2-Linux内核启动过程（bootloader）" class="headerlink" title="2 Linux内核启动过程（bootloader）"></a>2 Linux内核启动过程（bootloader）</h3><h4 id="2-1-启动过程描述"><a href="#2-1-启动过程描述" class="headerlink" title="2.1 启动过程描述"></a>2.1 启动过程描述</h4><p><img src="/images/biji_os_02/4.png" alt=""></p>
<ol>
<li>主板加电，cpu从rom中读取BIOS执行（通过将CS 设置为 0xFFFF，将 IP 设置为 0x0000，跳转到ROM中进行初始化）</li>
<li>BIOS做完计算机硬件自检和初始化后，会选择一个启动设备（例如软盘、硬盘、光盘等）</li>
<li>将 boot.img 从启动设备的主引导扇区(MBR)加载到内存中的 0x7c00（从现在开始进入bootloader，grub2为例）</li>
<li>boot.img加载core.img的第一个扇区diskboot.img（diskboot.img复杂加载core.img的其余模块）</li>
<li>diskboot.img通过启用分段和分页将系统从实模式切换到保护模式增大以寻址空间（为了解压缩lzma_decompress.img）<br><img src="/images/biji_os_02/5.png" alt=""></li>
<li>解压缩kernel.img,跳转到kernel.img开始执行</li>
<li>grub load config解析操作系统配置文件（grub.conf），经过一系列的系统配置初始化函数，最后调用grub_command_execute启动内核</li>
</ol>
<h4 id="2-2-启动过程小结图"><a href="#2-2-启动过程小结图" class="headerlink" title="2.2 启动过程小结图"></a>2.2 <font color="red">启动过程小结图</font></h4><p><img src="/images/biji_os_02/6.png" alt=""><br><img src="/images/biji_os_02/7.png" alt=""><br><img src="/images/biji_os_02/8.png" alt=""></p>
<h3 id="3-内核初始化"><a href="#3-内核初始化" class="headerlink" title="3 内核初始化"></a>3 内核初始化</h3><h4 id="3-1-内核初始化流程"><a href="#3-1-内核初始化流程" class="headerlink" title="3.1 内核初始化流程"></a>3.1 内核初始化流程</h4><p><img src="/images/biji_os_02/9.png" alt=""></p>
<ol>
<li>调用内核初始化函数start_kernel()</li>
<li>初始化进程列表，创建0号进程，这是唯一一个没有通过 fork 或者 kernel_thread 产生的进程，是进程列表的第一个</li>
<li>调用trap_init()初始化中断门</li>
<li>调用mm_init()初始化内存管理模块</li>
<li>调用sched_init()初始化调度模块</li>
<li>调用vfs_caches_init()初始化基于内存的文件系统rootfs</li>
<li>调用rest_init()来做其他方面的初始化<h4 id="3-2-系统调用流程"><a href="#3-2-系统调用流程" class="headerlink" title="3.2 系统调用流程"></a>3.2 系统调用流程</h4><img src="/images/biji_os_02/10.png" alt=""></li>
</ol>
<h4 id="3-3-rest-init"><a href="#3-3-rest-init" class="headerlink" title="3.3 rest_init()"></a>3.3 rest_init()</h4><ul>
<li>调用kernel_thread(kernel_init, NULL, CLONE_FS)创建第1号进程（用户态所有进程的祖先）</li>
<li>调用kernel_thread(kernel_init, NULL, CLONE_FS|CLONE_FILES)创建2号进程（用户态所有进程的祖先）</li>
</ul>
<font color="red">这里的函数 kthreadd，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。</font>

<h4 id="3-4-小结流程"><a href="#3-4-小结流程" class="headerlink" title="3.4 小结流程"></a>3.4 小结流程</h4><p><img src="/images/biji_os_02/11.png" alt=""></p>
<h3 id="4-引用链接"><a href="#4-引用链接" class="headerlink" title="4 引用链接"></a>4 引用链接</h3><p><a href="https://zh.wikipedia.org/wiki/X86" title="x86" target="_blank" rel="noopener">x86</a><br><a href="https://www.felixcloutier.com/x86/" title="x86 and amd64 instruction reference" target="_blank" rel="noopener">x86 and amd64 instruction reference</a></p>

	

	
		<span class="different-posts"><a href="/2019/04/14/biji-os-02/" onclick="window.history.go(-1); return false;">⬅️ Go back </a></span>

	

</article>

	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<p>Hi there, <br />welcome to my Blog glad you found it. Have a look around, will you?</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		  <li class="footer-links__link"><a href="/atom.xml">RSS</a></li>
	    
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2021 Jason | Powered by <a href="https://hexo.io/">Hexo</a> | Theme <a href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>
